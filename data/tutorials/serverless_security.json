{
  "id": "serverless-security-tutorial",
  "title": "Serverless Security",
  "description": "Comprehensive serverless security tutorials covering AWS Lambda, Azure Functions, GCP Cloud Functions, event trigger abuse, cold-start timing attacks, environment variable exposure, IAM misconfiguration, and CI/CD security for serverless functions.",
  "type": "tutorial",
  "steps": [
    {
      "id": "serverless-function-fundamentals",
      "title": "Serverless Function Fundamentals",
      "content": "OBJECTIVE: Understand serverless function architecture and identify potential security boundaries.\n\nACADEMIC BACKGROUND:\nServerless functions (FaaS) execute code in ephemeral containers managed by cloud providers. According to OWASP, serverless applications introduce unique security challenges due to their event-driven nature, shared infrastructure, and limited visibility.\n\nKey Serverless Concepts:\n- Function as a Service (FaaS): Code execution without managing servers\n- Event triggers: HTTP requests, scheduled events, message queues, file uploads\n- Runtime environments: Node.js, Python, Java, .NET, Go\n- Cold starts: Initial execution latency when function is not cached\n- Stateless execution: Functions should not rely on local state\n\nSTEP-BY-STEP:\n\n1. ANALYZE FUNCTION ARCHITECTURE:\n\n   a) Examine function deployment packages:\n   ```bash\n   # AWS Lambda - check deployment package contents\n   aws lambda get-function --function-name my-function --query 'Code.Location'\n   unzip -l deployment-package.zip\n\n   # Azure Functions - examine function app structure\n   az functionapp deployment source show --name myapp --resource-group mygroup\n\n   # GCP Cloud Functions - inspect function source\n   gcloud functions describe my-function --region=us-central1\n   ```\n\n   b) Review function configurations:\n   ```bash\n   # Check runtime, memory, timeout settings\n   aws lambda get-function-configuration --function-name my-function\n   az functionapp config show --name myapp --resource-group mygroup\n   gcloud functions describe my-function --region=us-central1\n   ```\n\n2. IDENTIFY EVENT TRIGGERS:\n\n   a) Map all function triggers:\n   ```bash\n   # AWS - list Lambda triggers\n   aws lambda list-event-source-mappings --function-name my-function\n\n   # Azure - check function bindings\n   az functionapp config appsettings list --name myapp --resource-group mygroup\n\n   # GCP - examine Cloud Function triggers\n   gcloud functions event-types list\n   ```\n\n   b) Test trigger validation:\n   ```bash\n   # Send test events to functions\n   aws lambda invoke --function-name my-function --payload '{\"test\":\"data\"}' response.json\n   ```\n\nWHAT TO LOOK FOR:\n- Large deployment packages with unnecessary dependencies\n- Functions with excessive memory/timeout allocations\n- Unauthenticated HTTP triggers exposed to internet\n- Functions triggered by sensitive events (S3 bucket changes, database updates)\n- Runtime versions that are end-of-life or unpatched\n\nCOMMON PITFALLS:\n- Avoid storing sensitive data in function code or environment variables\n- Implement proper input validation for all event triggers\n- Use least privilege IAM roles for function execution\n- Monitor function execution logs and metrics\n- Implement proper error handling to avoid information disclosure\n- Consider function cold start impacts on security controls",
      "tags": ["serverless", "security", "lambda", "functions", "fundamentals"]
    },
    {
      "id": "environment-variable-secret-management",
      "title": "Environment Variable & Secret Management",
      "content": "OBJECTIVE: Identify and exploit environment variable exposure and secret management weaknesses.\n\nACADEMIC BACKGROUND:\nServerless functions commonly use environment variables for configuration, but these can leak sensitive information. Research from Cloud Security Alliance shows that misconfigured environment variables are a top serverless security risk.\n\nEnvironment Variable Risks:\n- API keys, database credentials, encryption keys\n- Internal service URLs and ports\n- Debug flags that enable verbose logging\n- Configuration overrides that bypass security controls\n\nSTEP-BY-STEP:\n\n1. ENUMERATE ENVIRONMENT VARIABLES:\n\n   a) Check function environment configurations:\n   ```bash\n   # AWS Lambda environment variables\n   aws lambda get-function-configuration --function-name my-function --query 'Environment.Variables'\n\n   # Azure Functions app settings\n   az functionapp config appsettings list --name myapp --resource-group mygroup\n\n   # GCP Cloud Functions environment variables\n   gcloud functions describe my-function --region=us-central1 --format='value(environmentVariables)'\n   ```\n\n   b) Review function logs for variable exposure:\n   ```bash\n   # AWS CloudWatch logs\n   aws logs filter-log-events --log-group-name /aws/lambda/my-function --filter-pattern 'API_KEY|SECRET|PASSWORD'\n\n   # Azure Application Insights\n   az monitor app-insights query --app myapp --analytics-query 'traces | where message contains \"API_KEY\"'\n\n   # GCP Cloud Logging\n   gcloud logging read 'resource.type=cloud_function AND textPayload:(API_KEY OR SECRET)'\n   ```\n\n2. TEST VARIABLE INJECTION ATTACKS:\n\n   a) Attempt environment variable override:\n   ```bash\n   # Test if client can override environment variables\n   curl -X POST https://api.example.com/function \\\n     -H 'X-Custom-Header: DEBUG=true' \\\n     -d '{\"input\":\"test\"}'\n   ```\n\n   b) Check for variable leakage in error responses:\n   ```bash\n   # Trigger errors to see if environment variables are exposed\n   curl -X POST https://api.example.com/function \\\n     -d '{\"input\":\"invalid_data_to_cause_error\"}'\n   ```\n\n3. ASSESS SECRET MANAGEMENT:\n\n   b) Check for hardcoded secrets in function code:\n   ```bash\n   # Scan deployment packages for secrets\n   grep -r 'API_KEY\\|SECRET\\|PASSWORD' deployment-package/\n   ```\n\n   b) Verify secret rotation and access controls:\n   ```bash\n   # AWS Secrets Manager/Secrets Manager access\n   aws secretsmanager list-secrets\n   aws kms list-keys\n\n   # Azure Key Vault\n   az keyvault secret list --vault-name myvault\n\n   # GCP Secret Manager\n   gcloud secrets list\n   ```\n\nWHAT TO LOOK FOR:\n- Environment variables containing sensitive data (API keys, passwords, tokens)\n- Functions logging sensitive environment variables\n- Client-controllable headers overriding environment variables\n- Hardcoded secrets in function source code\n- Missing encryption for sensitive environment variables\n- Overly permissive IAM policies for secret access\n\nCOMMON PITFALLS:\n- Never store secrets in plaintext environment variables\n- Use cloud provider secret management services (AWS Secrets Manager, Azure Key Vault, GCP Secret Manager)\n- Implement proper key rotation policies\n- Avoid logging sensitive environment variables\n- Use environment variable encryption at rest\n- Implement least privilege access to secrets",
      "tags": ["serverless", "security", "environment", "secrets", "variables"]
    },
    {
      "id": "iam-misconfiguration-privilege-escalation",
      "title": "IAM Misconfiguration & Privilege Escalation",
      "content": "OBJECTIVE: Identify IAM misconfigurations that allow privilege escalation in serverless environments.\n\nACADEMIC BACKGROUND:\nServerless functions execute with IAM roles that can be overly permissive. According to AWS security research, misconfigured Lambda execution roles are responsible for 80% of serverless breaches.\n\nIAM Security Concepts:\n- Execution roles: Permissions granted to functions during execution\n- Resource policies: Permissions on resources that functions can access\n- Cross-account access: Functions accessing resources in other accounts\n- Service roles vs. user roles: Different permission models\n\nSTEP-BY-STEP:\n\n1. ANALYZE EXECUTION ROLE PERMISSIONS:\n\n   a) Examine function execution roles:\n   ```bash\n   # AWS Lambda execution role\n   aws lambda get-function-configuration --function-name my-function --query 'Role'\n   aws iam list-attached-role-policies --role-name lambda-execution-role\n\n   # Azure Functions managed identity\n   az functionapp identity show --name myapp --resource-group mygroup\n   az role assignment list --assignee my-identity-id\n\n   # GCP Cloud Functions service account\n   gcloud functions describe my-function --region=us-central1 --format='value(serviceAccountEmail)'\n   gcloud iam service-accounts get-iam-policy my-service-account@project.iam.gserviceaccount.com\n   ```\n\n   b) Test privilege escalation paths:\n   ```bash\n   # Check if function can assume other roles\n   aws sts assume-role --role-arn arn:aws:iam::123456789012:role/other-role --role-session-name test\n\n   # Test cross-account access\n   aws sts assume-role --role-arn arn:aws:iam::other-account:role/cross-account-role\n   ```\n\n2. REVIEW RESOURCE POLICIES:\n\n   a) Check resource-based policies:\n   ```bash\n   # Lambda resource policies\n   aws lambda get-policy --function-name my-function\n\n   # S3 bucket policies allowing Lambda access\n   aws s3api get-bucket-policy --bucket my-bucket\n\n   # API Gateway resource policies\n   aws apigateway get-rest-api --rest-api-id my-api --query 'policy'\n   ```\n\n   b) Test policy bypass techniques:\n   ```bash\n   # Attempt to invoke functions with overly permissive policies\n   aws lambda invoke --function-name restricted-function --payload '{}' output.json\n   ```\n\n3. ASSESS CROSS-SERVICE ACCESS:\n\n   a) Map service interactions:\n   ```bash\n   # Check VPC configurations for network isolation\n   aws lambda get-function-configuration --function-name my-function --query 'VpcConfig'\n\n   # Verify security groups and NACLs\n   aws ec2 describe-security-groups --group-ids sg-12345\n   ```\n\nWHAT TO LOOK FOR:\n- Execution roles with wildcard (*) permissions\n- Functions that can assume high-privilege roles\n- Resource policies allowing public access\n- Missing VPC configurations for sensitive functions\n- Cross-account IAM trust relationships\n- Service accounts with domain-wide delegation (GCP)\n\nCOMMON PITFALLS:\n- Use least privilege principle for execution roles\n- Avoid wildcard permissions in IAM policies\n- Implement resource-based policies for fine-grained access control\n- Use IAM condition keys to restrict resource access\n- Regularly audit and rotate access keys\n- Implement multi-factor authentication for privileged operations",
      "tags": ["serverless", "security", "iam", "privilege", "escalation"]
    },
    {
      "id": "event-trigger-abuse-injection-attacks",
      "title": "Event Trigger Abuse & Injection Attacks",
      "content": "OBJECTIVE: Identify and exploit vulnerabilities in serverless event triggers and injection vectors.\n\nACADEMIC BACKGROUND:\nServerless functions are triggered by various events, creating attack surfaces for injection and abuse. Research shows that event-driven attacks account for 60% of serverless security incidents.\n\nEvent Trigger Types:\n- HTTP API triggers (REST APIs, GraphQL)\n- Message queue triggers (SQS, EventBridge, Service Bus)\n- Storage triggers (S3, Blob Storage, Cloud Storage)\n- Database triggers (DynamoDB, Cosmos DB, Firestore)\n- Scheduled/cron triggers\n\nSTEP-BY-STEP:\n\n1. MAP EVENT SOURCES:\n\n   a) Enumerate all function triggers:\n   ```bash\n   # AWS Event sources\n   aws lambda list-event-source-mappings\n   aws events list-rules --query 'Rules[?State==`ENABLED`]'\n\n   # Azure Event Grid subscriptions\n   az eventgrid event-subscription list --topic-name mytopic\n\n   # GCP Eventarc triggers\n   gcloud eventarc triggers list\n   ```\n\n   b) Test trigger validation:\n   ```bash\n   # Send malformed events\n   aws lambda invoke --function-name my-function \\\n     --payload '{\"malicious\":\"<script>alert(1)</script>\"}' response.json\n   ```\n\n2. TEST INJECTION ATTACKS:\n\n   a) SQL injection in database triggers:\n   ```sql\n   -- Test for SQL injection in DynamoDB streams\n   INSERT INTO users (name, email) VALUES ('admin''--', 'hacker@example.com');\n   ```\n\n   b) XSS in HTTP triggers:\n   ```bash\n   # Test XSS in API Gateway\n   curl -X POST https://api.example.com/function \\\n     -d '{\"input\":\"<img src=x onerror=alert(1)>\"}'\n   ```\n\n   c) Command injection in processing functions:\n   ```bash\n   # Test command injection\n   curl -X POST https://api.example.com/process \\\n     -d '{\"filename\":\"../../../etc/passwd\"}'\n   ```\n\n3. ASSESS RATE LIMITING & DOS:\n\n   a) Test function concurrency limits:\n   ```bash\n   # AWS Lambda concurrency\n   aws lambda get-function-concurrency --function-name my-function\n\n   # Flood function with requests\n   for i in {1..1000}; do\n     curl -X POST https://api.example.com/function -d '{}' &\n   done\n   ```\n\nWHAT TO LOOK FOR:\n- Unauthenticated API endpoints accepting arbitrary input\n- Missing input validation and sanitization\n- Functions processing untrusted event data\n- Missing rate limiting on HTTP triggers\n- Database triggers vulnerable to injection\n- Event sources allowing cross-account access\n\nCOMMON PITFALLS:\n- Implement strict input validation for all event data\n- Use parameterized queries for database operations\n- Sanitize HTML content in web-facing functions\n- Implement rate limiting and request throttling\n- Use API gateways with built-in security features\n- Validate event source authenticity",
      "tags": ["serverless", "security", "events", "triggers", "injection"]
    },
    {
      "id": "cold-start-timing-attacks-side-channels",
      "title": "Cold Start Timing Attacks & Side Channels",
      "content": "OBJECTIVE: Exploit timing differences in serverless cold starts for information disclosure.\n\nACADEMIC BACKGROUND:\nCold starts occur when serverless functions execute for the first time or after inactivity. Research from USENIX Security shows timing differences can leak sensitive information through side channels.\n\nCold Start Characteristics:\n- Initialization time: Loading runtime, dependencies, and code\n- Container provisioning: Creating isolated execution environment\n- Network latency: Establishing connections to external services\n- Cache warming: Loading frequently accessed data\n\nSTEP-BY-STEP:\n\n1. MEASURE COLD START TIMING:\n\n   a) Monitor function execution times:\n   ```bash\n   # AWS CloudWatch metrics\n   aws cloudwatch get-metric-statistics \\\n     --namespace AWS/Lambda \\\n     --metric-name Duration \\\n     --dimensions Name=FunctionName,Value=my-function \\\n     --start-time 2024-01-01T00:00:00Z \\\n     --end-time 2024-01-02T00:00:00Z \\\n     --period 3600 \\\n     --statistics Average\n\n   # Azure Application Insights\n   az monitor metrics list \\\n     --resource /subscriptions/.../functionapp/myapp \\\n     --metric 'FunctionExecutionTime'\n   ```\n\n   b) Force cold starts and measure timing:\n   ```bash\n   # AWS - wait for function to become cold\n   sleep 3600  # Wait for cold start\n   time aws lambda invoke --function-name my-function --payload '{}' response.json\n\n   # Measure multiple invocations\n   for i in {1..10}; do\n     time curl -X POST https://api.example.com/function -d '{}' -o /dev/null -w '%{time_total}\\n'\n     sleep 300  # Wait between requests\n   done\n   ```\n\n2. EXPLOIT TIMING DIFFERENCES:\n\n   a) Test conditional timing attacks:\n   ```bash\n   # Test timing differences based on input\n   time curl -X POST https://api.example.com/auth \\\n     -d '{\"username\":\"admin\",\"password\":\"wrong\"}'\n\n   time curl -X POST https://api.example.com/auth \\\n     -d '{\"username\":\"wrong\",\"password\":\"wrong\"}'\n   ```\n\n   b) Measure cache-based timing:\n   ```bash\n   # Test if function caches results\n   time curl -X GET https://api.example.com/cache-test?key=known_value\n   time curl -X GET https://api.example.com/cache-test?key=unknown_value\n   ```\n\n3. ANALYZE RESOURCE CONTENTION:\n\n   a) Test concurrent execution timing:\n   ```bash\n   # Flood function to test resource limits\n   for i in {1..50}; do\n     curl -X POST https://api.example.com/function -d '{}' &\n   done\n\n   # Monitor execution times during high load\n   aws lambda get-function-concurrency --function-name my-function\n   ```\n\nWHAT TO LOOK FOR:\n- Significant timing differences between cold and warm starts\n- Timing variations based on input validation results\n- Cache hit/miss timing differences\n- Resource exhaustion during concurrent execution\n- Memory/CPU allocation affecting execution time\n- Network latency variations in external service calls\n\nCOMMON PITFALLS:\n- Avoid using execution time as a security control\n- Implement consistent response times for authentication\n- Use proper caching strategies to reduce cold start impact\n- Monitor and alert on unusual timing patterns\n- Implement request deduplication to prevent timing attacks\n- Use provisioned concurrency for latency-sensitive functions",
      "tags": ["serverless", "security", "cold-start", "timing", "side-channels"]
    },
    {
      "id": "cicd-pipeline-security-functions",
      "title": "CI/CD Pipeline Security for Functions",
      "content": "OBJECTIVE: Identify vulnerabilities in serverless deployment pipelines and supply chain attacks.\n\nACADEMIC BACKGROUND:\nServerless deployment pipelines can introduce security risks through compromised build processes, malicious dependencies, and insecure configurations. SolarWinds and Codecov incidents demonstrate the risks of supply chain attacks.\n\nCI/CD Security Risks:\n- Compromised build agents and runners\n- Malicious dependencies in deployment packages\n- Exposed deployment credentials\n- Insecure artifact storage and distribution\n- Lack of code signing and integrity checks\n\nSTEP-BY-STEP:\n\n1. ANALYZE DEPLOYMENT PIPELINES:\n\n   a) Review CI/CD configurations:\n   ```bash\n   # GitHub Actions workflows\n   cat .github/workflows/deploy.yml\n\n   # AWS CodePipeline\n   aws codepipeline get-pipeline --name my-pipeline\n\n   # Azure DevOps pipelines\n   az pipelines show --name my-pipeline --organization https://dev.azure.com/myorg\n   ```\n\n   b) Check deployment credentials:\n   ```bash\n   # AWS IAM roles for deployment\n   aws iam list-roles --query 'Roles[?RoleName==`lambda-deployment-role`]'\n\n   # Check for exposed secrets\n   grep -r 'AWS_ACCESS_KEY\\|AZURE_CLIENT_SECRET' .github/\n   ```\n\n2. INSPECT DEPENDENCY SECURITY:\n\n   a) Scan for vulnerable dependencies:\n   ```bash\n   # Use dependency scanners\n   npm audit\n   pip-audit\n   safety check\n\n   # Check for malicious packages\n   grep -r 'malicious-package' package.json requirements.txt\n   ```\n\n   b) Verify code signing:\n   ```bash\n   # AWS Lambda code signing\n   aws lambda get-code-signing-config --code-signing-config-arn arn:aws:lambda:region:account:code-signing-config:my-config\n\n   # Check signature verification\n   aws lambda get-function --function-name my-function --query 'Code.SigningProfileVersionArn'\n   ```\n\n3. TEST SUPPLY CHAIN ATTACKS:\n\n   a) Check artifact integrity:\n   ```bash\n   # Verify checksums\n   sha256sum deployment-package.zip\n   aws s3api head-object --bucket my-artifacts --key deployment-package.zip --query 'Metadata.sha256'\n\n   # Test dependency confusion\n   npm install @myorg/internal-package@latest  # Check if external package overrides internal\n   ```\n\nWHAT TO LOOK FOR:\n- Hardcoded credentials in CI/CD configurations\n- Use of untrusted third-party actions/workflows\n- Missing dependency vulnerability scanning\n- Unsigned deployment artifacts\n- Overly permissive deployment roles\n- Lack of multi-stage pipeline approvals\n\nCOMMON PITFALLS:\n- Use secret management for deployment credentials\n- Implement dependency scanning in CI/CD pipelines\n- Sign and verify all deployment artifacts\n- Use infrastructure as code for repeatable deployments\n- Implement manual approval gates for production deployments\n- Regularly rotate deployment credentials and tokens",
      "tags": ["serverless", "security", "cicd", "pipeline", "supply-chain"]
    },
    {
      "id": "serverless-security-quiz",
      "title": "Serverless Security Quiz",
      "content": "Quiz content loaded from serverless_security/serverless-security-quiz.txt",
      "tags": ["quiz", "serverless", "security", "lambda", "functions"]
    }
  ]
}