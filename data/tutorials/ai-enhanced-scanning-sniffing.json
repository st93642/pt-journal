{
  "id": "ai-enhanced-scanning-sniffing",
  "title": "AI-Enhanced Network Scanning & Traffic Analysis",
  "description": "Master AI-powered network scanning with intelligent command generation, automated analysis, and machine learning-enhanced packet capture using tools like Nmap, Wireshark, and LLM assistants.",
  "type": "tutorial",
  "steps": [
    {
      "id": "ai-scan-methodology",
      "title": "AI-Enhanced Scanning Methodology",
      "content": "OBJECTIVE: Understand how AI transforms network scanning by automating command generation, intelligent analysis, and adaptive scanning strategies.\n\nTRADITIONAL VS AI-ENHANCED SCANNING:\n\n| Aspect | Traditional | AI-Enhanced |\n|--------|------------|-------------|\n| Command generation | Manual reference | LLM-generated optimal commands |\n| Result analysis | Manual review | AI-prioritized findings |\n| Vulnerability correlation | CVE database lookup | AI context-aware assessment |\n| Report generation | Manual compilation | AI-synthesized reports |\n| Scan optimization | Trial and error | AI-adaptive parameters |\n\nAI SCANNING WORKFLOW:\n```\n1. Target Assessment\n   ├── AI generates target profile\n   └── Recommends scanning approach\n   \n2. Scan Configuration\n   ├── LLM generates optimized commands\n   ├── Timing and evasion parameters\n   └── Service-specific probes\n   \n3. Execution & Monitoring\n   ├── Adaptive scanning based on responses\n   └── Real-time AI analysis\n   \n4. Analysis & Correlation\n   ├── AI vulnerability prioritization\n   ├── Attack surface mapping\n   └── Exploitation path identification\n   \n5. Report Generation\n   ├── AI-synthesized findings\n   └── Remediation recommendations\n```\n\nKEY AI CAPABILITIES:\n\n1. **Command Optimization**\n   - Generate Nmap commands for specific scenarios\n   - Adapt timing based on network conditions\n   - Select appropriate scripts and probes\n\n2. **Intelligent Analysis**\n   - Correlate services with known vulnerabilities\n   - Identify misconfigurations from banners\n   - Detect anomalous services\n\n3. **Context-Aware Prioritization**\n   - Business impact assessment\n   - Exploitability scoring\n   - Attack chain identification\n\nTOOLS IN THIS MODULE:\n- Nmap (network scanning)\n- Wireshark (traffic analysis)\n- Shell GPT / Ollama (AI assistance)\n- Nuclei (vulnerability scanning)\n- Masscan (fast port scanning)",
      "tags": ["methodology", "scanning", "workflow", "ai-enhanced"],
      "related_tools": ["nmap", "wireshark"]
    },
    {
      "id": "ai-nmap-scanning",
      "title": "AI-Powered Nmap Command Generation & Analysis",
      "content": "OBJECTIVE: Use AI to generate optimized Nmap commands, interpret results, and identify attack vectors.\n\nAI COMMAND GENERATION:\n\n```bash\n# Basic AI-generated scan commands\nsgpt \"Generate an Nmap command to:\n- Scan top 1000 ports\n- Detect service versions\n- Run default scripts\n- Output to XML and text\n- Target: 192.168.1.0/24\"\n\n# Stealth scanning\nsgpt \"Create an Nmap command for stealth scanning a web server, avoiding IDS detection, with timing optimization\"\n\n# Specific service enumeration\nsgpt \"Generate Nmap commands to enumerate SMB shares, users, and vulnerabilities on 10.0.0.50\"\n```\n\nCOMMON AI-GENERATED COMMANDS:\n\n```bash\n# Comprehensive host discovery\nnmap -sn -PE -PP -PM -PS22,80,443,3389 -PA80,443 192.168.1.0/24 -oA discovery\n\n# Service version and script scan\nnmap -sV -sC -O -p- --min-rate=1000 -oA full_scan 192.168.1.100\n\n# Stealth SYN scan with timing evasion\nnmap -sS -T2 -f --data-length 50 -D RND:5 -oA stealth 192.168.1.100\n\n# Web server focused scan\nnmap -sV -p80,443,8080,8443 --script=http-enum,http-vuln*,ssl* -oA web_scan 192.168.1.100\n\n# SMB vulnerability scan\nnmap -p445 --script=smb-vuln-*,smb-enum-*,smb2-vuln* -oA smb_scan 192.168.1.100\n```\n\nAI RESULT ANALYSIS:\n\n```bash\n# Parse Nmap XML and analyze with AI\nnmap -sV -sC -oX scan.xml 192.168.1.100\n\n# Analyze results\nsgpt \"Analyze this Nmap scan and identify:\n1. Critical vulnerabilities\n2. Interesting services for exploitation\n3. Potential attack vectors\n4. Recommended next steps\n\n$(cat scan.xml | head -500)\"\n```\n\nPYTHON AUTOMATION:\n\n```python\n# ai_nmap_analyzer.py\nimport subprocess\nimport xml.etree.ElementTree as ET\nfrom openai import OpenAI\n\nclient = OpenAI()\n\ndef run_nmap_scan(target: str, scan_type: str = \"default\") -> str:\n    \"\"\"Run Nmap scan and return XML output.\"\"\"\n    \n    # AI generates optimal command\n    prompt = f\"Generate a single Nmap command line for {scan_type} scan of {target}. Output XML format. Only return the command, nothing else.\"\n    \n    response = client.chat.completions.create(\n        model=\"gpt-4o-mini\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    \n    nmap_cmd = response.choices[0].message.content.strip()\n    print(f\"[*] Running: {nmap_cmd}\")\n    \n    result = subprocess.run(\n        nmap_cmd.split(),\n        capture_output=True,\n        text=True\n    )\n    \n    return result.stdout\n\ndef parse_and_analyze(xml_output: str) -> dict:\n    \"\"\"Parse Nmap XML and use AI to analyze.\"\"\"\n    \n    # Parse basic info\n    root = ET.fromstring(xml_output)\n    hosts = []\n    \n    for host in root.findall('.//host'):\n        host_info = {\n            'ip': host.find('.//address').get('addr'),\n            'ports': []\n        }\n        \n        for port in host.findall('.//port'):\n            port_info = {\n                'port': port.get('portid'),\n                'protocol': port.get('protocol'),\n                'state': port.find('state').get('state'),\n                'service': port.find('service').get('name', 'unknown') if port.find('service') is not None else 'unknown'\n            }\n            host_info['ports'].append(port_info)\n        \n        hosts.append(host_info)\n    \n    # AI analysis\n    prompt = f\"\"\"Analyze these Nmap scan results and provide:\n\n1. EXECUTIVE SUMMARY\n2. HIGH-RISK FINDINGS (with exploitation suggestions)\n3. RECOMMENDED NEXT STEPS\n4. POTENTIAL ATTACK PATHS\n\nScan Results:\n{hosts}\n\"\"\"\n    \n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    \n    return {\n        'hosts': hosts,\n        'ai_analysis': response.choices[0].message.content\n    }\n\n# Usage\nresult = run_nmap_scan(\"192.168.1.100\", \"comprehensive service and vulnerability\")\nanalysis = parse_and_analyze(result)\nprint(analysis['ai_analysis'])\n```\n\nSPECIALIZED SCAN GENERATION:\n\n```bash\n# Generate vulnerability-specific scans\nsgpt \"Create Nmap commands to check for:\\n1. EternalBlue (MS17-010)\\n2. BlueKeep (CVE-2019-0708)\\n3. Log4j vulnerabilities\\n4. Exchange ProxyLogon\"\n\n# Network device scanning\nsgpt \"Generate Nmap commands to enumerate Cisco routers and switches, including SNMP community strings\"\n\n# Cloud infrastructure scanning\nsgpt \"Create Nmap commands to identify AWS/Azure/GCP services and misconfigurations\"\n```",
      "tags": ["nmap", "scanning", "command-generation", "analysis"],
      "related_tools": ["nmap", "masscan"]
    },
    {
      "id": "ai-packet-analysis",
      "title": "AI-Enhanced Packet Capture and Analysis",
      "content": "OBJECTIVE: Use AI to analyze network traffic, identify anomalies, extract credentials, and detect security issues in captured packets.\n\nWIRESHARK CAPTURE BASICS:\n\n```bash\n# Command line capture with tshark\ntshark -i eth0 -w capture.pcap -f \"port 80 or port 443\"\n\n# Capture with specific filters\ntshark -i eth0 -w http_traffic.pcap -f \"tcp port 80\" -a duration:300\n\n# Extract HTTP requests\ntshark -r capture.pcap -Y \"http.request\" -T fields -e ip.src -e http.host -e http.request.uri\n```\n\nAI-ASSISTED TRAFFIC ANALYSIS:\n\n```bash\n# Export packet summary and analyze\ntshark -r capture.pcap -c 1000 > packet_summary.txt\n\nsgpt \"Analyze this network traffic capture and identify:\n1. Suspicious connections\n2. Clear text credentials\n3. Potential C2 communication patterns\n4. Data exfiltration indicators\n5. Recommended Wireshark filters for deeper analysis\n\n$(cat packet_summary.txt | head -200)\"\n```\n\nPYTHON PACKET ANALYZER:\n\n```python\n# ai_packet_analyzer.py\nfrom scapy.all import *\nfrom collections import Counter\nimport json\nfrom openai import OpenAI\n\nclient = OpenAI()\n\nclass AIPacketAnalyzer:\n    def __init__(self, pcap_file: str):\n        self.packets = rdpcap(pcap_file)\n        self.stats = {}\n    \n    def extract_statistics(self) -> dict:\n        \"\"\"Extract key statistics from packet capture.\"\"\"\n        \n        src_ips = Counter()\n        dst_ips = Counter()\n        protocols = Counter()\n        ports = Counter()\n        http_hosts = []\n        dns_queries = []\n        \n        for pkt in self.packets:\n            if IP in pkt:\n                src_ips[pkt[IP].src] += 1\n                dst_ips[pkt[IP].dst] += 1\n            \n            if TCP in pkt:\n                protocols['TCP'] += 1\n                ports[pkt[TCP].dport] += 1\n            elif UDP in pkt:\n                protocols['UDP'] += 1\n                ports[pkt[UDP].dport] += 1\n            \n            # HTTP host extraction\n            if pkt.haslayer(Raw):\n                payload = str(pkt[Raw].load)\n                if 'Host:' in payload:\n                    host = payload.split('Host:')[1].split('\\\\r\\\\n')[0].strip()\n                    http_hosts.append(host)\n            \n            # DNS queries\n            if pkt.haslayer(DNS) and pkt[DNS].qd:\n                dns_queries.append(pkt[DNS].qd.qname.decode())\n        \n        self.stats = {\n            'total_packets': len(self.packets),\n            'top_sources': dict(src_ips.most_common(10)),\n            'top_destinations': dict(dst_ips.most_common(10)),\n            'protocols': dict(protocols),\n            'top_ports': dict(ports.most_common(15)),\n            'http_hosts': list(set(http_hosts))[:20],\n            'dns_queries': list(set(dns_queries))[:20]\n        }\n        \n        return self.stats\n    \n    def ai_analyze(self) -> str:\n        \"\"\"Use AI to analyze packet statistics.\"\"\"\n        \n        if not self.stats:\n            self.extract_statistics()\n        \n        prompt = f\"\"\"Analyze this network traffic summary for a security assessment:\n\n{json.dumps(self.stats, indent=2)}\n\nProvide:\n1. TRAFFIC OVERVIEW (normal vs suspicious patterns)\n2. SECURITY CONCERNS:\n   - Suspicious IP addresses or connections\n   - Potentially malicious DNS queries\n   - Unusual port activity\n   - Clear text protocol usage\n3. INDICATORS OF COMPROMISE (if any)\n4. RECOMMENDED WIRESHARK DISPLAY FILTERS for further investigation\n5. NEXT STEPS for the penetration test\n\"\"\"\n        \n        response = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        \n        return response.choices[0].message.content\n    \n    def find_credentials(self) -> list:\n        \"\"\"Search for potential credentials in traffic.\"\"\"\n        \n        credentials = []\n        patterns = ['password', 'passwd', 'pwd', 'user', 'username', 'login', 'auth']\n        \n        for pkt in self.packets:\n            if pkt.haslayer(Raw):\n                payload = str(pkt[Raw].load).lower()\n                for pattern in patterns:\n                    if pattern in payload:\n                        credentials.append({\n                            'src': pkt[IP].src if IP in pkt else 'unknown',\n                            'dst': pkt[IP].dst if IP in pkt else 'unknown',\n                            'snippet': payload[:200]\n                        })\n                        break\n        \n        return credentials[:20]  # Limit results\n\n# Usage\nanalyzer = AIPacketAnalyzer('capture.pcap')\nstats = analyzer.extract_statistics()\nanalysis = analyzer.ai_analyze()\nprint(analysis)\n\ncreds = analyzer.find_credentials()\nif creds:\n    print(\"\\n[!] Potential credentials found:\")\n    for c in creds:\n        print(f\"  {c['src']} -> {c['dst']}\")\n```\n\nWIRESHARK FILTER GENERATION:\n\n```bash\n# Generate filters for specific analysis\nsgpt \"Generate 10 Wireshark display filters to find:\\n1. SQL injection attempts\\n2. Clear text passwords\\n3. DNS tunneling\\n4. Large data transfers\\n5. Suspicious user agents\"\n\n# Example AI-generated filters:\n# SQL injection: http contains \"union\" or http contains \"select\"\n# Clear text auth: http.authbasic or ftp.request.command == \"PASS\"\n# DNS tunneling: dns.qry.name.len > 50\n# Large transfers: tcp.len > 10000\n# Suspicious UA: http.user_agent contains \"curl\" or http.user_agent contains \"wget\"\n```",
      "tags": ["wireshark", "packet-analysis", "traffic-capture", "credentials"],
      "related_tools": ["wireshark", "tcpdump", "tshark"]
    },
    {
      "id": "intelligent-vuln-scanning",
      "title": "AI-Optimized Vulnerability Scanning",
      "content": "OBJECTIVE: Use AI to optimize vulnerability scanning with Nuclei, generate custom templates, and prioritize findings.\n\nNUCLEI WITH AI OPTIMIZATION:\n\n```bash\n# Update Nuclei templates\nnuclei -ut\n\n# Basic vulnerability scan\nnuclei -u https://target.com -t cves/ -t vulnerabilities/ -o nuclei_results.txt\n\n# AI-optimized scanning based on technology\nsgpt \"Given a target running nginx 1.18, PHP 7.4, and WordPress 5.8, list the most relevant Nuclei template categories to run\"\n```\n\nAI-GENERATED NUCLEI TEMPLATES:\n\n```bash\n# Generate custom template\nsgpt \"Create a Nuclei template to detect:\\n- Custom header: X-Debug-Mode\\n- Response containing stack trace\\n- HTTP 500 with database error\"\n```\n\nGenerated template:\n```yaml\nid: custom-debug-detection\n\ninfo:\n  name: Debug Mode and Error Detection\n  author: ai-generated\n  severity: medium\n  tags: misconfiguration,debug\n\nrequests:\n  - method: GET\n    path:\n      - \"{{BaseURL}}/\"\n      - \"{{BaseURL}}/api/\"\n      - \"{{BaseURL}}/admin/\"\n    \n    matchers-condition: or\n    matchers:\n      - type: word\n        part: header\n        words:\n          - \"X-Debug-Mode\"\n        \n      - type: word\n        part: body\n        words:\n          - \"Stack trace:\"\n          - \"Exception in\"\n          - \"at line\"\n        condition: or\n        \n      - type: word\n        part: body\n        words:\n          - \"mysql_\"\n          - \"ORA-\"\n          - \"PostgreSQL\"\n          - \"SQLSTATE\"\n        condition: or\n```\n\nSCAN RESULT PRIORITIZATION:\n\n```python\n# ai_nuclei_analyzer.py\nimport json\nfrom openai import OpenAI\nimport subprocess\n\nclient = OpenAI()\n\ndef run_nuclei_scan(target: str) -> list:\n    \"\"\"Run Nuclei scan and return JSON results.\"\"\"\n    \n    result = subprocess.run(\n        ['nuclei', '-u', target, '-json', '-silent'],\n        capture_output=True,\n        text=True\n    )\n    \n    findings = []\n    for line in result.stdout.strip().split('\\n'):\n        if line:\n            findings.append(json.loads(line))\n    \n    return findings\n\ndef ai_prioritize_findings(findings: list) -> str:\n    \"\"\"Use AI to prioritize and analyze findings.\"\"\"\n    \n    # Prepare summary\n    summary = []\n    for f in findings:\n        summary.append({\n            'template': f.get('template-id', 'unknown'),\n            'severity': f.get('info', {}).get('severity', 'unknown'),\n            'name': f.get('info', {}).get('name', 'unknown'),\n            'matched': f.get('matched-at', '')\n        })\n    \n    prompt = f\"\"\"Analyze these vulnerability scan results and provide:\n\n1. CRITICAL FINDINGS (exploit immediately)\n2. HIGH PRIORITY (address this week)\n3. MEDIUM PRIORITY (address this month)\n4. LOW/INFO (monitor)\n\nFor each finding, provide:\n- Exploitation difficulty\n- Business impact\n- Recommended remediation\n\nFindings:\n{json.dumps(summary, indent=2)}\n\"\"\"\n    \n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    \n    return response.choices[0].message.content\n\n# Usage\ntarget = \"https://target.com\"\nfindings = run_nuclei_scan(target)\nanalysis = ai_prioritize_findings(findings)\nprint(analysis)\n```\n\nCOMBINED SCANNING WORKFLOW:\n\n```bash\n#!/bin/bash\n# ai_enhanced_scan.sh\nTARGET=$1\n\necho \"[1/4] Running Nmap service detection...\"\nnmap -sV -sC -oX nmap_scan.xml $TARGET\n\necho \"[2/4] Running Nuclei vulnerability scan...\"\nnuclei -u https://$TARGET -json -o nuclei.json\n\necho \"[3/4] Analyzing results with AI...\"\nsgpt \"Analyze these scan results and create a prioritized attack plan:\n\nNmap:\n$(cat nmap_scan.xml | head -300)\n\nNuclei:\n$(cat nuclei.json | head -100)\n\nProvide:\n1. Critical vulnerabilities to exploit first\n2. Recommended exploitation tools\n3. Potential lateral movement paths\"\n\necho \"[4/4] Generating report...\"\n```",
      "tags": ["nuclei", "vulnerability-scanning", "templates", "prioritization"],
      "related_tools": ["nuclei", "nmap"]
    },
    {
      "id": "scan-optimization-evasion",
      "title": "AI-Optimized Scan Timing and IDS Evasion",
      "content": "OBJECTIVE: Use AI to optimize scan timing, evade intrusion detection systems, and adapt scanning strategies based on network responses.\n\nTIMING OPTIMIZATION:\n\n```bash\n# AI-recommended timing for different scenarios\nsgpt \"Recommend Nmap timing parameters (-T flag and --min-rate) for:\n1. Stealth scan avoiding IDS\n2. Fast scan of known-safe internal network\n3. Scan during business hours to blend with normal traffic\n4. Scan of rate-limited cloud infrastructure\"\n\n# Example recommendations:\n# Stealth: -T1 --max-rate 10 --scan-delay 5s\n# Fast internal: -T4 --min-rate 5000\n# Business hours blend: -T3 --randomize-hosts\n# Cloud rate-limited: -T3 --max-rate 100 --scan-delay 1s\n```\n\nIDS EVASION TECHNIQUES:\n\n```bash\n# Generate evasion-focused commands\nsgpt \"Create Nmap commands with IDS evasion techniques including:\n- Packet fragmentation\n- Decoy scanning\n- Source port manipulation\n- Timing randomization\"\n\n# Example AI-generated evasion scan:\nnmap -sS -T2 -f --mtu 24 \\\n  -D RND:10 \\\n  --source-port 53 \\\n  --data-length 50 \\\n  --randomize-hosts \\\n  --badsum \\\n  -oA evasion_scan \\\n  192.168.1.0/24\n```\n\nADAPTIVE SCANNING SCRIPT:\n\n```python\n# adaptive_scanner.py\nimport subprocess\nimport time\nfrom openai import OpenAI\n\nclient = OpenAI()\n\nclass AdaptiveScanner:\n    def __init__(self, target: str):\n        self.target = target\n        self.scan_history = []\n        self.blocked = False\n    \n    def test_connectivity(self) -> bool:\n        \"\"\"Check if target is responding.\"\"\"\n        result = subprocess.run(\n            ['ping', '-c', '1', '-W', '2', self.target],\n            capture_output=True\n        )\n        return result.returncode == 0\n    \n    def get_ai_scan_recommendation(self, context: str) -> str:\n        \"\"\"Get AI recommendation for next scan approach.\"\"\"\n        \n        prompt = f\"\"\"Based on this scanning context, recommend the next Nmap command:\n\nTarget: {self.target}\nScan History: {self.scan_history[-5:]}\nCurrent Issue: {context}\n\nProvide only the Nmap command with appropriate evasion and timing.\n\"\"\"\n        \n        response = client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        \n        return response.choices[0].message.content.strip()\n    \n    def run_adaptive_scan(self):\n        \"\"\"Run scan with adaptive behavior.\"\"\"\n        \n        # Initial fast probe\n        print(\"[*] Running initial probe...\")\n        result = subprocess.run(\n            ['nmap', '-sn', '-T4', self.target],\n            capture_output=True,\n            text=True\n        )\n        \n        if 'Host seems down' in result.stdout:\n            print(\"[!] Host appears down, trying slower scan...\")\n            cmd = self.get_ai_scan_recommendation(\"Host appears down or blocking probes\")\n        elif 'filtered' in result.stdout:\n            print(\"[!] Ports filtered, trying evasion...\")\n            cmd = self.get_ai_scan_recommendation(\"Firewall detected, ports showing filtered\")\n        else:\n            print(\"[+] Host responsive, running full scan...\")\n            cmd = self.get_ai_scan_recommendation(\"Host responsive, proceed with service detection\")\n        \n        print(f\"[*] AI recommended: {cmd}\")\n        self.scan_history.append(cmd)\n        \n        # Execute recommended scan\n        subprocess.run(cmd.split())\n\n# Usage\nscanner = AdaptiveScanner(\"192.168.1.100\")\nscanner.run_adaptive_scan()\n```\n\nNETWORK RESPONSE ANALYSIS:\n\n```bash\n# Analyze scan responses for detection indicators\nsgpt \"Analyze these Nmap results for signs of:\n1. IDS/IPS blocking\n2. Rate limiting\n3. Firewall rules\n4. Honeypot indicators\n\n$(cat scan_results.txt)\n\nRecommend adjustments to scanning approach.\"\n```\n\nSCAN SCHEDULING:\n\n```bash\n# AI-generated scan schedule for stealth\nsgpt \"Create a bash script that schedules Nmap scans:\n- Run during business hours (9-5)\n- Random delays between 10-30 minutes\n- Rotate through different scan types\n- Log all results with timestamps\n- Stop if target becomes unresponsive\"\n```",
      "tags": ["timing", "evasion", "ids", "adaptive", "stealth"],
      "related_tools": ["nmap"]
    }
  ]
}