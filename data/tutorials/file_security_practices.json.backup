{
  "id": "file_security_practices",
  "title": "File Security Practices",
  "type": "tutorial",
  "steps": [
    {
      "id": "file_encryption_gpg",
      "title": "File Encryption with GPG",
      "content": "OBJECTIVE: Learn to encrypt and decrypt files using GPG (GNU Privacy Guard) for secure file protection.\n\nACADEMIC BACKGROUND:\nGPG is a free implementation of the OpenPGP standard for encrypting and signing data. It provides strong cryptographic protection for files, ensuring confidentiality and integrity through public-key and symmetric encryption.\n\nSTEP-BY-STEP PROCESS:\n\n1. GPG Installation and Setup:\n\nGetting Started with GPG:\n```bash\n# Install GPG (Ubuntu/Debian)\nsudo apt update\nsudo apt install gnupg\n\n# Check installation\ngpg --version\n\n# Generate your keypair\ngpg --gen-key\n# Follow prompts:\n# - Key type: RSA and RSA (default)\n# - Key size: 4096 bits\n# - Expiration: 0 (never)\n# - Name, email, comment\n# - Passphrase (strong!)\n\n# List your keys\ngpg --list-keys\n\n# Export public key\ngpg --export -a \"Your Name\" > public_key.asc\n\n# Import someone else's public key\ngpg --import public_key.asc\n```\n\n2. Symmetric Encryption:\n\nPassword-Based File Encryption:\n```bash\n# Encrypt a file with symmetric encryption\ngpg --symmetric --cipher-algo AES256 secret.txt\n# Enter passphrase when prompted\n# Creates: secret.txt.gpg\n\n# Decrypt the file\ngpg --decrypt secret.txt.gpg > decrypted.txt\n# Or output to stdout:\ngpg --decrypt secret.txt.gpg\n\n# Encrypt multiple files\ntar -czf archive.tar.gz files/\ngpg --symmetric archive.tar.gz\n\n# Encrypt with specific algorithm\ngpg --symmetric --cipher-algo CAMELLIA256 document.pdf\n\n# Use armor format (ASCII)\ngpg --symmetric --armor secret.txt\n# Creates: secret.txt.asc (text format)\n\n# Decrypt armor format\ngpg --decrypt secret.txt.asc\n```\n\n3. Asymmetric Encryption:\n\nPublic-Key File Encryption:\n```bash\n# Encrypt for a specific recipient\ngpg --encrypt --recipient \"recipient@email.com\" secret.txt\n# Creates: secret.txt.gpg\n\n# Encrypt for multiple recipients\ngpg --encrypt --recipient \"alice@email.com\" --recipient \"bob@email.com\" secret.txt\n\n# Sign and encrypt\ngpg --encrypt --sign --recipient \"recipient@email.com\" secret.txt\n\n# Decrypt (uses your private key)\ngpg --decrypt secret.txt.gpg\n\n# View encryption info\ngpg --list-packets secret.txt.gpg\n\n# Encrypt to self (for backup)\ngpg --encrypt --recipient \"your@email.com\" important.txt\n```\n\n4. Key Management:\n\nManaging GPG Keys:\n```bash\n# List all keys\ngpg --list-keys\n\n# List secret keys\ngpg --list-secret-keys\n\n# Export private key (for backup)\ngpg --export-secret-keys -a \"Your Name\" > private_key.asc\n\n# Import private key\ngpg --import private_key.asc\n\n# Change passphrase\ngpg --edit-key \"Your Name\"\n# At prompt: passwd\n\n# Delete a key\ngpg --delete-key \"Key ID\"\n\ngpg --delete-secret-key \"Key ID\"\n\n# Trust a key\ngpg --edit-key \"Key ID\"\n# At prompt: trust\n# Choose trust level\n\n# Search for keys on keyserver\ngpg --search-keys \"name or email\"\n\n# Refresh keys from keyserver\ngpg --refresh-keys\n```\n\n5. File Signing and Verification:\n\nDigital Signatures:\n```bash\n# Sign a file (creates detached signature)\ngpg --detach-sign document.txt\n# Creates: document.txt.sig\n\n# Verify signature\ngpg --verify document.txt.sig document.txt\n\n# Sign and encrypt in one step\ngpg --encrypt --sign --recipient \"recipient@email.com\" document.txt\n\n# Clear text signature\ngpg --clearsign document.txt\n# Creates signed document with signature embedded\n\n# Verify clear text signature\ngpg --verify document.txt.asc\n\n# Create ASCII armored signature\ngpg --detach-sign --armor document.txt\n# Creates: document.txt.asc\n```\n\n6. Batch Operations:\n\nProcessing Multiple Files:\n```bash\n# Encrypt all .txt files in directory\nfor file in *.txt; do\n    gpg --symmetric \"$file\"\ndone\n\n# Decrypt all .gpg files\nfor file in *.gpg; do\n    gpg --decrypt \"$file\" > \"${file%.gpg}\"\ndone\n\n# Encrypt entire directory\ntar -czf directory.tar.gz /path/to/directory\ngpg --symmetric directory.tar.gz\n\n# Recursive encryption\nfind /path/to/directory -type f -name \"*.txt\" -exec gpg --symmetric {} \\;\n\n# Batch verification\nfor sig in *.sig; do\n    file=\"${sig%.sig}\"\n    gpg --verify \"$sig\" \"$file\" && echo \"$file: GOOD\" || echo \"$file: BAD\"\ndone\n```\n\n7. Advanced GPG Features:\n\nSpecialized Operations:\n```bash\n# Create a key for signing only\ngpg --gen-key --expert\n# Choose options for signing capability\n\n# Use a keyserver\ngpg --keyserver hkps://keys.openpgp.org --send-keys \"Key ID\"\n\ngpg --keyserver hkps://keys.openpgp.org --recv-keys \"Key ID\"\n\n# Encrypt to hidden recipients\ngpg --hidden-recipient \"recipient@email.com\" --encrypt file.txt\n\n# Use custom hash algorithm\ngpg --digest-algo SHA512 --sign file.txt\n\n# Create a revocation certificate\ngpg --gen-revoke \"Your Name\" > revocation.asc\n\n# Compress before encrypting\ngpg --compress-algo BZIP2 --encrypt --recipient \"email\" file.txt\n\n# Use different cipher for symmetric encryption\ngpg --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --symmetric file.txt\n```\n\nWHAT TO LOOK FOR:\n- **Key Strength**: 4096-bit RSA or higher\n- **Passphrase Quality**: Strong, unique passphrases\n- **Key Trust**: Properly trusted public keys\n- **Algorithm Selection**: Modern ciphers (AES256)\n- **Signature Verification**: Always verify before trusting\n- **Key Backup**: Secure backup of private keys\n- **Regular Updates**: Keep keys current and revoke if needed\n\nSECURITY IMPLICATIONS:\n- **Data Confidentiality**: Encrypted files unreadable without key\n- **Authentication**: Digital signatures prove file origin\n- **Integrity**: Detects file tampering\n- **Non-Repudiation**: Sender cannot deny sending signed file\n- **Key Compromise**: Private key loss = data loss\n- **Trust Management**: Public key verification requirements\n\nCOMMON PITFALLS:\n- **Weak Passphrases**: Easy to crack passwords\n- **Key Loss**: No backup of private keys\n- **Untrusted Keys**: Encrypting to wrong public keys\n- **Old Algorithms**: Using deprecated ciphers\n- **No Verification**: Trusting unsigned files\n- **Public Key Exposure**: Sharing private keys\n\nTOOLS REFERENCE:\n- **gpg**: GNU Privacy Guard main tool\n- **gpg-agent**: Key management daemon\n- **keyserver**: Public key distribution\n- **paperkey**: Backup keys on paper\n- **caff**: Key signing helper\n- **pius**: Mass key signing\n\nFURTHER READING:\n- OpenPGP Standard: RFC 4880 specification\n- GPG Manual: Comprehensive command reference\n- Cryptographic Best Practices: Key management guidelines\n- Public Key Infrastructure: PKI concepts and implementation\n- Digital Signatures: Authentication and integrity\n- Key Escrow: Backup and recovery strategies",
      "tags": ["encryption", "gpg", "cryptography", "file-security", "public-key"]
    },
    {
      "id": "steganography_steghide",
      "title": "Steganography with Steghide",
      "content": "OBJECTIVE: Hide data within other files using steganography techniques with the Steghide tool.\n\nACADEMIC BACKGROUND:\nSteganography is the practice of concealing messages or data within other non-secret data. Unlike encryption, steganography hides the existence of the message itself. Steghide uses various algorithms to embed data in image, audio, and other file formats.\n\nSTEP-BY-STEP PROCESS:\n\n1. Steghide Installation:\n\nSetting Up Steghide:\n```bash\n# Install Steghide (Ubuntu/Debian)\nsudo apt update\nsudo apt install steghide\n\n# Check installation\nsteghide --version\n\n# View help\nsteghide --help\n\n# Steghide capabilities:\n# - Supports BMP, JPEG, WAV, AU formats\n# - Uses password-based encryption\n# - Multiple embedding algorithms\n# - Compression support\n# - Integrity checking\n```\n\n2. Basic Data Embedding:\n\nHiding Files in Images:\n```bash\n# Prepare files to hide\n# Create a secret text file\necho \"This is a secret message\" > secret.txt\n\n# Create a secret binary file\necho -e \"\\x00\\x01\\x02\\x03\" > secret.bin\n\n# Embed text in an image\nsteghide embed -cf image.jpg -ef secret.txt\n# -cf: cover file (image)\n# -ef: embed file (data to hide)\n# Prompts for passphrase\n\n# Embed binary data\nsteghide embed -cf picture.png -ef secret.bin\n\n# Embed in audio file\nsteghide embed -cf music.wav -ef secret.txt\n\n# Specify output file\nsteghide embed -cf image.jpg -ef secret.txt -sf stego_image.jpg\n# -sf: stego file (output)\n```\n\n3. Advanced Embedding Options:\n\nCustomization and Optimization:\n```bash\n# Use specific encryption algorithm\nsteghide embed -cf image.jpg -ef secret.txt -e serpentine\n# Available: rijndael-128, rijndael-192, rijndael-256, twofish, serpentine\n\n# Change compression level\nsteghide embed -cf image.jpg -ef secret.txt -z 9\n# -z: compression level (0-9, 9=max)\n\n# Use a passphrase file instead of prompting\nsteghide embed -cf image.jpg -ef secret.txt -p passphrase.txt\n\n# Embed multiple files (create archive first)\ntar -cf secrets.tar secret1.txt secret2.txt\nsteghide embed -cf image.jpg -ef secrets.tar\n\n# Check embedding capacity\nsteghide info image.jpg\n# Shows: capacity, used space, etc.\n\n# Force overwrite\nsteghide embed -cf image.jpg -ef secret.txt -f\n# -f: overwrite existing stego file\n```\n\n4. Data Extraction:\n\nRetrieving Hidden Data:\n```bash\n# Extract from stego file\nsteghide extract -sf stego_image.jpg\n# -sf: stego file\n# Prompts for passphrase\n# Extracts to current directory\n\n# Extract to specific location\nsteghide extract -sf stego_image.jpg -xf extracted_secret.txt\n# -xf: extract file (output filename)\n\n# Extract with passphrase file\nsteghide extract -sf stego_image.jpg -p passphrase.txt\n\n# Extract without prompting (insecure)\nsteghide extract -sf stego_image.jpg -p \"mypassword\"\n\n# Verify extraction\nls -la extracted_secret.txt\ncat extracted_secret.txt\n\n# Extract from audio file\nsteghide extract -sf stego_music.wav\n```\n\n5. Information and Analysis:\n\nStego File Analysis:\n```bash\n# Get information about a potential stego file\nsteghide info image.jpg\n\n# Output includes:\n# - File format and capacity\n# - Embedded data presence\n# - Encryption algorithm used\n# - Compression level\n\n# Check if file contains hidden data\nsteghide info suspicious.jpg | grep -i \"embedded\"\n\n# Compare file sizes\nls -la original.jpg stego.jpg\n# Stego file should be slightly larger\n\n# Use stegdetect (if available)\nstegdetect suspicious.jpg\n\n# Statistical analysis\n# Look for unusual patterns in file\nhexdump -C image.jpg | head -20\n```\n\n6. Batch Operations:\n\nProcessing Multiple Files:\n```bash\n# Embed data in multiple images\nfor img in *.jpg; do\n    steghide embed -cf \"$img\" -ef secret.txt -sf \"stego_$img\" -p \"password\"\ndone\n\n# Extract from multiple stego files\nfor stego in stego_*.jpg; do\n    steghide extract -sf \"$stego\" -xf \"extracted_${stego#stego_}\" -p \"password\"\ndone\n\n# Create stego images from directory\nfind /path/to/images -name \"*.jpg\" -exec steghide embed -cf {} -ef secret.txt -sf stego_{} \\;\n\n# Batch information gathering\nfor img in *.jpg; do\n    echo \"=== $img ===\"\n    steghide info \"$img\"\n    echo\n    done\n```\n\n7. Security Considerations:\n\nSteganography Best Practices:\n```bash\n# Use strong passphrases\n# Choose appropriate cover files\n# Don't reuse passphrases\n# Use different algorithms\n# Compress data before embedding\n# Verify extraction works\n\n# Avoid detection:\n# - Don't use obvious cover files\n# - Vary embedding parameters\n# - Use natural-looking images\n# - Avoid perfect compression\n# - Don't embed in all files\n\n# Detection avoidance:\n# - Use high-quality source images\n# - Maintain original file metadata\n# - Don't change file size dramatically\n# - Use appropriate file formats\n```\n\n8. Alternative Tools and Techniques:\n\nOther Steganography Methods:\n```bash\n# OpenStego\n# Java-based steganography tool\nopenstego embed -cf image.jpg -mf secret.txt -p password\n\n# Stegano (Python library)\n# pip install stegano\npython3 -c \"from stegano import lsb; lsb.hide('image.jpg', 'secret message').save('stego.jpg')\"\npython3 -c \"from stegano import lsb; print(lsb.reveal('stego.jpg'))\"\n\n# OutGuess\n# Universal steganography tool\noutguess -k \"password\" -d secret.txt image.jpg stego.jpg\n\n# StegHide alternatives:\n# - StegFS: Filesystem-based steganography\n# - Cloak: Text-based steganography\n# - Snow: Whitespace steganography\n```\n\nWHAT TO LOOK FOR:\n- **File Capacity**: Enough space for hidden data\n- **Visual Quality**: Stego file looks natural\n- **Compression Artifacts**: Avoid obvious changes\n- **Metadata Preservation**: Keep original file properties\n- **Password Strength**: Strong encryption passphrases\n- **Algorithm Selection**: Appropriate embedding method\n- **Detection Resistance**: Avoid statistical anomalies\n\nSECURITY IMPLICATIONS:\n- **Hidden Communication**: Conceal data transmission\n- **Data Exfiltration**: Secret information transfer\n- **Covert Channels**: Bypass content monitoring\n- **Intellectual Property**: Unauthorized data hiding\n- **Malware Distribution**: Conceal malicious payloads\n- **Forensic Challenges**: Difficult to detect hidden data\n\nCOMMON PITFALLS:\n- **Weak Passphrases**: Easy to crack encryption\n- **Obvious Cover Files**: Suspicious file selection\n- **Size Changes**: Dramatic file size increases\n- **Poor Quality**: Degraded cover file appearance\n- **Single Algorithm**: Easy to detect known methods\n- **No Compression**: Wasted embedding space\n\nTOOLS REFERENCE:\n- **steghide**: Primary steganography tool\n- **openstego**: Java-based alternative\n- **stegano**: Python steganography library\n- **outguess**: Advanced steganography tool\n- **stegdetect**: Steganography detection\n- **file**: File type identification\n\nFURTHER READING:\n- Steganography Fundamentals: Information hiding concepts\n- Digital Watermarking: Content protection techniques\n- Steganalysis: Detection and analysis methods\n- Information Hiding: Academic research papers\n- Covert Channels: Network steganography\n- Forensic Steganography: Investigation techniques",
      "tags": ["steganography", "steghide", "data-hiding", "file-security", "cryptography"]
    },
    {
      "id": "file_security_monitoring",
      "title": "File Security Monitoring with Wireshark",
      "content": "OBJECTIVE: Monitor file transfers and network activity using Wireshark for security analysis.\n\nACADEMIC BACKGROUND:\nWireshark is a network protocol analyzer that captures and examines network traffic. In file security contexts, it helps monitor file transfers, detect unauthorized data exfiltration, and analyze encrypted communications for security issues.\n\nSTEP-BY-STEP PROCESS:\n\n1. Wireshark Installation and Setup:\n\nGetting Started with Wireshark:\n```bash\n# Install Wireshark (Ubuntu/Debian)\nsudo apt update\nsudo apt install wireshark\n\n# Add user to wireshark group\nsudo usermod -a -G wireshark $USER\n# Logout and login again\n\n# Start Wireshark\nwireshark\n\n# Or use tshark (command line)\ntshark --version\n\n# Basic capture\nsudo tshark -i eth0 -c 10\n# -i: interface\n# -c: packet count\n```\n\n2. Capturing File Transfer Traffic:\n\nMonitoring FTP Transfers:\n```bash\n# Capture FTP traffic\ntshark -i eth0 -f \"tcp port 21\" -w ftp_capture.pcap\n\n# Filter for FTP commands\ntshark -r ftp_capture.pcap -Y \"ftp\"\n\n# Extract FTP data\ntshark -r ftp_capture.pcap -Y \"ftp-data\" -T fields -e tcp.payload\n\n# Monitor FTP login attempts\ntshark -r ftp_capture.pcap -Y \"ftp.request.command == USER or ftp.request.command == PASS\"\n\n# Check for plain text passwords\ntshark -r ftp_capture.pcap -Y \"ftp\" | grep -i \"pass\"\n\n# Analyze file transfers\ntshark -r ftp_capture.pcap -Y \"ftp-data\" -T fields -e frame.number -e ip.src -e ip.dst -e tcp.len\n```\n\n3. HTTP File Transfer Analysis:\n\nMonitoring Web-Based File Transfers:\n```bash\n# Capture HTTP traffic\ntshark -i eth0 -f \"tcp port 80\" -w http_capture.pcap\n\n# Filter for file downloads\ntshark -r http_capture.pcap -Y \"http.request.method == GET and http.content_type contains \\\"application\\\"\"\"\n\n# Extract file names from HTTP\ntshark -r http_capture.pcap -Y \"http\" -T fields -e http.request.uri | grep -E \"\\.(pdf|doc|zip|exe)\"\n\n# Monitor file uploads\ntshark -r http_capture.pcap -Y \"http.request.method == POST and http.content_type contains \\\"multipart\\\"\"\"\n\n# Check for large transfers\ntshark -r http_capture.pcap -Y \"tcp.len > 1000\" -T fields -e frame.number -e ip.src -e ip.dst -e tcp.len\n\n# Analyze HTTPS (encrypted)\ntshark -i eth0 -f \"tcp port 443\" -w https_capture.pcap\n# Note: Content is encrypted, can only see metadata\n```\n\n4. SMB/CIFS File Sharing Analysis:\n\nMonitoring Windows File Shares:\n```bash\n# Capture SMB traffic\ntshark -i eth0 -f \"tcp port 445\" -w smb_capture.pcap\n\n# Filter SMB commands\ntshark -r smb_capture.pcap -Y \"smb\" | head -20\n\n# Monitor file operations\ntshark -r smb_capture.pcap -Y \"smb.cmd == 0xa2\"  # SMB2 Create\n\ntshark -r smb_capture.pcap -Y \"smb.cmd == 0x06\"  # SMB Close\n\n# Extract file names\ntshark -r smb_capture.pcap -Y \"smb\" -T fields -e smb.file_name\n\n# Check for unauthorized access\ntshark -r smb_capture.pcap -Y \"smb.nt_status != 0\" -T fields -e smb.nt_status -e ip.src\n\n# Monitor large file transfers\ntshark -r smb_capture.pcap -Y \"smb\" -T fields -e frame.number -e ip.src -e ip.dst -e tcp.len | sort -k5 -nr\n```\n\n5. Encrypted Traffic Analysis:\n\nSSL/TLS File Transfer Monitoring:\n```bash\n# Capture SSL traffic\ntshark -i eth0 -f \"tcp port 443\" -w ssl_capture.pcap\n\n# Analyze SSL handshake\ntshark -r ssl_capture.pcap -Y \"ssl.handshake\" -T fields -e frame.number -e ip.src -e ip.dst -e ssl.handshake.version\n\n# Check certificate information\ntshark -r ssl_capture.pcap -Y \"ssl.handshake.certificate\" -T fields -e x509sat.printableString\n\n# Monitor encrypted file transfers\n# Can only see:\n# - Connection metadata\n# - Certificate details\n# - Data size (but not content)\n\n# Use SSLKEYLOGFILE for decryption (if available)\nexport SSLKEYLOGFILE=/tmp/sslkeys.log\n# Then capture and analyze\n```\n\n6. Data Exfiltration Detection:\n\nIdentifying Suspicious File Transfers:\n```bash\n# Look for unusual file extensions\ntshark -i eth0 -Y \"http\" -T fields -e http.request.uri | grep -E \"\\.(exe|dll|bat|scr|com)$\"\n\n# Monitor large outbound transfers\ntshark -i eth0 -f \"src net 192.168.1.0/24 and dst net not 192.168.1.0/24\" -Y \"tcp.len > 10000\"\n\n# Check for DNS tunneling\ntshark -i eth0 -f \"udp port 53\" -Y \"dns\" -T fields -e dns.qry.name | grep -v \"\\.[a-z]$\n\n# Monitor ICMP traffic (potential covert channels)\ntshark -i eth0 -f \"icmp\" -Y \"icmp\" -T fields -e frame.number -e ip.src -e ip.dst -e data.len\n\n# Look for beaconing behavior\n# Regular connections to same host:port\n\n# Check for unusual protocols\ntshark -i eth0 -f \"not (tcp port 80 or tcp port 443 or udp port 53)\" -c 100\n```\n\n7. File Integrity Monitoring:\n\nDetecting File Changes:\n```bash\n# Use inotify for real-time monitoring\n# Install inotify-tools\nsudo apt install inotify-tools\n\n# Monitor directory for changes\ninotifywait -m -r /var/www/html/\n\n# Monitor specific file types\ninotifywait -m /home/user/ -e modify,create,delete --format '%T %e %w%f' --timefmt '%Y-%m-%d %H:%M:%S'\n\n# Use tripwire for integrity checking\nsudo apt install tripwire\nsudo tripwire --init\nsudo tripwire --check\n\n# AIDE (Advanced Intrusion Detection Environment)\nsudo apt install aide\naideinit\n\n# Monitor with auditd\nsudo apt install auditd\nauditctl -w /etc/passwd -p wa -k passwd_changes\n```
\n\n8. Advanced Analysis Techniques:\n\nDeep Packet Inspection:\n```bash\n# Extract files from PCAP\ntshark -r capture.pcap -Y \"http\" --export-objects http,exported_files/\n\n# Follow TCP streams\ntshark -r capture.pcap -Y \"tcp.stream eq 1\" -T fields -e tcp.payload\n\n# Extract specific protocols\ntshark -r capture.pcap --export-objects smb,smb_files/\n\n# Statistical analysis\ntshark -r capture.pcap -qz io,stat,1\n\n# Conversation analysis\ntshark -r capture.pcap -qz conv,tcp\n\n# Endpoint analysis\ntshark -r capture.pcap -qz endpoints,tcp\n\n# Flow analysis\ntshark -r capture.pcap -qz flow,tcp,ascii\n```\n\nWHAT TO LOOK FOR:\n- **Unusual Protocols**: Unexpected traffic patterns\n- **Large Transfers**: Suspicious data movement\n- **Unauthorized Access**: Failed authentication attempts\n- **Encrypted Traffic**: SSL/TLS usage patterns\n- **File Types**: Executable or sensitive file transfers\n- **Timing Patterns**: Regular beaconing or unusual hours\n- **Source/Destination**: Unexpected network locations\n\nSECURITY IMPLICATIONS:\n- **Data Exfiltration**: Unauthorized data removal\n- **Malware Distribution**: Infected file transfers\n- **Insider Threats**: Internal data theft\n- **Compliance Violations**: Unauthorized data handling\n- **Network Compromise**: Lateral movement detection\n- **Forensic Evidence**: Incident investigation data\n\nCOMMON PITFALLS:\n- **Encrypted Traffic Blindness**: Cannot see HTTPS content\n- **High Volume Data**: Overwhelming analysis capabilities\n- **False Positives**: Legitimate traffic flagged as suspicious\n- **Performance Impact**: Capture overhead on production systems\n- **Storage Requirements**: Large PCAP file sizes\n- **Legal Issues**: Unauthorized traffic monitoring\n\nTOOLS REFERENCE:\n- **wireshark**: GUI network analyzer\n- **tshark**: Command-line Wireshark\n- **tcpdump**: Alternative packet capture\n- **inotify**: File system monitoring\n- **tripwire**: File integrity checking\n- **aide**: Advanced integrity checking\n- **auditd**: System auditing\n\nFURTHER READING:\n- Network Forensics: Traffic analysis techniques\n- Packet Analysis: Protocol dissection methods\n- Intrusion Detection: Network security monitoring\n- Digital Forensics: Evidence collection procedures\n- Data Loss Prevention: Exfiltration prevention\n- Compliance Monitoring: Regulatory requirements",
      "tags": ["wireshark", "monitoring", "network-analysis", "file-security", "forensics"]
    },
    {
      "id": "file_security_best_practices",
      "title": "File Security Best Practices",
      "content": "OBJECTIVE: Learn comprehensive file security practices including encryption, access controls, and monitoring.\n\nACADEMIC BACKGROUND:\nFile security encompasses multiple layers of protection including encryption, access controls, integrity monitoring, and secure transmission. Implementing these practices helps protect sensitive data from unauthorized access, modification, and exfiltration.\n\nSTEP-BY-STEP PROCESS:\n\n1. File Encryption Standards:\n\nChoosing Appropriate Encryption:\n```bash\n# For files at rest:\n# - Use AES-256 for symmetric encryption\n# - Use RSA-4096 or ECC for asymmetric\n# - Implement proper key management\n# - Use authenticated encryption (GCM mode)\n\n# For files in transit:\n# - Use TLS 1.3 for network transfer\n# - Implement perfect forward secrecy\n# - Verify certificate validity\n# - Use secure protocols (SFTP, HTTPS)\n\n# Encryption tools:\n# - GPG for file encryption\n# - VeraCrypt for containers\n# - BitLocker for Windows volumes\n# - FileVault for macOS\n# - LUKS for Linux partitions\n```\n\n2. Access Control Implementation:\n\nFile Permission Management:\n```bash\n# Linux file permissions\n# View permissions\nls -la file.txt\n# -rw-r--r-- 1 user group 1024 Jan 1 12:00 file.txt\n\n# Set permissions\nchmod 600 sensitive.txt  # Owner read/write only\nchmod 644 public.txt     # Owner read/write, others read\nchmod 755 script.sh      # Owner full, others read/execute\n\n# Set ownership\nchown user:group file.txt\n\n# Use ACLs for fine-grained control\nsudo apt install acl\nsetfacl -m u:alice:rw file.txt\nsetfacl -m g:admins:rw file.txt\n\n# Windows permissions\n# Use icacls\nicacls file.txt /grant alice:(R,W)\nicacls file.txt /deny bob:(R)\n\n# Remove inheritance\nicacls file.txt /inheritance:r\n```\n\n3. Secure File Transfer:\n\nSafe Data Transmission:\n```bash\n# Use secure protocols\n# SFTP instead of FTP\nsftp user@server\nput file.txt\n\n# SCP with key authentication\nscp -i key.pem file.txt user@server:/path/\n\n# Rsync over SSH\nrsync -avz -e ssh /local/path/ user@server:/remote/path/\n\n# HTTPS for web transfers\ncurl -X POST -F \"file=@upload.txt\" https://secure.example.com/upload\n\n# Avoid insecure methods\n# No plain FTP\n# No HTTP without TLS\n# No email attachments for sensitive data\n\n# Verify transfers\n# Use checksums\nsha256sum file.txt > file.txt.sha256\n# Verify on destination\nsha256sum -c file.txt.sha256\n```\n\n4. File Integrity Monitoring:\n\nDetecting Unauthorized Changes:\n```bash\n# Use AIDE for integrity checking\nsudo apt install aide\naideinit  # Create database\n\n# Check integrity\naide --check\n\n# Update database after legitimate changes\naide --update\n\n# Use Samhain\nsudo apt install samhain\nsamhain -t init  # Initialize\nsamhain -t check # Check\n\n# Tripwire\nsudo apt install tripwire\ntripwire --init\ntripwire --check\n\n# OSSEC file integrity monitoring\n# Configure in ossec.conf\n<syscheck>\n  <directories check_all=\"yes\">/etc,/usr/bin,/usr/sbin</directories>\n  <directories check_all=\"yes\" realtime=\"yes\">/var/www</directories>\n</syscheck>\n```
\n\n5. Backup Security:\n\nSecure Data Backup:\n```bash\n# Encrypt backups\n# Use duplicity for encrypted backups\nduplicity /home/user file:///media/backup\n\n# Encrypt with GPG before backup\ntar -czf - /important/data | gpg --symmetric | ssh user@backup \"cat > backup.tar.gz.gpg\"\n\n# Secure backup storage\n# Use offsite storage\n# Implement access controls\n# Regular integrity checks\n\n# Backup best practices:\n# - Test restoration procedures\n# - Keep multiple backup generations\n# - Store encryption keys separately\n# - Use immutable backups\n# - Regular backup verification\n\n# Cloud backup security:\n# - Use provider encryption\n# - Enable 2FA\n# - Review access logs\n# - Understand data location\n```\n\n6. Data Classification and Handling:\n\nSensitive Data Management:\n```bash\n# Classify data by sensitivity:\n# - Public: No restrictions\n# - Internal: Limited access\n# - Confidential: Restricted access\n# - Secret: Highly restricted\n\n# Implement data labeling:\n# File naming conventions\n# Metadata tagging\n# Digital rights management\n\n# Data handling procedures:\n# - Encryption at rest and in transit\n# - Access logging and monitoring\n# - Regular access reviews\n# - Secure deletion procedures\n\n# Secure deletion:\n# Linux: shred -u -v -n 3 file.txt\n# Windows: cipher /w:C:\\path\n# Secure erase tools: srm, wipe\n\n# Data retention policies:\n# - Define retention periods\n# - Implement automated deletion\n# - Document disposal procedures\n```\n\n7. Network Security for Files:\n\nProtecting File Transfers:\n```bash\n# Implement network controls:\n# - Use VPN for remote access\n# - Implement DLP (Data Loss Prevention)\n# - Monitor for exfiltration attempts\n# - Use network segmentation\n\n# Firewall rules for file services:\n# Allow only necessary ports\niptables -A INPUT -p tcp --dport 22 -s trusted_network -j ACCEPT\niptables -A INPUT -p tcp --dport 22 -j DROP\n\n# Use application firewalls:\n# ModSecurity for web applications\n# File transfer monitoring\n\n# Network encryption:\n# IPsec for network-level encryption\n# TLS for application-level encryption\n\n# Intrusion detection:\n# Monitor for file transfer anomalies\n# Alert on suspicious patterns\n```\n\n8. Incident Response for File Security:\n\nHandling File Security Incidents:\n```bash\n# Detection and analysis:\n# - Monitor for unauthorized access\n# - Check file integrity\n# - Review access logs\n# - Analyze network traffic\n\n# Containment:\n# - Revoke compromised credentials\n# - Isolate affected systems\n# - Block malicious network access\n# - Preserve evidence\n\n# Eradication:\n# - Remove malicious files\n# - Clean compromised systems\n# - Update security controls\n# - Patch vulnerabilities\n\n# Recovery:\n# - Restore from clean backups\n# - Verify system integrity\n# - Monitor for reinfection\n# - Update incident response plan\n\n# Lessons learned:\n# - Document the incident\n# - Update security controls\n# - Conduct training\n# - Review and improve procedures\n```\n\nWHAT TO LOOK FOR:\n- **Encryption Strength**: Modern algorithms and proper implementation\n- **Access Controls**: Principle of least privilege\n- **Monitoring Coverage**: Comprehensive security monitoring\n- **Backup Integrity**: Verifiable and secure backups\n- **Data Classification**: Appropriate protection levels\n- **Incident Response**: Effective breach handling\n- **Compliance Requirements**: Regulatory adherence\n\nSECURITY IMPLICATIONS:\n- **Data Confidentiality**: Protection against unauthorized access\n- **Data Integrity**: Prevention of unauthorized modification\n- **Data Availability**: Ensuring access to authorized users\n- **Regulatory Compliance**: Meeting legal requirements\n- **Business Continuity**: Maintaining operations during incidents\n- **Reputation Protection**: Avoiding data breach consequences\n\nCOMMON PITFALLS:\n- **Weak Encryption**: Using deprecated algorithms\n- **Overly Permissive Access**: Granting unnecessary privileges\n- **Inadequate Monitoring**: Missing security events\n- **Poor Backup Practices**: Unreliable or insecure backups\n- **Data Misclassification**: Incorrect protection levels\n- **Inadequate Training**: Lack of security awareness\n\nTOOLS REFERENCE:\n- **gpg**: File encryption\n- **veracrypt**: Encrypted containers\n- **aide**: Integrity monitoring\n- **rsync**: Secure file transfer\n- **duplicity**: Encrypted backups\n- **ossec**: Security monitoring\n- **chkrootkit**: Rootkit detection\n\nFURTHER READING:\n- Data Protection Best Practices: Industry standards\n- Encryption Standards: Algorithm selection and implementation\n- Access Control Models: Security frameworks\n- Backup and Recovery: Business continuity planning\n- Data Loss Prevention: Exfiltration prevention\n- Incident Response: Security breach handling",
      "tags": ["file-security", "best-practices", "encryption", "access-control", "monitoring"]
    }
  ]
}</content>
<parameter name="filePath">/home/altin/pt-journal/data/tutorials/file_security_practices.json