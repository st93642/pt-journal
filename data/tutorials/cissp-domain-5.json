{
  "id": "cissp-domain-5",
  "title": "CISSP Domain 5: Identity and Access Management",
  "type": "tutorial",
  "steps": [
    {
      "id": "identity-management-fundamentals",
      "title": "Identity Management Fundamentals and Concepts",
      "content": "OBJECTIVE: Understand the fundamental concepts and principles of identity and access management (IAM) systems.\n\nACADEMIC BACKGROUND:\nIdentity and Access Management (IAM) is a framework of policies and technologies that ensures the right individuals have the appropriate access to technology resources. This domain covers the lifecycle of digital identities, from creation through management to eventual termination, and the associated access controls that govern resource usage.\n\n## Understanding Digital Identity\n\n### What is Digital Identity?\nA digital identity is the electronic representation of an individual's or entity's attributes, credentials, and entitlements within an information system. Digital identities enable secure access to resources while maintaining privacy and accountability.\n\n**Identity Components:**\n- **Identifiers**: Unique attributes that distinguish one identity from another (username, email, employee ID)\n- **Credentials**: Proof of identity (passwords, certificates, biometrics)\n- **Attributes**: Additional information about the identity (role, department, clearance level)\n- **Entitlements**: Permissions and access rights associated with the identity\n\n**Identity Types:**\n- **Human Identities**: Individual users (employees, contractors, customers)\n- **Non-Human Identities**: System accounts, service accounts, IoT devices, applications\n- **Temporary Identities**: Guest accounts, emergency access accounts\n\n### Identity Lifecycle Management\nThe identity lifecycle encompasses all stages from initial creation to final termination.\n\n**Provision Phase:**\n- **Identity Creation**: Establishing new digital identities\n- **Attribute Assignment**: Assigning roles, groups, and permissions\n- **Credential Issuance**: Providing authentication credentials\n- **Entitlement Granting**: Assigning appropriate access rights\n\n**Maintenance Phase:**\n- **Identity Updates**: Modifying attributes and entitlements\n- **Credential Management**: Password resets, certificate renewals\n- **Access Reviews**: Periodic validation of access rights\n- **Lifecycle Events**: Role changes, department transfers\n\n**Termination Phase:**\n- **Account Deactivation**: Disabling access immediately\n- **Access Revocation**: Removing all entitlements\n- **Credential Destruction**: Invalidating all credentials\n- **Audit Logging**: Recording termination activities\n\n### Identity Federation\nIdentity federation allows users to access multiple systems using a single set of credentials by establishing trust relationships between identity providers.\n\n**Federation Models:**\n- **Web SSO**: Single sign-on across web applications\n- **SAML**: Security Assertion Markup Language for web-based federation\n- **OAuth**: Authorization framework for delegated access\n- **OpenID Connect**: Identity layer on top of OAuth 2.0\n\n**Federation Benefits:**\n- **User Convenience**: Single sign-on experience\n- **Reduced Administration**: Centralized identity management\n- **Improved Security**: Consistent authentication policies\n- **Scalability**: Support for large user populations\n\n## Access Control Principles\n\n### Access Control Concepts\nAccess control determines who can access what resources under what conditions.\n\n**Core Principles:**\n- **Least Privilege**: Users should have minimum necessary access\n- **Need-to-Know**: Access based on job requirements\n- **Separation of Duties**: Critical tasks require multiple individuals\n- **Fail-Safe Defaults**: Default to denying access\n\n**Access Control Types:**\n- **Discretionary Access Control (DAC)**: Resource owners control access\n- **Mandatory Access Control (MAC)**: System enforces access based on security labels\n- **Role-Based Access Control (RBAC)**: Access based on user roles\n- **Attribute-Based Access Control (ABAC)**: Access based on attributes and policies\n\n### Authentication Methods\nAuthentication verifies the identity of users and systems.\n\n**Authentication Factors:**\n- **Something You Know**: Passwords, PINs, security questions\n- **Something You Have**: Smart cards, tokens, mobile devices\n- **Something You Are**: Biometrics (fingerprint, iris, facial recognition)\n- **Something You Do**: Behavioral biometrics (keystroke dynamics, gait)\n- **Somewhere You Are**: Location-based authentication\n\n**Multi-Factor Authentication (MFA):**\n- **Two-Factor Authentication (2FA)**: Two different factor types\n- **Three-Factor Authentication (3FA)**: Three different factor types\n- **Adaptive Authentication**: Risk-based authentication adjustments\n\nWHAT TO LOOK FOR:\n- Comprehensive identity lifecycle management\n- Strong authentication mechanisms\n- Proper access control implementation\n- Regular access reviews and audits\n- Secure credential management\n\nSECURITY IMPLICATIONS:\n- Prevention of unauthorized access\n- Protection of sensitive resources\n- Compliance with regulatory requirements\n- Reduction of insider threats\n- Accountability through audit trails\n\nCOMMON PITFALLS:\n- Over-privileged accounts\n- Weak password policies\n- Lack of access reviews\n- Poor credential management\n- Insufficient monitoring\n\nTOOLS REFERENCE:\n- **IAM Solutions**: Microsoft Active Directory, Okta, Ping Identity\n- **Authentication**: RSA SecurID, YubiKey, Duo Security\n- **Access Management**: AWS IAM, Azure AD, SailPoint\n- **Federation**: ADFS, Shibboleth, Keycloak\n\nFURTHER READING:\n- \"Identity and Access Management\" by Ertem Osmanoglu\n- NIST SP 800-63 Digital Identity Guidelines\n- \"Access Control and Identity Management\" by Mike Chapple\n\nSTEP-BY-STEP PROCESS:\n\n1. Identity Lifecycle Management Implementation:\n\nIdentity Management System:\n```python\nfrom typing import Dict, List, Any, Optional, Set\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport hashlib\nimport secrets\n\nclass IdentityStatus(Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\"\n    SUSPENDED = \"suspended\"\n    TERMINATED = \"terminated\"\n\nclass AuthenticationFactor(Enum):\n    KNOWLEDGE = \"knowledge\"  # Something you know\n    POSSESSION = \"possession\"  # Something you have\n    INHERENCE = \"inherence\"  # Something you are\n    LOCATION = \"location\"    # Somewhere you are\n    BEHAVIOR = \"behavior\"    # Something you do\n\n@dataclass\nclass DigitalIdentity:\n    user_id: str\n    username: str\n    email: str\n    status: IdentityStatus\n    created_date: datetime\n    last_login: Optional[datetime]\n    roles: Set[str]\n    groups: Set[str]\n    attributes: Dict[str, Any]\n    entitlements: Set[str]\n    \n    def is_active(self) -> bool:\n        return self.status == IdentityStatus.ACTIVE\n    \n    def has_role(self, role: str) -> bool:\n        return role in self.roles\n    \n    def has_entitlement(self, entitlement: str) -> bool:\n        return entitlement in self.entitlements\n\nclass IdentityProvider:\n    def __init__(self):\n        self.identities: Dict[str, DigitalIdentity] = {}\n        self.password_hashes: Dict[str, str] = {}\n        self.sessions: Dict[str, Dict] = {}\n        self.audit_log: List[Dict] = []\n    \n    def create_identity(self, user_id: str, username: str, email: str, \n                       initial_roles: List[str] = None, attributes: Dict = None) -> DigitalIdentity:\n        \"\"\"Create a new digital identity\"\"\"\n        if user_id in self.identities:\n            raise ValueError(f\"Identity {user_id} already exists\")\n        \n        identity = DigitalIdentity(\n            user_id=user_id,\n            username=username,\n            email=email,\n            status=IdentityStatus.ACTIVE,\n            created_date=datetime.now(),\n            last_login=None,\n            roles=set(initial_roles or []),\n            groups=set(),\n            attributes=attributes or {},\n            entitlements=set()\n        )\n        \n        self.identities[user_id] = identity\n        self._audit_event(\"identity_created\", user_id, {\"username\": username, \"email\": email})\n        \n        return identity\n    \n    def authenticate_user(self, username: str, password: str, \n                         factors: List[AuthenticationFactor] = None) -> Optional[str]:\n        \"\"\"Authenticate user with provided credentials\"\"\"\n        # Find identity by username\n        identity = None\n        for ident in self.identities.values():\n            if ident.username == username:\n                identity = ident\n                break\n        \n        if not identity or not identity.is_active():\n            return None\n        \n        # Verify password\n        stored_hash = self.password_hashes.get(identity.user_id)\n        if not stored_hash or not self._verify_password(password, stored_hash):\n            self._audit_event(\"authentication_failed\", identity.user_id, {\"reason\": \"invalid_password\"})\n            return None\n        \n        # Check additional factors (simplified)\n        if factors and len(factors) > 1:\n            # In real implementation, verify each factor\n            pass\n        \n        # Create session\n        session_id = secrets.token_hex(32)\n        self.sessions[session_id] = {\n            'user_id': identity.user_id,\n            'created': datetime.now(),\n            'expires': datetime.now() + timedelta(hours=8)\n        }\n        \n        # Update last login\n        identity.last_login = datetime.now()\n        \n        self._audit_event(\"authentication_success\", identity.user_id, {\"session_id\": session_id})\n        return session_id\n    \n    def authorize_access(self, session_id: str, resource: str, action: str) -> bool:\n        \"\"\"Authorize access to a resource\"\"\"\n        session = self.sessions.get(session_id)\n        if not session or session['expires'] < datetime.now():\n            return False\n        \n        user_id = session['user_id']\n        identity = self.identities.get(user_id)\n        if not identity or not identity.is_active():\n            return False\n        \n        # Check entitlements (simplified RBAC)\n        required_entitlement = f\"{resource}:{action}\"\n        if required_entitlement not in identity.entitlements:\n            self._audit_event(\"authorization_denied\", user_id, \n                            {\"resource\": resource, \"action\": action})\n            return False\n        \n        self._audit_event(\"authorization_granted\", user_id, \n                        {\"resource\": resource, \"action\": action})\n        return True\n    \n    def update_identity(self, user_id: str, updates: Dict) -> bool:\n        \"\"\"Update identity attributes and entitlements\"\"\"\n        if user_id not in self.identities:\n            return False\n        \n        identity = self.identities[user_id]\n        \n        # Update attributes\n        for key, value in updates.items():\n            if hasattr(identity, key):\n                if key in ['roles', 'groups', 'entitlements']:\n                    setattr(identity, key, set(value))\n                else:\n                    setattr(identity, key, value)\n        \n        self._audit_event(\"identity_updated\", user_id, updates)\n        return True\n    \n    def terminate_identity(self, user_id: str) -> bool:\n        \"\"\"Terminate an identity and revoke all access\"\"\"\n        if user_id not in self.identities:\n            return False\n        \n        identity = self.identities[user_id]\n        identity.status = IdentityStatus.TERMINATED\n        \n        # Revoke all sessions\n        sessions_to_remove = [sid for sid, sess in self.sessions.items() \n                            if sess['user_id'] == user_id]\n        for sid in sessions_to_remove:\n            del self.sessions[sid]\n        \n        self._audit_event(\"identity_terminated\", user_id, {})\n        return True\n    \n    def set_password(self, user_id: str, password: str):\n        \"\"\"Set user password (with proper hashing)\"\"\"\n        salt = secrets.token_hex(16)\n        hash_input = f\"{password}{salt}\"\n        password_hash = hashlib.sha256(hash_input.encode()).hexdigest()\n        self.password_hashes[user_id] = f\"{salt}:{password_hash}\"\n    \n    def _verify_password(self, password: str, stored_hash: str) -> bool:\n        \"\"\"Verify password against stored hash\"\"\"\n        salt, hash_value = stored_hash.split(':')\n        hash_input = f\"{password}{salt}\"\n        return hashlib.sha256(hash_input.encode()).hexdigest() == hash_value\n    \n    def _audit_event(self, event_type: str, user_id: str, details: Dict):\n        \"\"\"Log audit event\"\"\"\n        event = {\n            'timestamp': datetime.now(),\n            'event_type': event_type,\n            'user_id': user_id,\n            'details': details\n        }\n        self.audit_log.append(event)\n    \n    def get_audit_log(self, user_id: Optional[str] = None, event_type: Optional[str] = None) -> List[Dict]:\n        \"\"\"Retrieve audit log entries\"\"\"\n        log = self.audit_log\n        \n        if user_id:\n            log = [entry for entry in log if entry['user_id'] == user_id]\n        if event_type:\n            log = [entry for entry in log if entry['event_type'] == event_type]\n        \n        return log\n\ndef demonstrate_identity_management():\n    \"\"\"Demonstrate identity and access management\"\"\"\n    idp = IdentityProvider()\n    \n    # Create identities\n    user1 = idp.create_identity(\"user001\", \"alice\", \"alice@company.com\", \n                               [\"employee\"], {\"department\": \"IT\", \"clearance\": \"secret\"})\n    user2 = idp.create_identity(\"user002\", \"bob\", \"bob@company.com\", \n                               [\"manager\"], {\"department\": \"HR\", \"clearance\": \"confidential\"})\n    \n    # Set passwords\n    idp.set_password(\"user001\", \"SecurePass123!\")\n    idp.set_password(\"user002\", \"ManagerPass456!\")\n    \n    # Assign entitlements\n    idp.update_identity(\"user001\", {\"entitlements\": [\"file_server:read\", \"email:send\"]})\n    idp.update_identity(\"user002\", {\"entitlements\": [\"file_server:read\", \"file_server:write\", \"hr_database:admin\"]})\n    \n    # Authenticate users\n    session1 = idp.authenticate_user(\"alice\", \"SecurePass123!\")\n    session2 = idp.authenticate_user(\"bob\", \"ManagerPass456!\")\n    \n    # Test authorization\n    alice_can_read = idp.authorize_access(session1, \"file_server\", \"read\")\n    alice_can_write = idp.authorize_access(session1, \"file_server\", \"write\")\n    bob_can_admin = idp.authorize_access(session2, \"hr_database\", \"admin\")\n    \n    # Terminate identity\n    idp.terminate_identity(\"user001\")\n    \n    # Check audit log\n    audit_log = idp.get_audit_log()\n    \n    return {\n        'identities_created': len(idp.identities),\n        'active_sessions': len(idp.sessions),\n        'authentication_results': {\n            'alice_authenticated': session1 is not None,\n            'bob_authenticated': session2 is not None\n        },\n        'authorization_results': {\n            'alice_read_access': alice_can_read,\n            'alice_write_access': alice_can_write,\n            'bob_admin_access': bob_can_admin\n        },\n        'audit_events': len(audit_log),\n        'terminated_identities': len([i for i in idp.identities.values() if i.status == IdentityStatus.TERMINATED])\n    }\n```\n\n2. Access Control Implementation:\n\nRole-Based Access Control System:\n```python\nfrom typing import Dict, List, Any, Optional, Set\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\nclass AccessDecision(Enum):\n    GRANT = \"grant\"\n    DENY = \"deny\"\n    INDETERMINATE = \"indeterminate\"\n\n@dataclass\nclass Role:\n    name: str\n    description: str\n    permissions: Set[str]\n    parent_roles: Set[str]  # For role hierarchy\n    \n    def has_permission(self, permission: str) -> bool:\n        return permission in self.permissions\n    \n    def get_all_permissions(self, role_registry: Dict[str, 'Role']) -> Set[str]:\n        \"\"\"Get all permissions including inherited ones\"\"\"\n        all_perms = set(self.permissions)\n        \n        for parent_name in self.parent_roles:\n            if parent_name in role_registry:\n                parent = role_registry[parent_name]\n                all_perms.update(parent.get_all_permissions(role_registry))\n        \n        return all_perms\n\n@dataclass\nclass AccessPolicy:\n    name: str\n    resource: str\n    action: str\n    conditions: List[str]  # Policy conditions\n    effect: AccessDecision\n    \n    def evaluate(self, context: Dict) -> AccessDecision:\n        \"\"\"Evaluate policy against context\"\"\"\n        # Simplified policy evaluation\n        for condition in self.conditions:\n            if not self._check_condition(condition, context):\n                return AccessDecision.INDETERMINATE\n        \n        return self.effect\n    \n    def _check_condition(self, condition: str, context: Dict) -> bool:\n        \"\"\"Check individual policy condition\"\"\"\n        # Simplified condition checking\n        if \"time\" in condition and \"business_hours\" in condition:\n            current_hour = datetime.now().hour\n            return 9 <= current_hour <= 17\n        elif \"location\" in condition and \"office\" in condition:\n            return context.get(\"location\") == \"office\"\n        elif \"device\" in condition and \"trusted\" in condition:\n            return context.get(\"device_trusted\", False)\n        \n        return True  # Default to true for unknown conditions\n\nclass AccessControlSystem:\n    def __init__(self):\n        self.roles: Dict[str, Role] = {}\n        self.policies: List[AccessPolicy] = {}\n        self.user_roles: Dict[str, Set[str]] = {}\n        self.role_assignments: Dict[str, Set[str]] = {}  # role -> users\n        self.access_log: List[Dict] = []\n    \n    def create_role(self, name: str, description: str, permissions: List[str], \n                   parent_roles: List[str] = None) -> Role:\n        \"\"\"Create a new role\"\"\"\n        role = Role(\n            name=name,\n            description=description,\n            permissions=set(permissions),\n            parent_roles=set(parent_roles or [])\n        )\n        \n        self.roles[name] = role\n        return role\n    \n    def assign_role_to_user(self, user_id: str, role_name: str):\n        \"\"\"Assign role to user\"\"\"\n        if role_name not in self.roles:\n            raise ValueError(f\"Role {role_name} does not exist\")\n        \n        if user_id not in self.user_roles:\n            self.user_roles[user_id] = set()\n        \n        self.user_roles[user_id].add(role_name)\n        \n        if role_name not in self.role_assignments:\n            self.role_assignments[role_name] = set()\n        \n        self.role_assignments[role_name].add(user_id)\n    \n    def create_policy(self, name: str, resource: str, action: str, \n                     conditions: List[str], effect: AccessDecision):\n        \"\"\"Create access control policy\"\"\"\n        policy = AccessPolicy(\n            name=name,\n            resource=resource,\n            action=action,\n            conditions=conditions,\n            effect=effect\n        )\n        \n        self.policies[name] = policy\n    \n    def check_access(self, user_id: str, resource: str, action: str, \n                    context: Dict = None) -> AccessDecision:\n        \"\"\"Check if user has access to perform action on resource\"\"\"\n        context = context or {}\n        \n        # Get user roles\n        user_roles = self.user_roles.get(user_id, set())\n        \n        # Collect all permissions from user's roles\n        user_permissions = set()\n        for role_name in user_roles:\n            if role_name in self.roles:\n                role = self.roles[role_name]\n                user_permissions.update(role.get_all_permissions(self.roles))\n        \n        # Check direct permission\n        required_permission = f\"{resource}:{action}\"\n        if required_permission in user_permissions:\n            self._log_access(user_id, resource, action, AccessDecision.GRANT, \"role_based\")\n            return AccessDecision.GRANT\n        \n        # Check policies\n        for policy in self.policies.values():\n            if policy.resource == resource and policy.action == action:\n                decision = policy.evaluate(context)\n                if decision != AccessDecision.INDETERMINATE:\n                    self._log_access(user_id, resource, action, decision, \"policy_based\")\n                    return decision\n        \n        # Default deny\n        self._log_access(user_id, resource, action, AccessDecision.DENY, \"default_deny\")\n        return AccessDecision.DENY\n    \n    def implement_least_privilege(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Review and minimize user privileges\"\"\"\n        user_roles = self.user_roles.get(user_id, set())\n        user_permissions = set()\n        \n        for role_name in user_roles:\n            if role_name in self.roles:\n                role = self.roles[role_name]\n                user_permissions.update(role.get_all_permissions(self.roles))\n        \n        # Analyze permission usage (simplified)\n        used_permissions = set()\n        for log_entry in self.access_log:\n            if log_entry['user_id'] == user_id and log_entry['decision'] == 'grant':\n                used_permissions.add(f\"{log_entry['resource']}:{log_entry['action']}\")\n        \n        unused_permissions = user_permissions - used_permissions\n        \n        return {\n            'total_permissions': len(user_permissions),\n            'used_permissions': len(used_permissions),\n            'unused_permissions': list(unused_permissions),\n            'recommendations': [\n                f\"Consider removing {len(unused_permissions)} unused permissions\",\n                \"Implement regular access reviews\",\n                \"Use just-in-time access for privileged operations\"\n            ]\n        }\n    \n    def _log_access(self, user_id: str, resource: str, action: str, \n                   decision: AccessDecision, reason: str):\n        \"\"\"Log access decision\"\"\"\n        log_entry = {\n            'timestamp': datetime.now(),\n            'user_id': user_id,\n            'resource': resource,\n            'action': action,\n            'decision': decision.value,\n            'reason': reason\n        }\n        self.access_log.append(log_entry)\n\ndef demonstrate_access_control():\n    \"\"\"Demonstrate access control implementation\"\"\"\n    acs = AccessControlSystem()\n    \n    # Create roles\n    employee_role = acs.create_role(\n        \"employee\", \n        \"Basic employee role\", \n        [\"file_server:read\", \"email:send\"]\n    )\n    \n    manager_role = acs.create_role(\n        \"manager\", \n        \"Manager role with additional permissions\", \n        [\"file_server:write\", \"reports:view\"], \n        [\"employee\"]  # Inherits from employee\n    )\n    \n    admin_role = acs.create_role(\n        \"admin\", \n        \"Administrator role\", \n        [\"system:admin\", \"user_management:*\"]\n    )\n    \n    # Assign roles to users\n    acs.assign_role_to_user(\"alice\", \"employee\")\n    acs.assign_role_to_user(\"bob\", \"manager\")\n    acs.assign_role_to_user(\"admin\", \"admin\")\n    \n    # Create policies\n    acs.create_policy(\n        \"business_hours_only\", \n        \"sensitive_data\", \n        \"access\", \n        [\"time=business_hours\"], \n        AccessDecision.GRANT\n    )\n    \n    acs.create_policy(\n        \"office_only\", \n        \"internal_network\", \n        \"connect\", \n        [\"location=office\"], \n        AccessDecision.GRANT\n    )\n    \n    # Test access control\n    alice_file_access = acs.check_access(\"alice\", \"file_server\", \"read\")\n    alice_write_access = acs.check_access(\"alice\", \"file_server\", \"write\")\n    bob_write_access = acs.check_access(\"bob\", \"file_server\", \"write\")\n    bob_reports_access = acs.check_access(\"bob\", \"reports\", \"view\")\n    \n    # Test policy-based access\n    sensitive_access = acs.check_access(\n        \"alice\", \n        \"sensitive_data\", \n        \"access\", \n        {\"time\": \"business_hours\"}\n    )\n    \n    # Implement least privilege\n    alice_privilege_review = acs.implement_least_privilege(\"alice\")\n    \n    return {\n        'roles_created': len(acs.roles),\n        'users_with_roles': len(acs.user_roles),\n        'access_tests': {\n            'alice_file_read': alice_file_access.value,\n            'alice_file_write': alice_write_access.value,\n            'bob_file_write': bob_write_access.value,\n            'bob_reports_view': bob_reports_access.value,\n            'alice_sensitive_data': sensitive_access.value\n        },\n        'policies_created': len(acs.policies),\n        'privilege_analysis': alice_privilege_review,\n        'audit_entries': len(acs.access_log)\n    }\n```",
      "tags": [
        "identity-management",
        "access-control",
        "authentication",
        "authorization",
        "iam",
        "cissp"
      ]
    },
    {
      "id": "authentication-authorization",
      "title": "Authentication and Authorization Mechanisms",
      "content": "OBJECTIVE: Implement robust authentication and authorization mechanisms to secure access to resources.\n\nACADEMIC BACKGROUND:\nAuthentication and authorization are fundamental security functions that work together to ensure that only authorized individuals can access protected resources. While authentication verifies identity, authorization determines what actions authenticated users can perform.\n\n## Authentication Technologies\n\n### Password-Based Authentication\nTraditional password authentication remains widely used despite its limitations.\n\n**Password Security Best Practices:**\n- **Complexity Requirements**: Minimum length, character variety\n- **Regular Changes**: Periodic password updates\n- **No Reuse**: Prevent password recycling\n- **Secure Storage**: Proper hashing and salting\n\n**Password Hashing Algorithms:**\n- **bcrypt**: Adaptive hashing with salt\n- **scrypt**: Memory-hard function resistant to hardware attacks\n- **Argon2**: Winner of Password Hashing Competition\n- **PBKDF2**: Standard key derivation function\n\n### Token-Based Authentication\nTokens provide an additional authentication factor beyond passwords.\n\n**Token Types:**\n- **Hardware Tokens**: Physical devices generating one-time codes\n- **Software Tokens**: Mobile apps providing time-based codes\n- **Smart Cards**: Physical cards with embedded chips\n- **USB Tokens**: Portable authentication devices\n\n**Time-Based One-Time Passwords (TOTP):**\n- **Algorithm**: HMAC-SHA1 with time windows\n- **Window Size**: 30-second intervals\n- **Clock Synchronization**: Required between token and server\n- **Replay Protection**: Each code usable only once\n\n### Certificate-Based Authentication\nDigital certificates provide strong authentication using public key cryptography.\n\n**Certificate Components:**\n- **Subject**: Entity being authenticated\n- **Issuer**: Certificate authority\n- **Public Key**: Used for encryption/verification\n- **Validity Period**: Certificate lifetime\n- **Signature**: CA's digital signature\n\n**Certificate Authorities (CAs):**\n- **Root CA**: Top-level trusted authority\n- **Intermediate CA**: Issues certificates on behalf of root\n- **Self-Signed Certificates**: Not recommended for production\n\n### Biometric Authentication\nBiometrics use unique physical or behavioral characteristics for authentication.\n\n**Biometric Types:**\n- **Physiological**: Fingerprint, iris, facial recognition, DNA\n- **Behavioral**: Keystroke dynamics, voice patterns, gait analysis\n- **Advantages**: Cannot be lost or forgotten, difficult to forge\n- **Limitations**: Privacy concerns, potential for false positives/negatives\n\n## Authorization Models\n\n### Role-Based Access Control (RBAC)\nRBAC assigns permissions based on user roles within an organization.\n\n**RBAC Components:**\n- **Users**: Individuals accessing the system\n- **Roles**: Job functions or responsibilities\n- **Permissions**: Allowed operations on resources\n- **Sessions**: User-role activations\n\n**RBAC Variations:**\n- **Core RBAC**: Basic user-role-permission relationships\n- **Hierarchical RBAC**: Role inheritance\n- **Constrained RBAC**: Separation of duties\n- **Symmetric RBAC**: Bidirectional role relationships\n\n### Attribute-Based Access Control (ABAC)\nABAC makes access decisions based on attributes of users, resources, and environment.\n\n**ABAC Attributes:**\n- **Subject Attributes**: User properties (department, clearance, role)\n- **Object Attributes**: Resource properties (classification, owner, type)\n- **Environment Attributes**: Context (time, location, threat level)\n- **Action Attributes**: Operation properties (read, write, execute)\n\n**Policy Language:**\n- **XACML**: eXtensible Access Control Markup Language\n- **ALFA**: Abbreviated Language for Authorization\n- **Policy Evaluation**: Combining algorithms (permit-overrides, deny-overrides)\n\n### Mandatory Access Control (MAC)\nMAC enforces access control based on security labels assigned to subjects and objects.\n\n**Security Labels:**\n- **Classification Levels**: Unclassified, Confidential, Secret, Top Secret\n- **Categories**: Compartments or compartments within classifications\n- **Dominance**: Label relationships (higher/lower classifications)\n\n**Bell-LaPadula Model:**\n- **Simple Security Property**: No read up\n- **Star Property**: No write down\n- **Strong Star Property**: No write up, no read down\n\nWHAT TO LOOK FOR:\n- Multi-factor authentication implementation\n- Strong password policies and management\n- Proper authorization controls\n- Regular access reviews\n- Secure credential storage\n\nSECURITY IMPLICATIONS:\n- Prevention of unauthorized access\n- Protection against credential theft\n- Enforcement of least privilege\n- Audit trail maintenance\n- Compliance with security policies\n\nCOMMON PITFALLS:\n- Weak password requirements\n- Single-factor authentication\n- Over-privileged accounts\n- Lack of access monitoring\n- Poor session management\n\nTOOLS REFERENCE:\n- **Authentication**: Active Directory, LDAP, RADIUS, TACACS+\n- **MFA Solutions**: Google Authenticator, Authy, Duo\n- **Authorization**: AWS IAM, Azure RBAC, Keycloak\n- **Biometrics**: Windows Hello, Apple Touch ID, fingerprint readers\n\nFURTHER READING:\n- \"Authentication and Authorization\" by Mike Chapple\n- NIST SP 800-63 Digital Identity Guidelines\n- \"Role-Based Access Control\" by David Ferraiolo\n\nSTEP-BY-STEP PROCESS:\n\n1. Multi-Factor Authentication Implementation:\n\nAdvanced Authentication System:\n```python\nfrom typing import Dict, List, Any, Optional, Set\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport hashlib\nimport hmac\nimport secrets\nimport time\n\nclass AuthenticationMethod(Enum):\n    PASSWORD = \"password\"\n    TOTP = \"totp\"\n    CERTIFICATE = \"certificate\"\n    BIOMETRIC = \"biometric\"\n    HARDWARE_TOKEN = \"hardware_token\"\n\nclass MFAResult(Enum):\n    SUCCESS = \"success\"\n    FAILURE = \"failure\"\n    PENDING = \"pending\"\n    EXPIRED = \"expired\"\n\n@dataclass\nclass TOTPSecret:\n    secret: str\n    digits: int = 6\n    interval: int = 30\n    \n    def generate_code(self, timestamp: int = None) -> str:\n        \"\"\"Generate TOTP code\"\"\"\n        if timestamp is None:\n            timestamp = int(time.time())\n        \n        # Calculate time window\n        time_window = timestamp // self.interval\n        \n        # Convert to bytes\n        time_bytes = time_window.to_bytes(8, 'big')\n        \n        # HMAC-SHA1\n        key = bytes.fromhex(self.secret)\n        hmac_hash = hmac.new(key, time_bytes, hashlib.sha1).digest()\n        \n        # Dynamic truncation\n        offset = hmac_hash[-1] & 0x0F\n        code = hmac_hash[offset:offset+4]\n        code_int = int.from_bytes(code, 'big') & 0x7FFFFFFF\n        \n        # Generate digits\n        return f\"{code_int % (10 ** self.digits):0{self.digits}d}\"\n    \n    def verify_code(self, code: str, window: int = 1) -> bool:\n        \"\"\"Verify TOTP code with time window tolerance\"\"\"\n        current_time = int(time.time())\n        \n        for i in range(-window, window + 1):\n            check_time = current_time + (i * self.interval)\n            if self.generate_code(check_time) == code:\n                return True\n        \n        return False\n\n@dataclass\nclass UserCredentials:\n    user_id: str\n    password_hash: Optional[str]\n    totp_secret: Optional[TOTPSecret]\n    certificate_fingerprint: Optional[str]\n    biometric_template: Optional[str]\n    hardware_token_serial: Optional[str]\n    mfa_required: bool = False\n    \n    def get_available_methods(self) -> List[AuthenticationMethod]:\n        \"\"\"Get available authentication methods\"\"\"\n        methods = []\n        if self.password_hash:\n            methods.append(AuthenticationMethod.PASSWORD)\n        if self.totp_secret:\n            methods.append(AuthenticationMethod.TOTP)\n        if self.certificate_fingerprint:\n            methods.append(AuthenticationMethod.CERTIFICATE)\n        if self.biometric_template:\n            methods.append(AuthenticationMethod.BIOMETRIC)\n        if self.hardware_token_serial:\n            methods.append(AuthenticationMethod.HARDWARE_TOKEN)\n        return methods\n\nclass MultiFactorAuthenticator:\n    def __init__(self):\n        self.users: Dict[str, UserCredentials] = {}\n        self.active_sessions: Dict[str, Dict] = {}\n        self.challenges: Dict[str, Dict] = {}  # challenge_id -> challenge data\n        self.audit_log: List[Dict] = []\n    \n    def register_user(self, user_id: str, password: str = None, \n                    enable_mfa: bool = False) -> UserCredentials:\n        \"\"\"Register user with authentication credentials\"\"\"\n        # Hash password\n        password_hash = None\n        if password:\n            salt = secrets.token_hex(16)\n            password_hash = hashlib.sha256(f\"{password}{salt}\".encode()).hexdigest()\n            password_hash = f\"{salt}:{password_hash}\"\n        \n        # Generate TOTP secret if MFA enabled\n        totp_secret = None\n        if enable_mfa:\n            secret_hex = secrets.token_hex(20)  # 160 bits\n            totp_secret = TOTPSecret(secret_hex)\n        \n        credentials = UserCredentials(\n            user_id=user_id,\n            password_hash=password_hash,\n            totp_secret=totp_secret,\n            certificate_fingerprint=None,\n            biometric_template=None,\n            hardware_token_serial=None,\n            mfa_required=enable_mfa\n        )\n        \n        self.users[user_id] = credentials\n        return credentials\n    \n    def initiate_authentication(self, user_id: str, method: AuthenticationMethod) -> str:\n        \"\"\"Initiate authentication challenge\"\"\"\n        if user_id not in self.users:\n            raise ValueError(\"User not found\")\n        \n        user = self.users[user_id]\n        \n        if method not in user.get_available_methods():\n            raise ValueError(f\"Authentication method {method.value} not available for user\")\n        \n        challenge_id = secrets.token_hex(32)\n        \n        if method == AuthenticationMethod.TOTP:\n            # For TOTP, challenge is just the request for code\n            self.challenges[challenge_id] = {\n                'user_id': user_id,\n                'method': method.value,\n                'timestamp': datetime.now(),\n                'expires': datetime.now() + timedelta(minutes=5)\n            }\n        \n        return challenge_id\n    \n    def verify_authentication(self, challenge_id: str, response: str) -> MFAResult:\n        \"\"\"Verify authentication response\"\"\"\n        if challenge_id not in self.challenges:\n            return MFAResult.FAILURE\n        \n        challenge = self.challenges[challenge_id]\n        \n        if challenge['expires'] < datetime.now():\n            del self.challenges[challenge_id]\n            return MFAResult.EXPIRED\n        \n        user_id = challenge['user_id']\n        method = AuthenticationMethod(challenge['method'])\n        user = self.users[user_id]\n        \n        success = False\n        \n        if method == AuthenticationMethod.PASSWORD:\n            success = self._verify_password(user, response)\n        elif method == AuthenticationMethod.TOTP:\n            success = user.totp_secret and user.totp_secret.verify_code(response)\n        elif method == AuthenticationMethod.CERTIFICATE:\n            success = self._verify_certificate(user, response)\n        elif method == AuthenticationMethod.BIOMETRIC:\n            success = self._verify_biometric(user, response)\n        elif method == AuthenticationMethod.HARDWARE_TOKEN:\n            success = self._verify_hardware_token(user, response)\n        \n        # Clean up challenge\n        del self.challenges[challenge_id]\n        \n        result = MFAResult.SUCCESS if success else MFAResult.FAILURE\n        \n        self._audit_event(user_id, method.value, result.value)\n        \n        if result == MFAResult.SUCCESS:\n            # Create session\n            session_id = secrets.token_hex(32)\n            self.active_sessions[session_id] = {\n                'user_id': user_id,\n                'created': datetime.now(),\n                'method': method.value,\n                'expires': datetime.now() + timedelta(hours=8)\n            }\n            \n        return result\n    \n    def authenticate_with_mfa(self, user_id: str, password: str, \n                             mfa_code: str = None) -> Optional[str]:\n        \"\"\"Complete MFA authentication flow\"\"\"\n        user = self.users.get(user_id)\n        if not user:\n            return None\n        \n        # Verify password first\n        if not self._verify_password(user, password):\n            self._audit_event(user_id, \"password\", \"failure\")\n            return None\n        \n        # If MFA required, verify second factor\n        if user.mfa_required:\n            if not mfa_code:\n                return None\n            \n            # Try TOTP if available\n            if user.totp_secret and user.totp_secret.verify_code(mfa_code):\n                session_id = secrets.token_hex(32)\n                self.active_sessions[session_id] = {\n                    'user_id': user_id,\n                    'created': datetime.now(),\n                    'method': 'mfa',\n                    'expires': datetime.now() + timedelta(hours=8)\n                }\n                self._audit_event(user_id, \"mfa\", \"success\")\n                return session_id\n            else:\n                self._audit_event(user_id, \"mfa\", \"failure\")\n                return None\n        \n        # Single factor authentication\n        session_id = secrets.token_hex(32)\n        self.active_sessions[session_id] = {\n            'user_id': user_id,\n            'created': datetime.now(),\n            'method': 'password_only',\n            'expires': datetime.now() + timedelta(hours=8)\n        }\n        \n        self._audit_event(user_id, \"password\", \"success\")\n        return session_id\n    \n    def _verify_password(self, user: UserCredentials, password: str) -> bool:\n        \"\"\"Verify password against stored hash\"\"\"\n        if not user.password_hash:\n            return False\n        \n        salt, stored_hash = user.password_hash.split(':')\n        check_hash = hashlib.sha256(f\"{password}{salt}\".encode()).hexdigest()\n        return check_hash == stored_hash\n    \n    def _verify_certificate(self, user: UserCredentials, certificate_data: str) -> bool:\n        \"\"\"Verify client certificate (simplified)\"\"\"\n        # In real implementation, verify certificate chain and signature\n        return user.certificate_fingerprint == hashlib.sha256(certificate_data.encode()).hexdigest()\n    \n    def _verify_biometric(self, user: UserCredentials, biometric_data: str) -> bool:\n        \"\"\"Verify biometric data (simplified)\"\"\"\n        # In real implementation, compare against stored template\n        return user.biometric_template == hashlib.sha256(biometric_data.encode()).hexdigest()\n    \n    def _verify_hardware_token(self, user: UserCredentials, token_response: str) -> bool:\n        \"\"\"Verify hardware token response (simplified)\"\"\"\n        # In real implementation, verify token signature or challenge-response\n        return len(token_response) == 6 and token_response.isdigit()\n    \n    def _audit_event(self, user_id: str, method: str, result: str):\n        \"\"\"Log authentication event\"\"\"\n        event = {\n            'timestamp': datetime.now(),\n            'user_id': user_id,\n            'method': method,\n            'result': result\n        }\n        self.audit_log.append(event)\n\ndef demonstrate_mfa():\n    \"\"\"Demonstrate multi-factor authentication\"\"\"\n    mfa = MultiFactorAuthenticator()\n    \n    # Register users\n    alice_creds = mfa.register_user(\"alice\", \"SecurePass123!\", enable_mfa=True)\n    bob_creds = mfa.register_user(\"bob\", \"Password456!\", enable_mfa=False)\n    \n    # Test MFA authentication\n    alice_session = mfa.authenticate_with_mfa(\"alice\", \"SecurePass123!\", \"123456\")  # Invalid TOTP\n    \n    # Generate valid TOTP for Alice\n    if alice_creds.totp_secret:\n        valid_code = alice_creds.totp_secret.generate_code()\n        alice_session_valid = mfa.authenticate_with_mfa(\"alice\", \"SecurePass123!\", valid_code)\n    else:\n        alice_session_valid = None\n    \n    # Test single-factor for Bob\n    bob_session = mfa.authenticate_with_mfa(\"bob\", \"Password456!\")\n    \n    # Test challenge-based authentication\n    challenge_id = mfa.initiate_authentication(\"alice\", AuthenticationMethod.TOTP)\n    challenge_result = mfa.verify_authentication(challenge_id, valid_code if alice_creds.totp_secret else \"000000\")\n    \n    return {\n        'users_registered': len(mfa.users),\n        'mfa_enabled_users': len([u for u in mfa.users.values() if u.mfa_required]),\n        'authentication_tests': {\n            'alice_mfa_invalid': alice_session is None,\n            'alice_mfa_valid': alice_session_valid is not None,\n            'bob_single_factor': bob_session is not None,\n            'challenge_based': challenge_result.value\n        },\n        'active_sessions': len(mfa.active_sessions),\n        'audit_events': len(mfa.audit_log)\n    }\n```\n\n2. Authorization Policy Engine:\n\nPolicy-Based Authorization System:\n```python\nfrom typing import Dict, List, Any, Optional, Set, Callable\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime, time\n\nclass PolicyEffect(Enum):\n    ALLOW = \"allow\"\n    DENY = \"deny\"\n\nclass PolicyAlgorithm(Enum):\n    FIRST_APPLICABLE = \"first_applicable\"\n    DENY_OVERRIDES = \"deny_overrides\"\n    PERMIT_OVERRIDES = \"permit_overrides\"\n\n@dataclass\nclass PolicyRule:\n    name: str\n    description: str\n    effect: PolicyEffect\n    conditions: List[Callable[[Dict], bool]]\n    \n    def evaluate(self, context: Dict) -> PolicyEffect:\n        \"\"\"Evaluate rule conditions against context\"\"\"\n        for condition in self.conditions:\n            if not condition(context):\n                return PolicyEffect.DENY if self.effect == PolicyEffect.ALLOW else PolicyEffect.ALLOW\n        \n        return self.effect\n\n@dataclass\nclass AuthorizationPolicy:\n    name: str\n    description: str\n    target: Callable[[Dict], bool]  # Function to check if policy applies\n    rules: List[PolicyRule]\n    algorithm: PolicyAlgorithm\n    \n    def evaluate(self, context: Dict) -> PolicyEffect:\n        \"\"\"Evaluate policy against request context\"\"\"\n        # Check if policy applies to this request\n        if not self.target(context):\n            return PolicyEffect.DENY  # Policy doesn't apply\n        \n        results = []\n        \n        # Evaluate rules based on algorithm\n        if self.algorithm == PolicyAlgorithm.FIRST_APPLICABLE:\n            for rule in self.rules:\n                result = rule.evaluate(context)\n                if result != PolicyEffect.DENY:  # First non-deny result\n                    return result\n            return PolicyEffect.DENY\n        \n        elif self.algorithm == PolicyAlgorithm.DENY_OVERRIDES:\n            has_allow = False\n            for rule in self.rules:\n                result = rule.evaluate(context)\n                if result == PolicyEffect.DENY:\n                    return PolicyEffect.DENY\n                if result == PolicyEffect.ALLOW:\n                    has_allow = True\n            return PolicyEffect.ALLOW if has_allow else PolicyEffect.DENY\n        \n        elif self.algorithm == PolicyAlgorithm.PERMIT_OVERRIDES:\n            has_deny = False\n            for rule in self.rules:\n                result = rule.evaluate(context)\n                if result == PolicyEffect.ALLOW:\n                    return PolicyEffect.ALLOW\n                if result == PolicyEffect.DENY:\n                    has_deny = True\n            return PolicyEffect.DENY if has_deny else PolicyEffect.ALLOW\n        \n        return PolicyEffect.DENY\n\nclass PolicyDecisionPoint:\n    def __init__(self):\n        self.policies: List[AuthorizationPolicy] = []\n        self.attribute_providers: Dict[str, Callable[[str], Any]] = {}\n        self.decision_cache: Dict[str, Dict] = {}\n        self.audit_log: List[Dict] = []\n    \n    def add_policy(self, policy: AuthorizationPolicy):\n        \"\"\"Add authorization policy\"\"\"\n        self.policies.append(policy)\n    \n    def register_attribute_provider(self, attribute_name: str, provider: Callable[[str], Any]):\n        \"\"\"Register attribute provider function\"\"\"\n        self.attribute_providers[attribute_name] = provider\n    \n    def evaluate_request(self, subject: str, resource: str, action: str, \n                        environment: Dict = None) -> PolicyEffect:\n        \"\"\"Evaluate access request against policies\"\"\"\n        environment = environment or {}\n        \n        # Build evaluation context\n        context = {\n            'subject': subject,\n            'resource': resource,\n            'action': action,\n            'environment': environment,\n            'timestamp': datetime.now()\n        }\n        \n        # Enrich context with subject attributes\n        context.update(self._get_subject_attributes(subject))\n        \n        # Enrich context with resource attributes\n        context.update(self._get_resource_attributes(resource))\n        \n        # Check cache first\n        cache_key = f\"{subject}:{resource}:{action}:{hash(str(environment))}\"\n        if cache_key in self.decision_cache:\n            cached = self.decision_cache[cache_key]\n            if cached['expires'] > datetime.now():\n                return cached['decision']\n        \n        # Evaluate policies\n        final_decision = PolicyEffect.DENY  # Default deny\n        \n        for policy in self.policies:\n            decision = policy.evaluate(context)\n            if decision == PolicyEffect.ALLOW:\n                final_decision = PolicyEffect.ALLOW\n                break  # First allow wins in this simple implementation\n        \n        # Cache decision\n        self.decision_cache[cache_key] = {\n            'decision': final_decision,\n            'expires': datetime.now() + timedelta(minutes=5)\n        }\n        \n        # Audit\n        self._audit_decision(subject, resource, action, final_decision, context)\n        \n        return final_decision\n    \n    def _get_subject_attributes(self, subject: str) -> Dict[str, Any]:\n        \"\"\"Get subject attributes from providers\"\"\"\n        attributes = {}\n        \n        for attr_name, provider in self.attribute_providers.items():\n            try:\n                attributes[attr_name] = provider(subject)\n            except:\n                attributes[attr_name] = None\n        \n        return attributes\n    \n    def _get_resource_attributes(self, resource: str) -> Dict[str, Any]:\n        \"\"\"Get resource attributes (simplified)\"\"\"\n        # In real implementation, this would query a resource registry\n        return {\n            'resource_type': resource.split(':')[0] if ':' in resource else 'unknown',\n            'sensitivity': 'normal'  # Could be confidential, restricted, etc.\n        }\n    \n    def _audit_decision(self, subject: str, resource: str, action: str, \n                       decision: PolicyEffect, context: Dict):\n        \"\"\"Audit authorization decision\"\"\"\n        audit_entry = {\n            'timestamp': datetime.now(),\n            'subject': subject,\n            'resource': resource,\n            'action': action,\n            'decision': decision.value,\n            'context': context\n        }\n        self.audit_log.append(audit_entry)\n\ndef demonstrate_authorization():\n    \"\"\"Demonstrate policy-based authorization\"\"\"\n    pdp = PolicyDecisionPoint()\n    \n    # Register attribute providers\n    def get_user_department(user_id: str) -> str:\n        departments = {'alice': 'engineering', 'bob': 'hr', 'charlie': 'finance'}\n        return departments.get(user_id, 'unknown')\n    \n    def get_user_clearance(user_id: str) -> str:\n        clearances = {'alice': 'secret', 'bob': 'confidential', 'charlie': 'top_secret'}\n        return clearances.get(user_id, 'unclassified')\n    \n    pdp.register_attribute_provider('department', get_user_department)\n    pdp.register_attribute_provider('clearance', get_user_clearance)\n    \n    # Define policy conditions\n    def business_hours_only(context: Dict) -> bool:\n        current_hour = datetime.now().hour\n        return 9 <= current_hour <= 17\n    \n    def engineering_department_only(context: Dict) -> bool:\n        return context.get('department') == 'engineering'\n    \n    def secret_clearance_required(context: Dict) -> bool:\n        clearance_levels = {'unclassified': 0, 'confidential': 1, 'secret': 2, 'top_secret': 3}\n        user_level = clearance_levels.get(context.get('clearance', 'unclassified'), 0)\n        required_level = clearance_levels.get('secret', 2)\n        return user_level >= required_level\n    \n    # Create policies\n    file_access_policy = AuthorizationPolicy(\n        name=\"file_access_policy\",\n        description=\"Control access to files\",\n        target=lambda ctx: ctx['resource'].startswith('file:'),\n        rules=[\n            PolicyRule(\n                name=\"engineering_file_access\",\n                description=\"Engineers can access engineering files\",\n                effect=PolicyEffect.ALLOW,\n                conditions=[engineering_department_only, business_hours_only]\n            ),\n            PolicyRule(\n                name=\"secret_file_access\",\n                description=\"Secret clearance required for secret files\",\n                effect=PolicyEffect.ALLOW,\n                conditions=[secret_clearance_required]\n            )\n        ],\n        algorithm=PolicyAlgorithm.FIRST_APPLICABLE\n    )\n    \n    pdp.add_policy(file_access_policy)\n    \n    # Test authorization decisions\n    alice_file_access = pdp.evaluate_request('alice', 'file:engineering_docs', 'read')\n    bob_file_access = pdp.evaluate_request('bob', 'file:engineering_docs', 'read')\n    charlie_secret_access = pdp.evaluate_request('charlie', 'file:secret_project', 'read')\n    alice_secret_access = pdp.evaluate_request('alice', 'file:secret_project', 'read')\n    \n    # Test with environment context\n    after_hours_access = pdp.evaluate_request(\n        'alice', \n        'file:engineering_docs', \n        'read', \n        {'time': '18:00'}  # After hours\n    )\n    \n    return {\n        'policies_loaded': len(pdp.policies),\n        'attribute_providers': len(pdp.attribute_providers),\n        'authorization_tests': {\n            'alice_engineering_file': alice_file_access.value,\n            'bob_engineering_file': bob_file_access.value,\n            'charlie_secret_file': charlie_secret_access.value,\n            'alice_secret_file': alice_secret_access.value,\n            'alice_after_hours': after_hours_access.value\n        },\n        'audit_entries': len(pdp.audit_log),\n        'cached_decisions': len(pdp.decision_cache)\n    }\n```",
      "tags": [
        "authentication",
        "authorization",
        "mfa",
        "policies",
        "access-control",
        "cissp"
      ]
    },
    {
      "id": "account-session-management",
      "title": "Account and Session Management",
      "content": "OBJECTIVE: Implement secure account and session management practices to protect user accounts and maintain session security.\n\nACADEMIC BACKGROUND:\nAccount and session management are critical components of identity and access management that ensure the security of user accounts throughout their lifecycle and maintain the integrity of user sessions.\n\n## Account Lifecycle Management\n\n### Account Creation and Provisioning\nThe process of creating and setting up user accounts with appropriate access.\n\n**Provisioning Steps:**\n- **Identity Verification**: Confirm user identity and authorization\n- **Account Creation**: Generate unique account identifiers\n- **Initial Password Assignment**: Set temporary or initial passwords\n- **Role and Group Assignment**: Assign appropriate roles and groups\n- **Entitlement Granting**: Provide necessary access rights\n- **Account Activation**: Enable account for use\n\n**Automated Provisioning:**\n- **Just-in-Time (JIT) Provisioning**: Accounts created when first needed\n- **Workflow-Based Provisioning**: Approval processes for account creation\n- **Self-Service Provisioning**: Users request their own accounts\n- **Bulk Provisioning**: Automated creation of multiple accounts\n\n### Account Maintenance\nOngoing management of active accounts to ensure continued security and compliance.\n\n**Maintenance Activities:**\n- **Password Management**: Regular password changes and resets\n- **Access Reviews**: Periodic validation of access rights\n- **Attribute Updates**: Modification of user information\n- **Role Changes**: Updates to user roles and responsibilities\n- **Entitlement Modifications**: Changes to access permissions\n\n**Account Monitoring:**\n- **Usage Tracking**: Monitor account activity patterns\n- **Anomaly Detection**: Identify unusual account behavior\n- **Compliance Auditing**: Ensure adherence to policies\n- **Security Event Logging**: Record security-relevant events\n\n### Account Termination\nSecure removal of access when accounts are no longer needed.\n\n**Termination Triggers:**\n- **Voluntary Termination**: User-initiated account closure\n- **Involuntary Termination**: Employment termination, policy violation\n- **Account Expiration**: Temporary accounts reaching end of life\n- **Security Incident**: Compromised account requiring shutdown\n\n**Termination Process:**\n- **Immediate Disable**: Prevent further access\n- **Access Revocation**: Remove all entitlements\n- **Data Archival**: Preserve necessary account data\n- **Audit Logging**: Record termination activities\n- **Resource Cleanup**: Remove associated resources\n\n## Session Management\n\n### Session Creation and Establishment\nThe process of establishing authenticated sessions for user access.\n\n**Session Components:**\n- **Session Identifier**: Unique session token\n- **User Context**: Associated user identity and attributes\n- **Session Attributes**: Session-specific properties\n- **Security Context**: Authentication and authorization state\n- **Timeout Settings**: Session duration limits\n\n**Session Types:**\n- **Interactive Sessions**: Direct user interaction\n- **API Sessions**: Programmatic access sessions\n- **Service Sessions**: System-to-system authentication\n- **Federated Sessions**: Cross-domain authentication\n\n### Session Security\nProtecting sessions from various security threats.\n\n**Session Threats:**\n- **Session Hijacking**: Unauthorized session takeover\n- **Session Fixation**: Forced use of known session IDs\n- **Session Poisoning**: Manipulation of session data\n- **Cross-Site Request Forgery (CSRF)**: Forced actions in authenticated sessions\n- **Session Riding**: Exploitation of active sessions\n\n**Session Protection Mechanisms:**\n- **Secure Session IDs**: Cryptographically strong, unpredictable identifiers\n- **Session Encryption**: Protect session data in transit\n- **Session Timeouts**: Automatic session termination\n- **Session Invalidation**: Proper logout and cleanup\n- **Origin Validation**: Check request source validity\n\n### Session Monitoring and Control\nOngoing monitoring and management of active sessions.\n\n**Session Monitoring:**\n- **Concurrent Session Limits**: Restrict simultaneous sessions\n- **Geographic Restrictions**: Limit access by location\n- **Device Restrictions**: Control device-based access\n- **Time-Based Restrictions**: Limit access by time of day\n- **Activity Monitoring**: Track session activity patterns\n\n**Session Control:**\n- **Forced Logout**: Administrative session termination\n- **Session Transfer**: Moving sessions between devices\n- **Session Persistence**: Maintaining sessions across interruptions\n- **Session Clustering**: Distributing sessions across servers\n\nWHAT TO LOOK FOR:\n- Secure account provisioning processes\n- Proper session timeout settings\n- Strong session identifier generation\n- Regular account reviews and audits\n- Secure account termination procedures\n- Session activity monitoring\n\nSECURITY IMPLICATIONS:\n- Prevention of unauthorized account access\n- Protection against session-based attacks\n- Compliance with account management policies\n- Audit trail maintenance for accountability\n- Reduction of orphaned accounts and entitlements\n\nCOMMON PITFALLS:\n- Weak session identifiers\n- Excessive session timeouts\n- Lack of account monitoring\n- Improper account termination\n- Insufficient audit logging\n- Poor session cleanup\n\nTOOLS REFERENCE:\n- **Account Management**: Active Directory, LDAP, SCIM\n- **Session Management**: Redis, Memcached, JWT\n- **Monitoring**: SIEM systems, session tracking tools\n- **Provisioning**: Okta Lifecycle Management, SailPoint\n\nFURTHER READING:\n- \"Session Management\" by Mike Chapple\n- OWASP Session Management Cheat Sheet\n- NIST SP 800-63 Session Management Guidelines\n\nSTEP-BY-STEP PROCESS:\n\n1. Account Lifecycle Management System:\n\nComprehensive Account Management:\n```python\nfrom typing import Dict, List, Any, Optional, Set\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport secrets\nimport hashlib\n\nclass AccountStatus(Enum):\n    PROVISIONING = \"provisioning\"\n    ACTIVE = \"active\"\n    SUSPENDED = \"suspended\"\n    TERMINATED = \"terminated\"\n    LOCKED = \"locked\"\n\nclass AccountEvent(Enum):\n    CREATED = \"created\"\n    ACTIVATED = \"activated\"\n    SUSPENDED = \"suspended\"\n    TERMINATED = \"terminated\"\n    PASSWORD_CHANGED = \"password_changed\"\n    ROLE_CHANGED = \"role_changed\"\n    LOGIN_SUCCESS = \"login_success\"\n    LOGIN_FAILURE = \"login_failure\"\n    LOCKED = \"locked\"\n    UNLOCKED = \"unlocked\"\n\n@dataclass\nclass Account:\n    account_id: str\n    username: str\n    email: str\n    status: AccountStatus\n    created_date: datetime\n    last_login: Optional[datetime]\n    password_changed_date: Optional[datetime]\n    roles: Set[str]\n    groups: Set[str]\n    attributes: Dict[str, Any]\n    entitlements: Set[str]\n    failed_login_attempts: int\n    locked_until: Optional[datetime]\n    \n    def is_active(self) -> bool:\n        return self.status == AccountStatus.ACTIVE\n    \n    def is_locked(self) -> bool:\n        return self.locked_until and self.locked_until > datetime.now()\n    \n    def record_login_attempt(self, success: bool):\n        if success:\n            self.failed_login_attempts = 0\n            self.locked_until = None\n            self.last_login = datetime.now()\n        else:\n            self.failed_login_attempts += 1\n            if self.failed_login_attempts >= 5:\n                self.locked_until = datetime.now() + timedelta(minutes=30)\n\nclass AccountManager:\n    def __init__(self):\n        self.accounts: Dict[str, Account] = {}\n        self.account_history: Dict[str, List[Dict]] = {}\n        self.password_policy = {\n            'min_length': 8,\n            'require_uppercase': True,\n            'require_lowercase': True,\n            'require_digits': True,\n            'require_special': True,\n            'max_age_days': 90\n        }\n        self.audit_log: List[Dict] = []\n    \n    def provision_account(self, username: str, email: str, \n                         initial_roles: List[str] = None, \n                         attributes: Dict = None) -> Account:\n        \"\"\"Provision a new user account\"\"\"\n        account_id = secrets.token_hex(16)\n        \n        account = Account(\n            account_id=account_id,\n            username=username,\n            email=email,\n            status=AccountStatus.PROVISIONING,\n            created_date=datetime.now(),\n            last_login=None,\n            password_changed_date=None,\n            roles=set(initial_roles or []),\n            groups=set(),\n            attributes=attributes or {},\n            entitlements=set(),\n            failed_login_attempts=0,\n            locked_until=None\n        )\n        \n        self.accounts[account_id] = account\n        self.account_history[account_id] = []\n        \n        self._log_event(account_id, AccountEvent.CREATED, {\"username\": username, \"email\": email})\n        \n        return account\n    \n    def activate_account(self, account_id: str, temp_password: str) -> bool:\n        \"\"\"Activate a provisioned account\"\"\"\n        if account_id not in self.accounts:\n            return False\n        \n        account = self.accounts[account_id]\n        if account.status != AccountStatus.PROVISIONING:\n            return False\n        \n        # Set temporary password\n        self._set_password(account, temp_password)\n        \n        # Activate account\n        account.status = AccountStatus.ACTIVE\n        \n        self._log_event(account_id, AccountEvent.ACTIVATED, {})\n        return True\n    \n    def authenticate_account(self, username: str, password: str) -> Optional[str]:\n        \"\"\"Authenticate account credentials\"\"\"\n        # Find account by username\n        account = None\n        for acc in self.accounts.values():\n            if acc.username == username:\n                account = acc\n                break\n        \n        if not account or not account.is_active():\n            return None\n        \n        if account.is_locked():\n            self._log_event(account.account_id, AccountEvent.LOGIN_FAILURE, {\"reason\": \"account_locked\"})\n            return None\n        \n        # Verify password\n        if self._verify_password(account, password):\n            account.record_login_attempt(True)\n            self._log_event(account.account_id, AccountEvent.LOGIN_SUCCESS, {})\n            return account.account_id\n        else:\n            account.record_login_attempt(False)\n            self._log_event(account.account_id, AccountEvent.LOGIN_FAILURE, {\"reason\": \"invalid_password\"})\n            return None\n    \n    def change_password(self, account_id: str, old_password: str, new_password: str) -> bool:\n        \"\"\"Change account password\"\"\"\n        if account_id not in self.accounts:\n            return False\n        \n        account = self.accounts[account_id]\n        \n        # Verify old password\n        if not self._verify_password(account, old_password):\n            return False\n        \n        # Validate new password\n        if not self._validate_password_policy(new_password):\n            return False\n        \n        # Set new password\n        self._set_password(account, new_password)\n        account.password_changed_date = datetime.now()\n        \n        self._log_event(account_id, AccountEvent.PASSWORD_CHANGED, {})\n        return True\n    \n    def suspend_account(self, account_id: str, reason: str) -> bool:\n        \"\"\"Suspend an account\"\"\"\n        if account_id not in self.accounts:\n            return False\n        \n        account = self.accounts[account_id]\n        account.status = AccountStatus.SUSPENDED\n        \n        self._log_event(account_id, AccountEvent.SUSPENDED, {\"reason\": reason})\n        return True\n    \n    def terminate_account(self, account_id: str, reason: str) -> bool:\n        \"\"\"Terminate an account\"\"\"\n        if account_id not in self.accounts:\n            return False\n        \n        account = self.accounts[account_id]\n        account.status = AccountStatus.TERMINATED\n        \n        # Revoke all entitlements\n        account.entitlements.clear()\n        account.roles.clear()\n        account.groups.clear()\n        \n        self._log_event(account_id, AccountEvent.TERMINATED, {\"reason\": reason})\n        return True\n    \n    def review_account_access(self, account_id: str) -> Dict[str, Any]:\n        \"\"\"Review account access and entitlements\"\"\"\n        if account_id not in self.accounts:\n            return {\"error\": \"Account not found\"}\n        \n        account = self.accounts[account_id]\n        \n        # Check password age\n        password_age_days = None\n        if account.password_changed_date:\n            password_age_days = (datetime.now() - account.password_changed_date).days\n        \n        # Analyze entitlements\n        entitlements_analysis = {\n            'total_entitlements': len(account.entitlements),\n            'high_privilege_count': len([e for e in account.entitlements if 'admin' in e.lower()]),\n            'role_count': len(account.roles)\n        }\n        \n        # Check for dormant account\n        days_since_login = None\n        if account.last_login:\n            days_since_login = (datetime.now() - account.last_login).days\n        \n        return {\n            'account_id': account_id,\n            'status': account.status.value,\n            'password_age_days': password_age_days,\n            'days_since_login': days_since_login,\n            'entitlements_analysis': entitlements_analysis,\n            'recommendations': self._generate_access_recommendations(account)\n        }\n    \n    def _set_password(self, account: Account, password: str):\n        \"\"\"Set account password with proper hashing\"\"\"\n        salt = secrets.token_hex(16)\n        hash_input = f\"{password}{salt}\"\n        password_hash = hashlib.sha256(hash_input.encode()).hexdigest()\n        account.attributes['password_hash'] = f\"{salt}:{password_hash}\"\n        account.password_changed_date = datetime.now()\n    \n    def _verify_password(self, account: Account, password: str) -> bool:\n        \"\"\"Verify password against stored hash\"\"\"\n        stored = account.attributes.get('password_hash')\n        if not stored:\n            return False\n        \n        salt, hash_value = stored.split(':')\n        check_hash = hashlib.sha256(f\"{password}{salt}\".encode()).hexdigest()\n        return check_hash == hash_value\n    \n    def _validate_password_policy(self, password: str) -> bool:\n        \"\"\"Validate password against policy\"\"\"\n        policy = self.password_policy\n        \n        if len(password) < policy['min_length']:\n            return False\n        \n        if policy['require_uppercase'] and not any(c.isupper() for c in password):\n            return False\n        \n        if policy['require_lowercase'] and not any(c.islower() for c in password):\n            return False\n        \n        if policy['require_digits'] and not any(c.isdigit() for c in password):\n            return False\n        \n        if policy['require_special'] and not any(not c.isalnum() for c in password):\n            return False\n        \n        return True\n    \n    def _generate_access_recommendations(self, account: Account) -> List[str]:\n        \"\"\"Generate access review recommendations\"\"\"\n        recommendations = []\n        \n        # Password age check\n        if account.password_changed_date:\n            age = (datetime.now() - account.password_changed_date).days\n            if age > self.password_policy['max_age_days']:\n                recommendations.append(\"Password exceeds maximum age - requires change\")\n        \n        # Dormant account check\n        if account.last_login:\n            days = (datetime.now() - account.last_login).days\n            if days > 90:\n                recommendations.append(\"Account appears dormant - consider suspension\")\n        \n        # High privilege check\n        high_privilege = [e for e in account.entitlements if 'admin' in e.lower()]\n        if len(high_privilege) > 3:\n            recommendations.append(\"Account has many high-privilege entitlements - review necessity\")\n        \n        return recommendations\n    \n    def _log_event(self, account_id: str, event: AccountEvent, details: Dict):\n        \"\"\"Log account management event\"\"\"\n        log_entry = {\n            'timestamp': datetime.now(),\n            'account_id': account_id,\n            'event': event.value,\n            'details': details\n        }\n        \n        self.audit_log.append(log_entry)\n        \n        # Add to account history\n        if account_id not in self.account_history:\n            self.account_history[account_id] = []\n        self.account_history[account_id].append(log_entry)\n\ndef demonstrate_account_management():\n    \"\"\"Demonstrate account lifecycle management\"\"\"\n    am = AccountManager()\n    \n    # Provision account\n    account = am.provision_account(\"john.doe\", \"john.doe@company.com\", [\"employee\"])\n    \n    # Activate account\n    am.activate_account(account.account_id, \"TempPass123!\")\n    \n    # Authenticate\n    auth_result = am.authenticate_account(\"john.doe\", \"TempPass123!\")\n    \n    # Change password\n    password_changed = am.change_password(account.account_id, \"TempPass123!\", \"NewSecurePass123!\")\n    \n    # Review access\n    access_review = am.review_account_access(account.account_id)\n    \n    # Terminate account\n    am.terminate_account(account.account_id, \"Employee departure\")\n    \n    return {\n        'account_provisioned': account.account_id,\n        'account_activated': True,\n        'authentication_success': auth_result is not None,\n        'password_changed': password_changed,\n        'access_review_completed': True,\n        'account_terminated': True,\n        'audit_events': len(am.audit_log)\n    }\n```\n\n2. Session Security Management:\n\nAdvanced Session Management System:\n```python\nfrom typing import Dict, List, Any, Optional, Set\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport secrets\nimport hashlib\nimport hmac\n\nclass SessionStatus(Enum):\n    ACTIVE = \"active\"\n    EXPIRED = \"expired\"\n    INVALIDATED = \"invalidated\"\n    SUSPENDED = \"suspended\"\n\nclass SessionEvent(Enum):\n    CREATED = \"created\"\n    EXTENDED = \"extended\"\n    ACCESSED = \"accessed\"\n    EXPIRED = \"expired\"\n    INVALIDATED = \"invalidated\"\n    HIJACKED = \"hijacked\"\n\n@dataclass\nclass Session:\n    session_id: str\n    account_id: str\n    created_time: datetime\n    last_accessed: datetime\n    expires_at: datetime\n    status: SessionStatus\n    ip_address: str\n    user_agent: str\n    attributes: Dict[str, Any]\n    access_count: int\n    \n    def is_active(self) -> bool:\n        return (self.status == SessionStatus.ACTIVE and \n                self.expires_at > datetime.now())\n    \n    def extend(self, new_expiry: datetime):\n        \"\"\"Extend session expiry\"\"\"\n        self.expires_at = new_expiry\n        self.last_accessed = datetime.now()\n    \n    def record_access(self):\n        \"\"\"Record session access\"\"\"\n        self.last_accessed = datetime.now()\n        self.access_count += 1\n    \n    def invalidate(self):\n        \"\"\"Invalidate the session\"\"\"\n        self.status = SessionStatus.INVALIDATED\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions: Dict[str, Session] = {}\n        self.session_store: Dict[str, Dict] = {}  # Persistent storage\n        self.session_config = {\n            'max_lifetime': timedelta(hours=8),\n            'idle_timeout': timedelta(minutes=30),\n            'absolute_timeout': timedelta(hours=24),\n            'max_concurrent_sessions': 3,\n            'regenerate_on_auth': True\n        }\n        self.audit_log: List[Dict] = []\n        self.session_tokens: Set[str] = set()  # For token validation\n    \n    def create_session(self, account_id: str, ip_address: str = \"127.0.0.1\", \n                      user_agent: str = \"Unknown\", attributes: Dict = None) -> Session:\n        \"\"\"Create a new session for account\"\"\"\n        # Check concurrent session limit\n        active_sessions = [s for s in self.sessions.values() \n                          if s.account_id == account_id and s.is_active()]\n        \n        if len(active_sessions) >= self.session_config['max_concurrent_sessions']:\n            # Terminate oldest session\n            oldest = min(active_sessions, key=lambda s: s.created_time)\n            self.invalidate_session(oldest.session_id, \"concurrent_limit_exceeded\")\n        \n        # Generate secure session ID\n        session_id = self._generate_secure_session_id()\n        \n        now = datetime.now()\n        session = Session(\n            session_id=session_id,\n            account_id=account_id,\n            created_time=now,\n            last_accessed=now,\n            expires_at=now + self.session_config['max_lifetime'],\n            status=SessionStatus.ACTIVE,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            attributes=attributes or {},\n            access_count=0\n        )\n        \n        self.sessions[session_id] = session\n        self.session_tokens.add(session_id)\n        \n        self._log_event(session_id, SessionEvent.CREATED, \n                       {\"account_id\": account_id, \"ip_address\": ip_address})\n        \n        return session\n    \n    def validate_session(self, session_id: str, ip_address: str = None, \n                        user_agent: str = None) -> Optional[Session]:\n        \"\"\"Validate session and check for security issues\"\"\"\n        if session_id not in self.sessions:\n            return None\n        \n        session = self.sessions[session_id]\n        \n        # Check if session is active\n        if not session.is_active():\n            return None\n        \n        # Check IP address consistency (optional security feature)\n        if ip_address and session.ip_address != ip_address:\n            # Log potential session hijacking\n            self._log_event(session_id, SessionEvent.HIJACKED, \n                           {\"original_ip\": session.ip_address, \"new_ip\": ip_address})\n            session.invalidate()\n            return None\n        \n        # Check user agent consistency (optional)\n        if user_agent and session.user_agent != user_agent:\n            self._log_event(session_id, SessionEvent.ACCESSED, \n                           {\"user_agent_changed\": True})\n        \n        # Check for idle timeout\n        idle_time = datetime.now() - session.last_accessed\n        if idle_time > self.session_config['idle_timeout']:\n            session.invalidate()\n            self._log_event(session_id, SessionEvent.EXPIRED, {\"reason\": \"idle_timeout\"})\n            return None\n        \n        # Check for absolute timeout\n        session_age = datetime.now() - session.created_time\n        if session_age > self.session_config['absolute_timeout']:\n            session.invalidate()\n            self._log_event(session_id, SessionEvent.EXPIRED, {\"reason\": \"absolute_timeout\"})\n            return None\n        \n        # Update session access\n        session.record_access()\n        \n        # Extend session if close to expiry\n        time_to_expiry = session.expires_at - datetime.now()\n        if time_to_expiry < timedelta(minutes=5):\n            session.extend(datetime.now() + self.session_config['max_lifetime'])\n            self._log_event(session_id, SessionEvent.EXTENDED, {})\n        \n        return session\n    \n    def invalidate_session(self, session_id: str, reason: str = \"user_logout\") -> bool:\n        \"\"\"Invalidate a session\"\"\"\n        if session_id not in self.sessions:\n            return False\n        \n        session = self.sessions[session_id]\n        session.invalidate()\n        \n        self._log_event(session_id, SessionEvent.INVALIDATED, {\"reason\": reason})\n        return True\n    \n    def invalidate_all_user_sessions(self, account_id: str, reason: str = \"admin_action\") -> int:\n        \"\"\"Invalidate all sessions for a user\"\"\"\n        invalidated_count = 0\n        \n        for session in self.sessions.values():\n            if session.account_id == account_id and session.is_active():\n                session.invalidate()\n                self._log_event(session.session_id, SessionEvent.INVALIDATED, \n                               {\"reason\": reason, \"bulk\": True})\n                invalidated_count += 1\n        \n        return invalidated_count\n    \n    def regenerate_session_id(self, old_session_id: str) -> Optional[str]:\n        \"\"\"Regenerate session ID for security\"\"\"\n        if old_session_id not in self.sessions:\n            return None\n        \n        old_session = self.sessions[old_session_id]\n        if not old_session.is_active():\n            return None\n        \n        # Create new session with same attributes\n        new_session = self.create_session(\n            old_session.account_id,\n            old_session.ip_address,\n            old_session.user_agent,\n            old_session.attributes\n        )\n        \n        # Copy additional attributes\n        new_session.access_count = old_session.access_count\n        \n        # Invalidate old session\n        old_session.invalidate()\n        self._log_event(old_session_id, SessionEvent.INVALIDATED, {\"reason\": \"regenerated\"})\n        \n        return new_session.session_id\n    \n    def get_session_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get session management statistics\"\"\"\n        now = datetime.now()\n        \n        active_sessions = [s for s in self.sessions.values() if s.is_active()]\n        expired_sessions = [s for s in self.sessions.values() if s.status == SessionStatus.EXPIRED]\n        \n        # Calculate average session duration\n        durations = []\n        for session in self.sessions.values():\n            if session.last_accessed:\n                duration = session.last_accessed - session.created_time\n                durations.append(duration.total_seconds())\n        \n        avg_duration = sum(durations) / len(durations) if durations else 0\n        \n        return {\n            'total_sessions': len(self.sessions),\n            'active_sessions': len(active_sessions),\n            'expired_sessions': len(expired_sessions),\n            'average_session_duration_seconds': avg_duration,\n            'sessions_by_account': self._count_sessions_by_account()\n        }\n    \n    def cleanup_expired_sessions(self) -> int:\n        \"\"\"Clean up expired sessions\"\"\"\n        cleaned_count = 0\n        now = datetime.now()\n        \n        for session in list(self.sessions.values()):\n            if session.expires_at < now and session.status == SessionStatus.ACTIVE:\n                session.status = SessionStatus.EXPIRED\n                self._log_event(session.session_id, SessionEvent.EXPIRED, {\"reason\": \"cleanup\"})\n                cleaned_count += 1\n        \n        return cleaned_count\n    \n    def _generate_secure_session_id(self) -> str:\n        \"\"\"Generate cryptographically secure session ID\"\"\"\n        # Use multiple entropy sources\n        entropy = secrets.token_hex(32) + str(datetime.now().timestamp())\n        return hashlib.sha256(entropy.encode()).hexdigest()\n    \n    def _count_sessions_by_account(self) -> Dict[str, int]:\n        \"\"\"Count active sessions per account\"\"\"\n        counts = {}\n        for session in self.sessions.values():\n            if session.is_active():\n                counts[session.account_id] = counts.get(session.account_id, 0) + 1\n        return counts\n    \n    def _log_event(self, session_id: str, event: SessionEvent, details: Dict):\n        \"\"\"Log session management event\"\"\"\n        log_entry = {\n            'timestamp': datetime.now(),\n            'session_id': session_id,\n            'event': event.value,\n            'details': details\n        }\n        self.audit_log.append(log_entry)\n\ndef demonstrate_session_management():\n    \"\"\"Demonstrate advanced session management\"\"\"\n    sm = SessionManager()\n    \n    # Create sessions\n    session1 = sm.create_session(\"user001\", \"192.168.1.100\", \"Chrome/91.0\")\n    session2 = sm.create_session(\"user001\", \"192.168.1.100\", \"Chrome/91.0\")  # Second session\n    session3 = sm.create_session(\"user002\", \"10.0.0.50\", \"Firefox/89.0\")\n    \n    # Validate sessions\n    valid_session1 = sm.validate_session(session1.session_id, \"192.168.1.100\", \"Chrome/91.0\")\n    valid_session2 = sm.validate_session(session2.session_id)\n    \n    # Test session regeneration\n    new_session_id = sm.regenerate_session_id(session1.session_id)\n    \n    # Invalidate all user sessions\n    invalidated_count = sm.invalidate_all_user_sessions(\"user001\", \"password_change\")\n    \n    # Get statistics\n    stats = sm.get_session_statistics()\n    \n    # Cleanup expired sessions\n    cleaned = sm.cleanup_expired_sessions()\n    \n    return {\n        'sessions_created': len(sm.sessions),\n        'session_validation': {\n            'session1_valid': valid_session1 is not None,\n            'session2_valid': valid_session2 is not None\n        },\n        'session_regenerated': new_session_id is not None,\n        'bulk_invalidation': invalidated_count,\n        'session_statistics': stats,\n        'expired_sessions_cleaned': cleaned,\n        'audit_events': len(sm.audit_log)\n    }\n```",
      "tags": [
        "account-management",
        "session-management",
        "lifecycle",
        "security",
        "audit",
        "cissp"
      ]
    },
    {
      "id": "cissp-domain-5-quiz",
      "title": "CISSP Domain 5: Identity and Access Management Quiz",
      "content": "Quiz content loaded from cissp/cissp-domain-5-quiz.txt",
      "tags": [
        "quiz",
        "cissp",
        "identity-access-management"
      ]
    }
  ]
}
