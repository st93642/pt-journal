{
  "id": "practical_oauth",
  "title": "Practical OAuth/OIDC Abuse",
  "description": "Practical OAuth/OIDC Abuse tutorial phase covering OAuth 2.0 and OpenID Connect security testing",
  "type": "tutorial",
  "steps": [
    {
      "id": "practical-oauth-oidc-abuse",
      "title": "Practical OAuth/OIDC Abuse",
      "content": "OBJECTIVE: Test modern authentication protocols (OAuth 2.0, OpenID Connect) for common misconfigurations including redirect URI validation, token handling, scope abuse, and session management issues.\n\nACADEMIC BACKGROUND:\nOAuth 2.0 enables secure delegated access without sharing credentials, while OpenID Connect adds identity verification. According to RFC 6819 (OAuth 2.0 Threat Model) and OWASP, common vulnerabilities include:\n- Open redirects via redirect_uri parameter\n- Missing or weak state parameter (CSRF)\n- Token leakage through referrer headers\n- Insufficient scope validation\n- Missing PKCE (Proof Key for Code Exchange) for mobile apps\n\nMITRE ATT&CK mappings:\n- T1078: Valid Accounts (stolen tokens)\n- T1550: Use Alternate Authentication Material (OAuth tokens)\n- T1539: Steal Web Session Cookie\n\nSTEP-BY-STEP PROCESS:\n\n1. OAUTH 2.0 & OIDC FUNDAMENTALS:\n\n   Key Terminology:\n   - Resource Owner: User who owns the data\n   - Client: Application requesting access\n   - Authorization Server: Issues tokens (Auth0, Okta, Azure AD)\n   - Resource Server: API that requires access token\n   - Scope: Permissions requested (read, write, admin)\n\n   OAuth 2.0 Flows:\n   \n   a) Authorization Code Flow (most secure):\n      1. Client redirects user to Authorization Server with client_id, redirect_uri, scope, state\n      2. User authenticates and consents\n      3. Authorization Server redirects back with authorization code\n      4. Client exchanges code for access token (+ refresh token)\n      5. Client uses access token to call Resource Server\n   \n   b) Implicit Flow (deprecated, less secure):\n      - Access token returned directly in URL fragment\n      - No client authentication\n      - Vulnerable to token leakage\n   \n   c) Client Credentials Flow:\n      - Service-to-service authentication\n      - No user involvement\n      - Client authenticates with client_id and client_secret\n\n   OpenID Connect Additions:\n   - ID Token: JWT containing user identity claims (sub, name, email)\n   - UserInfo Endpoint: Returns additional user claims\n   - Standard scopes: openid, profile, email\n\n2. CRITICAL PARAMETERS AND THEIR SECURITY IMPLICATIONS:\n\n   redirect_uri:\n   - MUST be validated against pre-registered list\n   - Common attack: Manipulate to attacker-controlled domain\n   - Exploitation: Steal authorization code or access token\n   \n   state:\n   - Random value to prevent CSRF\n   - Must be unique per request and validated on callback\n   - Missing state allows attacker to initiate login on victim's behalf\n   \n   nonce:\n   - Used in OIDC to bind ID token to client request\n   - Prevents token replay attacks\n   - Should be random and validated\n   \n   scope:\n   - Defines requested permissions\n   - Should be minimal (least privilege)\n   - Dangerous scopes: offline_access (refresh tokens), admin, write\n   \n   response_type:\n   - Determines which flow is used\n   - code: Authorization code flow (secure)\n   - token: Implicit flow (vulnerable to leakage)\n   - id_token: OIDC implicit flow\n   \n   PKCE (Proof Key for Code Exchange):\n   - code_challenge: SHA-256 hash of random code_verifier\n   - code_verifier: Sent during token exchange\n   - Prevents authorization code interception\n   - REQUIRED for public clients (mobile, SPA)\n\n3. ENUMERATION AND RECONNAISSANCE:\n\n   Discovery:\n   ```bash\n   # OIDC Discovery Document\n   curl https://idp.example.com/.well-known/openid-configuration | jq\n   \n   # Key fields:\n   # - issuer: Identity provider identifier\n   # - authorization_endpoint: Where to send auth requests\n   # - token_endpoint: Where to exchange code for token\n   # - jwks_uri: Public keys for token verification\n   # - scopes_supported: Available scopes\n   - grant_types_supported: Supported OAuth flows\n   ```\n\n   Manual Testing Setup:\n   ```bash\n   # Install Burp Suite or OWASP ZAP\n   # Configure browser to use proxy (localhost:8080)\n   # Enable SSL interception with proxy CA certificate\n   \n   # Perform baseline login and capture traffic:\n   # 1. Authorization request\n   # 2. User authentication\n   # 3. Authorization response (callback)\n   # 4. Token exchange\n   # 5. API requests with access token\n   ```\n\n4. COMMON VULNERABILITIES AND TESTING:\n\n   a) Open Redirect via redirect_uri:\n      \n      Attack Scenario:\n      ```\n      Original:\n      https://idp.example.com/authorize?\n        client_id=app123&\n        redirect_uri=https://app.example.com/callback&\n        response_type=code&state=xyz\n      \n      Manipulated:\n      https://idp.example.com/authorize?\n        client_id=app123&\n        redirect_uri=https://attacker.com/callback&\n        response_type=code&state=xyz\n      ```\n      \n      Expected Behavior: Authorization server rejects non-registered redirect_uri\n      Vulnerable Behavior: Authorization server accepts attacker URI, sends code to attacker\n      \n      Testing:\n      ```bash\n      # Try subdomain variations\n      redirect_uri=https://evil.app.example.com/callback\n      \n      # Try path traversal\n      redirect_uri=https://app.example.com/callback/../../../attacker.com\n      \n      # Try open redirect chains\n      redirect_uri=https://app.example.com/redirect?url=https://attacker.com\n      ```\n\n   b) Missing or Weak state Parameter:\n      \n      Attack: CSRF on OAuth login\n      1. Attacker initiates OAuth flow and gets authorization URL with state=abc\n      2. Victim clicks attacker's link (without completing auth)\n      3. Victim ends up logged in as attacker\n      \n      Testing:\n      ```bash\n      # Remove state parameter\n      https://idp.example.com/authorize?client_id=app123&redirect_uri=...&response_type=code\n      \n      # Replay old state value\n      # Use same state across multiple requests\n      \n      # Check if state is validated on callback\n      # Modify state in callback URL\n      ```\n\n   c) Token Leakage:\n      \n      Implicit Flow Token in URL:\n      ```\n      https://app.example.com/callback#access_token=SECRET&token_type=Bearer\n      ```\n      - Tokens in URL fragments are visible in browser history\n      - Can be leaked via Referer header if app navigates\n      - Vulnerable to XSS attacks\n      \n      Testing:\n      - Check if app uses implicit flow (response_type=token)\n      - Inspect browser history for access tokens\n      - Check if tokens appear in server logs (they shouldn't)\n\n   d) Insufficient Scope Validation:\n      \n      Attack: Request excessive scopes\n      ```bash\n      # Normal request\n      scope=openid profile email\n      \n      # Escalation attempt\n      scope=openid profile email admin offline_access\n      ```\n      \n      Testing:\n      - Request additional scopes not normally available\n      - Check if consent screen shows all scopes\n      - Verify Resource Server validates token scopes\n      - Test scope downgrade (remove expected scopes)\n\n   e) Missing PKCE (Public Clients):\n      \n      Attack: Authorization code interception\n      - Attacker intercepts code from mobile app\n      - Exchanges code for access token\n      \n      Testing:\n      ```bash\n      # Check if PKCE is used\n      # Authorization request should include:\n      code_challenge=BASE64URL(SHA256(random_string))\n      code_challenge_method=S256\n      \n      # Token exchange should include:\n      code_verifier=random_string\n      \n      # Test if server enforces PKCE\n      # Try omitting code_challenge or using mismatched verifier\n      ```\n\n5. ID TOKEN AND ACCESS TOKEN ANALYSIS:\n\n   JWT Structure:\n   - Header: Algorithm, token type\n   - Payload: Claims (sub, iss, aud, exp, iat, nonce)\n   - Signature: Cryptographic signature\n\n   Analysis Tools:\n   ```bash\n   # Install JWT tools\n   pip install pyjwt jwt_tool\n   \n   # Decode ID token\n   python3 jwt_tool.py id_token.jwt\n   \n   # Verify signature\n   python3 jwt_tool.py id_token.jwt -V -pk public_key.pem\n   ```\n\n   Key Checks:\n   ```bash\n   # Validate issuer (iss claim)\n   # Should match expected identity provider\n   \n   # Validate audience (aud claim)\n   # Should match your application's client_id\n   \n   # Check expiration (exp claim)\n   # Tokens should have short lifetimes (minutes to hours)\n   \n   # Verify algorithm (alg in header)\n   # Should be RS256 or ES256, NOT HS256 for ID tokens\n   # NEVER \"none\" algorithm\n   ```\n\n   Common JWT Vulnerabilities:\n   - Algorithm confusion (RS256 â†’ HS256)\n   - None algorithm accepted\n   - Weak signing key\n   - Missing expiration validation\n   - Audience not validated\n\n6. SESSION MANAGEMENT TESTING:\n\n   Cookie Security:\n   ```bash\n   # Check session cookie attributes\n   Set-Cookie: session=abc; Secure; HttpOnly; SameSite=Strict\n   \n   # Required flags:\n   # - Secure: Only sent over HTTPS\n   # - HttpOnly: Not accessible via JavaScript (XSS protection)\n   - SameSite: CSRF protection\n   ```\n\n   Logout Testing:\n   ```bash\n   # Capture access token and refresh token\n   # Trigger logout\n   # Attempt to use tokens after logout\n   # Expected: Tokens should be invalidated\n   \n   # Test single logout vs. global logout\n   # Check if logout revokes refresh tokens\n   # Verify logout redirects are validated\n   ```\n\n7. LAB SCENARIO - OAuth Misconfiguration Testing:\n\n   Setup Lab Environment:\n   ```bash\n   # Use OAuth testing playground\n   # Option 1: https://oauth.com/playground/\n   # Option 2: Deploy local Keycloak\n   docker run -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:latest start-dev\n   \n   # Configure test client with intentional misconfigurations\n   # - Allow http:// redirect URIs\n   # - Enable implicit flow\n   # - Disable PKCE requirement\n   ```\n\n   Testing Workflow:\n   ```bash\n   # 1. Baseline OAuth flow\n   # Capture complete auth code flow in Burp/ZAP\n   \n   # 2. Test redirect_uri validation\n   # Modify redirect_uri parameter to attacker.com\n   # Try subdomain variations\n   \n   # 3. Test state validation\n   # Remove state parameter\n   # Replay old state value\n   \n   # 4. Test PKCE enforcement\n   # Omit code_challenge\n   # Use mismatched code_verifier\n   \n   # 5. Test token handling\n   # Decode JWT tokens\n   # Check expiration times\n   # Attempt token replay\n   \n   # 6. Test logout\n   # Verify token revocation\n   # Test refresh token invalidation\n   ```\n\n8. REMEDIATION BEST PRACTICES:\n\n   Authorization Server:\n   - Strict redirect_uri validation (exact match, no wildcards)\n   - Require state and nonce parameters\n   - Enforce PKCE for all public clients\n   - Issue short-lived access tokens (15 minutes)\n   - Implement refresh token rotation\n   - Validate token audience and issuer\n   - Use RS256 or ES256 for token signing\n   - Implement rate limiting on token endpoint\n\n   Client Application:\n   - Use authorization code flow with PKCE\n   - Validate state and nonce on callback\n   - Verify token signatures\n   - Check token expiration\n   - Store tokens securely (not in localStorage for SPAs)\n   - Implement token refresh logic\n   - Validate redirect destinations on logout\n   - Set proper cookie flags\n\nTOOLS AND RESOURCES:\n- Burp Suite: Web proxy with OAuth extensions\n- OWASP ZAP: Free alternative to Burp\n- jwt_tool: JWT manipulation and analysis (https://github.com/ticarpi/jwt_tool)\n- OAuth 2.0 Playground: https://www.oauth.com/playground/\n- Keycloak: Open-source identity provider for labs\n\nREFERENCES:\n- OAuth 2.0 RFC 6749: https://tools.ietf.org/html/rfc6749\n- OAuth 2.0 Threat Model RFC 6819: https://tools.ietf.org/html/rfc6819\n- OpenID Connect Core: https://openid.net/specs/openid-connect-core-1_0.html\n- PKCE RFC 7636: https://tools.ietf.org/html/rfc7636\n- OWASP OAuth 2.0 Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Security_Cheat_Sheet.html\n- PortSwigger OAuth Testing: https://portswigger.net/web-security/oauth\n\nFor detailed testing methodology and automation scripts, refer to the 'sso-oauth-oidc-misconfig-playbook' in the Tool Instructions panel.",
      "tags": [
        "cloud",
        "oauth",
        "oidc"
      ],
      "related_tools": [
        "hunter-io",
        "recon-ng",
        "sso-oauth-oidc-misconfig-playbook",
        "shodan-cli",
        "federation-attack-scenarios"
      ]
    }
  ]
}